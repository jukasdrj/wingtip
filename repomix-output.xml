This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed, empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/test/**, **/tests/**, **/__tests__/**, **/*.test.*, **/*.spec.*, **/testing/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  ISSUE_TEMPLATE/
    bug_report.yml
    config.yml
    feature_request.yml
    performance_issue.yml
.ralph-tui/
  config.toml
  progress.md
  ralph.lock
  session-meta.json
  session.json
android/
  app/
    src/
      debug/
        AndroidManifest.xml
      main/
        kotlin/
          com/
            wingtip/
              wingtip/
                MainActivity.kt
        res/
          drawable/
            background.png
            launch_background.xml
          drawable-hdpi/
            android12splash.png
            ic_launcher_foreground.png
            splash.png
          drawable-mdpi/
            android12splash.png
            ic_launcher_foreground.png
            splash.png
          drawable-night-hdpi/
            android12splash.png
          drawable-night-mdpi/
            android12splash.png
          drawable-night-xhdpi/
            android12splash.png
          drawable-night-xxhdpi/
            android12splash.png
          drawable-night-xxxhdpi/
            android12splash.png
          drawable-v21/
            background.png
            launch_background.xml
          drawable-xhdpi/
            android12splash.png
            ic_launcher_foreground.png
            splash.png
          drawable-xxhdpi/
            android12splash.png
            ic_launcher_foreground.png
            splash.png
          drawable-xxxhdpi/
            android12splash.png
            ic_launcher_foreground.png
            splash.png
          mipmap-anydpi-v26/
            ic_launcher.xml
          mipmap-hdpi/
            ic_launcher.png
          mipmap-mdpi/
            ic_launcher.png
          mipmap-xhdpi/
            ic_launcher.png
          mipmap-xxhdpi/
            ic_launcher.png
          mipmap-xxxhdpi/
            ic_launcher.png
          values/
            colors.xml
            styles.xml
          values-night/
            styles.xml
          values-night-v31/
            styles.xml
          values-v31/
            styles.xml
        AndroidManifest.xml
      profile/
        AndroidManifest.xml
    build.gradle.kts
  gradle/
    wrapper/
      gradle-wrapper.properties
  .gitignore
  build.gradle.kts
  gradle.properties
  settings.gradle.kts
assets/
  icon/
    icon.png
  images/
    empty_bookshelf.svg
  splash/
    splash.png
docs/
  user-stories.md
ios/
  Flutter/
    AppFrameworkInfo.plist
    Debug.xcconfig
    Release.xcconfig
  Runner/
    Assets.xcassets/
      AppIcon.appiconset/
        Contents.json
        Icon-App-1024x1024@1x.png
        Icon-App-20x20@1x.png
        Icon-App-20x20@2x.png
        Icon-App-20x20@3x.png
        Icon-App-29x29@1x.png
        Icon-App-29x29@2x.png
        Icon-App-29x29@3x.png
        Icon-App-40x40@1x.png
        Icon-App-40x40@2x.png
        Icon-App-40x40@3x.png
        Icon-App-50x50@1x.png
        Icon-App-50x50@2x.png
        Icon-App-57x57@1x.png
        Icon-App-57x57@2x.png
        Icon-App-60x60@2x.png
        Icon-App-60x60@3x.png
        Icon-App-72x72@1x.png
        Icon-App-72x72@2x.png
        Icon-App-76x76@1x.png
        Icon-App-76x76@2x.png
        Icon-App-83.5x83.5@2x.png
      LaunchBackground.imageset/
        background.png
        Contents.json
      LaunchImage.imageset/
        Contents.json
        LaunchImage.png
        LaunchImage@2x.png
        LaunchImage@3x.png
        README.md
    Base.lproj/
      LaunchScreen.storyboard
      Main.storyboard
    AppDelegate.swift
    Info.plist
    Runner-Bridging-Header.h
  Runner.xcodeproj/
    project.xcworkspace/
      xcshareddata/
        IDEWorkspaceChecks.plist
        WorkspaceSettings.xcsettings
      contents.xcworkspacedata
    xcshareddata/
      xcschemes/
        Runner.xcscheme
    project.pbxproj
  Runner.xcworkspace/
    xcshareddata/
      IDEWorkspaceChecks.plist
      WorkspaceSettings.xcsettings
    contents.xcworkspacedata
  RunnerTests/
    RunnerTests.swift
  .gitignore
  Podfile
lib/
  core/
    device_id_provider.dart
    device_id_service.dart
    failed_scans_directory.dart
    network_client.dart
    network_status_provider.dart
    sse_client_provider.dart
    sse_client.dart
    talaria_client_provider.dart
    talaria_client.dart
    theme.dart
  data/
    database_provider.dart
    database.dart
    database.g.dart
    failed_scans_repository.dart
  features/
    camera/
      camera_provider.dart
      camera_screen.dart
      camera_service.dart
      image_processor.dart
      permission_primer_screen.dart
    debug/
      debug_settings_page.dart
    library/
      widgets/
        empty_library_state.dart
      book_detail_bottom_sheet.dart
      library_provider.dart
      library_screen.dart
    talaria/
      job_state_notifier.dart
      job_state_provider.dart
      job_state.dart
      processing_stack_widget.dart
  services/
    csv_export_service_provider.dart
    csv_export_service.dart
  widgets/
    error_snack_bar.dart
    network_status_indicator.dart
  main.dart
tasks/
  epic-4.json
  prd-product-requirements-document-project-wingtip-frontend.md
  prd.json
web/
  icons/
    Icon-192.png
    Icon-512.png
    Icon-maskable-192.png
    Icon-maskable-512.png
  favicon.png
  index.html
  manifest.json
.gitignore
.ios-optimizer.yml
.metadata
analysis_options.yaml
CLAUDE.md
PRD-wingtip.md
pubspec.lock
pubspec.yaml
README.md
repomix.config.json
US-wingtip.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="repomix.config.json">
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "removeComments": true,
    "removeEmptyLines": true
  },
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": [
      "**/test/**",
      "**/tests/**",
      "**/__tests__/**",
      "**/*.test.*",
      "**/*.spec.*",
      "**/testing/**"
    ]
  },
  "security": {
    "enableSecurityCheck": true
  }
}
</file>

<file path=".github/ISSUE_TEMPLATE/bug_report.yml">
name: Bug Report
description: Report a bug or unexpected behavior in the app
title: "[Bug]: "
labels: ["bug", "needs-triage"]
body:
  - type: markdown
    attributes:
      value: |
        Thanks for taking the time to report a bug! Please fill out the information below to help us investigate.
  - type: textarea
    id: description
    attributes:
      label: Description
      description: A clear and concise description of what the bug is.
      placeholder: What happened?
    validations:
      required: true
  - type: textarea
    id: steps
    attributes:
      label: Steps to Reproduce
      description: Steps to reproduce the behavior
      placeholder: |
        1. Go to '...'
        2. Tap on '...'
        3. Scroll down to '...'
        4. See error
    validations:
      required: true
  - type: textarea
    id: expected
    attributes:
      label: Expected Behavior
      description: What did you expect to happen?
    validations:
      required: true
  - type: textarea
    id: actual
    attributes:
      label: Actual Behavior
      description: What actually happened?
    validations:
      required: true
  - type: textarea
    id: screenshots
    attributes:
      label: Screenshots
      description: If applicable, add screenshots to help explain your problem.
  - type: dropdown
    id: platform
    attributes:
      label: Platform
      description: Which platform(s) are you experiencing this issue on?
      multiple: true
      options:
        - iOS
        - Android
        - Web
        - macOS
        - Windows
        - Linux
    validations:
      required: true
  - type: input
    id: flutter-version
    attributes:
      label: Flutter Version
      description: Run `flutter --version` and paste the output
      placeholder: "Flutter 3.x.x"
    validations:
      required: true
  - type: input
    id: device
    attributes:
      label: Device/Emulator
      description: What device or emulator are you using?
      placeholder: "iPhone 15 Pro / Pixel 8 / Chrome Browser"
  - type: textarea
    id: logs
    attributes:
      label: Logs
      description: Please copy and paste any relevant log output. This will be automatically formatted.
      render: shell
  - type: textarea
    id: context
    attributes:
      label: Additional Context
      description: Add any other context about the problem here.
</file>

<file path=".github/ISSUE_TEMPLATE/config.yml">
blank_issues_enabled: false
contact_links:
  - name: Question or Discussion
    url: https://github.com/jukasdrj/wingtip/discussions
    about: Please use GitHub Discussions for questions and general discussions
  - name: Flutter Documentation
    url: https://docs.flutter.dev
    about: Official Flutter documentation and guides
</file>

<file path=".github/ISSUE_TEMPLATE/feature_request.yml">
name: Feature Request
description: Suggest a new feature or enhancement
title: "[Feature]: "
labels: ["enhancement", "needs-triage"]
body:
  - type: markdown
    attributes:
      value: |
        Thanks for suggesting a new feature! Please provide as much detail as possible.
  - type: textarea
    id: problem
    attributes:
      label: Problem Statement
      description: Is your feature request related to a problem? Please describe.
      placeholder: I'm always frustrated when...
    validations:
      required: true
  - type: textarea
    id: solution
    attributes:
      label: Proposed Solution
      description: Describe the solution you'd like to see
      placeholder: I would like to...
    validations:
      required: true
  - type: textarea
    id: alternatives
    attributes:
      label: Alternatives Considered
      description: Describe any alternative solutions or features you've considered
  - type: dropdown
    id: priority
    attributes:
      label: Priority
      description: How important is this feature to you?
      options:
        - Low - Nice to have
        - Medium - Would improve experience
        - High - Critical for my use case
    validations:
      required: true
  - type: dropdown
    id: platform
    attributes:
      label: Target Platform
      description: Which platform(s) should this feature support?
      multiple: true
      options:
        - iOS
        - Android
        - Web
        - macOS
        - Windows
        - Linux
        - All platforms
  - type: textarea
    id: mockups
    attributes:
      label: Mockups/Examples
      description: If applicable, add mockups, sketches, or examples from other apps
  - type: textarea
    id: context
    attributes:
      label: Additional Context
      description: Add any other context or information about the feature request
</file>

<file path=".github/ISSUE_TEMPLATE/performance_issue.yml">
name: Performance Issue
description: Report performance problems like lag, crashes, or high resource usage
title: "[Performance]: "
labels: ["performance", "needs-triage"]
body:
  - type: markdown
    attributes:
      value: |
        Thanks for reporting a performance issue! Please provide detailed information to help us investigate.
  - type: textarea
    id: description
    attributes:
      label: Description
      description: Describe the performance issue you're experiencing
      placeholder: The app becomes unresponsive when...
    validations:
      required: true
  - type: dropdown
    id: issue-type
    attributes:
      label: Issue Type
      description: What kind of performance issue are you experiencing?
      options:
        - App crash
        - UI lag/jank
        - Slow loading
        - High memory usage
        - High CPU usage
        - Battery drain
        - Other
    validations:
      required: true
  - type: textarea
    id: steps
    attributes:
      label: Steps to Reproduce
      description: How can we reproduce this performance issue?
      placeholder: |
        1. Open the app
        2. Navigate to '...'
        3. Perform action '...'
        4. Observe lag/crash
    validations:
      required: true
  - type: dropdown
    id: frequency
    attributes:
      label: Frequency
      description: How often does this issue occur?
      options:
        - Always
        - Often (>50% of the time)
        - Sometimes (10-50% of the time)
        - Rarely (<10% of the time)
    validations:
      required: true
  - type: dropdown
    id: platform
    attributes:
      label: Platform
      description: Which platform(s) are you experiencing this issue on?
      multiple: true
      options:
        - iOS
        - Android
        - Web
        - macOS
        - Windows
        - Linux
    validations:
      required: true
  - type: input
    id: flutter-version
    attributes:
      label: Flutter Version
      description: Run `flutter --version` and paste the output
      placeholder: "Flutter 3.x.x"
    validations:
      required: true
  - type: input
    id: device
    attributes:
      label: Device/Emulator
      description: What device or emulator are you using?
      placeholder: "iPhone 15 Pro / Pixel 8"
    validations:
      required: true
  - type: dropdown
    id: build-mode
    attributes:
      label: Build Mode
      description: Which build mode were you running?
      options:
        - Debug
        - Profile
        - Release
    validations:
      required: true
  - type: textarea
    id: profiling
    attributes:
      label: Profiling Data
      description: If you've run Flutter DevTools profiler, paste relevant data here
      render: shell
  - type: textarea
    id: logs
    attributes:
      label: Logs/Stack Trace
      description: Please copy and paste any relevant log output or crash stack traces
      render: shell
  - type: textarea
    id: context
    attributes:
      label: Additional Context
      description: Add any other context about the performance issue
</file>

<file path=".ralph-tui/config.toml">
# Ralph TUI Configuration
# Generated by setup wizard
# See: ralph-tui config help

configVersion = "2.1"
tracker = "json"
agent = "claude"
maxIterations = 25
autoCommit = true

[trackerOptions]
[agentOptions]
</file>

<file path="android/app/src/debug/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
</file>

<file path="android/app/src/main/kotlin/com/wingtip/wingtip/MainActivity.kt">
package com.wingtip.wingtip
import io.flutter.embedding.android.FlutterActivity
class MainActivity : FlutterActivity()
</file>

<file path="android/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml">
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
  <background android:drawable="@color/ic_launcher_background"/>
  <foreground>
      <inset
          android:drawable="@drawable/ic_launcher_foreground"
          android:inset="16%" />
  </foreground>
</adaptive-icon>
</file>

<file path="android/app/src/main/res/values/colors.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="ic_launcher_background">#000000</color>
</resources>
</file>

<file path="android/app/src/main/res/values-night-v31/styles.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:forceDarkAllowed">false</item>
        <item name="android:windowFullscreen">false</item>
        <item name="android:windowDrawsSystemBarBackgrounds">false</item>
        <item name="android:windowLayoutInDisplayCutoutMode">shortEdges</item>
        <item name="android:windowSplashScreenBackground">#000000</item>
        <item name="android:windowSplashScreenAnimatedIcon">@drawable/android12splash</item>
    </style>
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
</file>

<file path="android/app/src/main/res/values-v31/styles.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:forceDarkAllowed">false</item>
        <item name="android:windowFullscreen">false</item>
        <item name="android:windowDrawsSystemBarBackgrounds">false</item>
        <item name="android:windowLayoutInDisplayCutoutMode">shortEdges</item>
        <item name="android:windowSplashScreenBackground">#000000</item>
        <item name="android:windowSplashScreenAnimatedIcon">@drawable/android12splash</item>
    </style>
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
</file>

<file path="android/app/src/profile/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
</file>

<file path="android/gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.14-all.zip
</file>

<file path="android/.gitignore">
gradle-wrapper.jar
/.gradle
/captures/
/gradlew
/gradlew.bat
/local.properties
GeneratedPluginRegistrant.java
.cxx/

# Remember to never publicly share your keystore.
# See https://flutter.dev/to/reference-keystore
key.properties
**/*.keystore
**/*.jks
</file>

<file path="android/build.gradle.kts">
allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory =
    rootProject.layout.buildDirectory
        .dir("../../build")
        .get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}
subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}
</file>

<file path="android/gradle.properties">
org.gradle.jvmargs=-Xmx8G -XX:MaxMetaspaceSize=4G -XX:ReservedCodeCacheSize=512m -XX:+HeapDumpOnOutOfMemoryError
android.useAndroidX=true
</file>

<file path="android/settings.gradle.kts">
pluginManagement {
    val flutterSdkPath =
        run {
            val properties = java.util.Properties()
            file("local.properties").inputStream().use { properties.load(it) }
            val flutterSdkPath = properties.getProperty("flutter.sdk")
            require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
            flutterSdkPath
        }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.11.1" apply false
    id("org.jetbrains.kotlin.android") version "2.2.20" apply false
}

include(":app")
</file>

<file path="assets/images/empty_bookshelf.svg">
<svg width="120" height="120" viewBox="0 0 120 120" fill="none" xmlns="http://www.w3.org/2000/svg">
  <!-- Simple bookshelf outline in Swiss Utility style -->
  <!-- Top shelf -->
  <rect x="20" y="30" width="80" height="1" fill="white"/>

  <!-- Middle shelf -->
  <rect x="20" y="60" width="80" height="1" fill="white"/>

  <!-- Bottom shelf -->
  <rect x="20" y="90" width="80" height="1" fill="white"/>

  <!-- Left vertical -->
  <rect x="20" y="30" width="1" height="60" fill="white"/>

  <!-- Right vertical -->
  <rect x="99" y="30" width="1" height="60" fill="white"/>

  <!-- Book spines (minimal outlines) -->
  <rect x="30" y="32" width="12" height="26" stroke="white" stroke-width="1" fill="none"/>
  <rect x="45" y="32" width="10" height="26" stroke="white" stroke-width="1" fill="none"/>
  <rect x="58" y="32" width="15" height="26" stroke="white" stroke-width="1" fill="none"/>

  <rect x="25" y="62" width="14" height="26" stroke="white" stroke-width="1" fill="none"/>
  <rect x="42" y="62" width="11" height="26" stroke="white" stroke-width="1" fill="none"/>
  <rect x="56" y="62" width="13" height="26" stroke="white" stroke-width="1" fill="none"/>
  <rect x="72" y="62" width="12" height="26" stroke="white" stroke-width="1" fill="none"/>
</svg>
</file>

<file path="docs/user-stories.md">
# User Stories: Project Wingtip (MVP)

## Design Language: "Swiss Utility"

* **Typography:** *JetBrains Mono* (headers/data) + *Inter* (body)
* **Palette:** `#000000` (Background), `#FFFFFF` (Text), `#FF3B30` (Accent - "International Orange" for status/action)
* **Borders:** 1px solid white borders on cards. No drop shadows
* **Motion:** 0ms delay. Snap transitions

---

## Epic 1: Foundations & Architecture

*Building the "skeleton" of the app.*

### US-101: Initialize Flutter Project with Riverpod & Drift

**As a** developer
**I want to** scaffold the app with the latest Flutter stack
**So that** I have a stable foundation for state and data

**Acceptance Criteria:**
- [ ] Project created with `com.ooheynerds.wingtip`
- [ ] `flutter_riverpod` (v3) installed and `ProviderScope` configured
- [ ] `drift` (v2) installed with `sqlite3_flutter_libs` for native performance
- [ ] Folder structure set: `features/`, `core/`, `data/`

**Priority:** P0 (Critical)
**Estimate:** 2 hours
**Dependencies:** None

---

### US-102: Implement "Swiss Utility" Theme System

**As a** user
**I want to** experience a high-contrast, clean interface
**So that** the app feels precise and professional

**Acceptance Criteria:**
- [ ] Theme mode locked to **Dark** (OLED black)
- [ ] Font set to *JetBrains Mono* for all numbers/IDs and *Inter* for text
- [ ] Components use 1px solid borders instead of shadows (flat design)
- [ ] Accent color defined as `#FF3B30` (International Orange)

**Priority:** P0 (Critical)
**Estimate:** 3 hours
**Dependencies:** US-101

---

### US-103: Generate & Store Persistent Device ID

**As a** system
**I want to** generate a UUID v4 on first launch
**So that** I can authenticate with the Talaria backend

**Acceptance Criteria:**
- [ ] On first run, generate `uuid.v4()`
- [ ] Store securely in `FlutterSecureStorage` key `device_id`
- [ ] Inject `X-Device-ID` header into all Dio requests
- [ ] Provide a "Regenerate ID" button in debug settings

**Priority:** P0 (Critical)
**Estimate:** 2 hours
**Dependencies:** US-101

---

### US-104: Offline-First Network Client

**As a** system
**I want to** queue requests when offline
**So that** I don't lose scans if the network drops

**Acceptance Criteria:**
- [ ] Configure `Dio` with a connection retry interceptor
- [ ] Detect network status (Connectivity Plus)
- [ ] If offline, show a subtle "OFFLINE" tag in the top-right corner (Swiss style: small text, boxed border)

**Priority:** P1 (High)
**Estimate:** 4 hours
**Dependencies:** US-103

---

## Epic 2: The Viewfinder (Capture)

*The primary interface. Fast, dumb, and responsive.*

### US-105: Instant Camera Initialization

**As a** user
**I want to** see the camera immediately upon opening the app
**So that** I can capture a book spine instantly

**Acceptance Criteria:**
- [ ] App launches directly to `CameraScreen`
- [ ] Cold start to live feed < 1.0s
- [ ] Hide system status bar for full immersion

**Priority:** P0 (Critical)
**Estimate:** 4 hours
**Dependencies:** US-101, US-102

---

### US-106: Non-Blocking Shutter Action

**As a** user
**I want to** tap the shutter button repeatedly without waiting
**So that** I can scan a whole shelf in seconds

**Acceptance Criteria:**
- [ ] Shutter button is a large, white ring at bottom center
- [ ] On tap: Haptic "Tick" (Light impact)
- [ ] On tap: Screen flashes white (100ms opacity)
- [ ] UI does **not** show a loading spinner on the button itself (always clickable)

**Priority:** P0 (Critical)
**Estimate:** 3 hours
**Dependencies:** US-105

---

### US-107: Background Image Processing

**As a** system
**I want to** compress and resize images in a background Isolate
**So that** the UI thread never janks

**Acceptance Criteria:**
- [ ] Spawn `compute` isolate for image manipulation
- [ ] Resize to max 1920px (height or width) to save bandwidth
- [ ] Compress to JPEG (quality 85)
- [ ] Save temporary file to `NSTemporaryDirectory`

**Priority:** P0 (Critical)
**Estimate:** 4 hours
**Dependencies:** US-106

---

### US-108: The "Processing Stack" UI

**As a** user
**I want to** see my active uploads as a queue
**So that** I know the system is working

**Acceptance Criteria:**
- [ ] Horizontal list above the shutter button
- [ ] Each item is a 40x60px thumbnail of the photo
- [ ] Status indicators: "Uploading" (Yellow border), "Analyzing" (Blue border), "Done" (Green border)
- [ ] Auto-remove card after 5 seconds of "Done" state

**Priority:** P1 (High)
**Estimate:** 5 hours
**Dependencies:** US-107

---

### US-109: Manual Focus & Zoom

**As a** user
**I want to** pinch to zoom and tap to focus
**So that** I can capture small text on spines

**Acceptance Criteria:**
- [ ] Pinch gesture controls camera zoom level (1x - 4x)
- [ ] Tap on preview sets focus point
- [ ] Show a square bracket cursor `[ ]` at focus point (Swiss style)

**Priority:** P1 (High)
**Estimate:** 3 hours
**Dependencies:** US-105

---

## Epic 3: The Talaria Link (Integration)

*Connecting to the backend brain.*

### US-110: Upload Image to Talaria

**As a** system
**I want to** POST the image to `/v3/jobs/scans`
**So that** I can start the analysis pipeline

**Acceptance Criteria:**
- [ ] Multipart upload of the processed JPEG
- [ ] Handle `202 Accepted` response
- [ ] Parse `jobId` and `streamUrl` from response
- [ ] Update UI state to "Listening"

**Priority:** P0 (Critical)
**Estimate:** 4 hours
**Dependencies:** US-107, US-103

---

### US-111: SSE Stream Listener

**As a** system
**I want to** listen to Server-Sent Events for a specific Job ID
**So that** I receive real-time updates

**Acceptance Criteria:**
- [ ] Open connection to `streamUrl` using `fetch_client`
- [ ] Maintain open connection until `complete` event or timeout (5m)
- [ ] Parse incoming JSON chunks (`progress`, `result`, `complete`)

**Priority:** P0 (Critical)
**Estimate:** 5 hours
**Dependencies:** US-110

---

### US-112: Visualize "Progress" Events

**As a** user
**I want to** see text updates as the AI thinks
**So that** I feel the speed of the system

**Acceptance Criteria:**
- [ ] Overlay transparent text on the specific job thumbnail
- [ ] Display `stage` messages: "Looking...", "Reading...", "Enriching..."
- [ ] Use Monospace font for these logs

**Priority:** P1 (High)
**Estimate:** 3 hours
**Dependencies:** US-111, US-108

---

### US-113: Handle "Result" Events (Data Upsert)

**As a** system
**I want to** save incoming book data immediately
**So that** the user sees results before the job finishes

**Acceptance Criteria:**
- [ ] Listen for `event: result`
- [ ] Map JSON to Drift `Book` entity
- [ ] `INSERT OR REPLACE` into local DB (deduplicate by ISBN)
- [ ] Trigger a specific haptic pattern (Double Click) on success

**Priority:** P0 (Critical)
**Estimate:** 4 hours
**Dependencies:** US-111, US-116

---

### US-114: Handle "Complete" & Cleanup

**As a** system
**I want to** clean up resources when a job finishes
**So that** I don't waste storage or battery

**Acceptance Criteria:**
- [ ] Listen for `event: complete`
- [ ] Send `DELETE /v3/jobs/scans/{jobId}/cleanup` request
- [ ] Delete local temporary JPEG file
- [ ] Close SSE connection

**Priority:** P0 (Critical)
**Estimate:** 3 hours
**Dependencies:** US-111

---

### US-115: Handle Global Rate Limits

**As a** user
**I want to** know if I've hit the daily limit
**So that** I don't waste time snapping photos

**Acceptance Criteria:**
- [ ] Intercept `429 Too Many Requests`
- [ ] Parse `retryAfterMs`
- [ ] Disable shutter button
- [ ] Show a countdown timer overlay: "LIMIT REACHED. RESETS IN HH:MM:SS"

**Priority:** P1 (High)
**Estimate:** 3 hours
**Dependencies:** US-110

---

## Epic 4: The Library (Drift DB)

*The permanent home for the data.*

### US-116: Drift Database Schema

**As a** developer
**I want to** define the `Books` table
**So that** I can store metadata efficiently

**Acceptance Criteria:**
- [ ] Columns: `isbn` (PK), `title`, `author`, `coverUrl`, `format`, `addedDate`, `spineConfidence`
- [ ] Index on `addedDate` (descending) for default sort

**Priority:** P0 (Critical)
**Estimate:** 2 hours
**Dependencies:** US-101

---

### US-117: Library Grid View

**As a** user
**I want to** see my books in a clean grid
**So that** I can browse my collection

**Acceptance Criteria:**
- [ ] 3-column grid of cover images
- [ ] Aspect ratio 1:1.5 (Standard book size)
- [ ] If no cover URL, show a solid grey card with Title/Author in monospace text
- [ ] Infinite scroll (lazy loading from Drift)

**Priority:** P0 (Critical)
**Estimate:** 5 hours
**Dependencies:** US-116, US-102

---

### US-118: Real-time List Updates

**As a** user
**I want to** see new books pop in automatically
**So that** I don't have to pull-to-refresh

**Acceptance Criteria:**
- [ ] Use Drift's `watch()` method to stream DB updates to the UI
- [ ] Animate new items: Fade in + Slide up (200ms)

**Priority:** P1 (High)
**Estimate:** 3 hours
**Dependencies:** US-117

---

### US-119: Full-Text Search (FTS5)

**As a** user
**I want to** search my library instantly
**So that** I can find a specific book

**Acceptance Criteria:**
- [ ] Enable FTS5 module in Drift
- [ ] Search bar at top of Library view
- [ ] Queries filter `title`, `author`, and `isbn`
- [ ] Results update as I type (< 100ms latency)

**Priority:** P1 (High)
**Estimate:** 4 hours
**Dependencies:** US-116, US-117

---

### US-120: "Review Needed" Indicator

**As a** user
**I want to** see which books had low confidence
**So that** I can manually check them

**Acceptance Criteria:**
- [ ] Check `flag: review_needed` from backend
- [ ] Overlay a small yellow triangle icon on the book cover
- [ ] Sort option: "Needs Review First"

**Priority:** P2 (Medium)
**Estimate:** 3 hours
**Dependencies:** US-117, US-113

---

### US-121: Export Data to CSV

**As a** user
**I want to** export my library
**So that** I own my data

**Acceptance Criteria:**
- [ ] "Export" button in settings
- [ ] Generates `wingtip_library_[date].csv`
- [ ] Opens system share sheet (Save to Files, AirDrop, etc.)

**Priority:** P2 (Medium)
**Estimate:** 3 hours
**Dependencies:** US-116

---

## Epic 5: Detail & Interaction

*The "Swiss Utility" feel comes from these interaction details.*

### US-122: Minimal Book Detail View

**As a** user
**I want to** tap a book to see its data
**So that** I can verify the scan

**Acceptance Criteria:**
- [ ] Modal bottom sheet (dragging up to full screen)
- [ ] Layout: Large Cover (Left) + Data Fields (Right) - "Passport style"
- [ ] Fields: ISBN (Monospace), Title (Bold), Author, Format
- [ ] Edit button to manually correct fields

**Priority:** P1 (High)
**Estimate:** 5 hours
**Dependencies:** US-117, US-102

---

### US-123: The "Raw Data" Toggle

**As a** user
**I want to** see the raw JSON for a book
**So that** I can geek out on the metadata

**Acceptance Criteria:**
- [ ] Toggle switch in Detail View: "Visual" vs "JSON"
- [ ] JSON view displays formatted code block in monospace green

**Priority:** P3 (Low)
**Estimate:** 2 hours
**Dependencies:** US-122

---

### US-124: Swipe to Delete

**As a** user
**I want to** remove bad scans easily
**So that** my library stays clean

**Acceptance Criteria:**
- [ ] In Library view, long-press to enter "Select Mode"
- [ ] Select multiple items -> Tap Trash icon
- [ ] Confirm dialog: "Delete X books?"

**Priority:** P2 (Medium)
**Estimate:** 4 hours
**Dependencies:** US-117

---

### US-125: Haptic Feedback Strategy

**As a** user
**I want to** feel the app working
**So that** I don't have to look at the screen constantly

**Acceptance Criteria:**
- [ ] Shutter: `HapticFeedback.lightImpact()`
- [ ] Scan Success: `HapticFeedback.mediumImpact()`
- [ ] Error: `HapticFeedback.heavyImpact()`

**Priority:** P1 (High)
**Estimate:** 2 hours
**Dependencies:** US-106, US-113

---

### US-126: Cache Manager

**As a** user
**I want to** clear cached cover images
**So that** the app doesn't eat up my storage

**Acceptance Criteria:**
- [ ] Settings option: "Clear Image Cache"
- [ ] Uses `DefaultCacheManager.emptyCache()`
- [ ] Shows current cache size (e.g., "Cache: 124 MB")

**Priority:** P2 (Medium)
**Estimate:** 3 hours
**Dependencies:** US-117

---

## Epic 6: Polish & Launch

*Getting ready for the store.*

### US-127: App Icon & Splash Screen

**As a** user
**I want to** recognize the app on my home screen
**So that** I can launch it quickly

**Acceptance Criteria:**
- [ ] Icon: Abstract white "Wing" glyph on Black background
- [ ] Splash: Black screen, white "Wingtip" text (Monospace), fades out

**Priority:** P2 (Medium)
**Estimate:** 3 hours
**Dependencies:** US-102

---

### US-128: Permission Priming

**As a** user
**I want to** understand why you need camera access
**So that** I trust the app

**Acceptance Criteria:**
- [ ] Before requesting permission, show a full-screen "Primer" slide
- [ ] Text: "Wingtip needs your camera to see books. Images are processed and deleted instantly."
- [ ] "Grant Access" button triggers OS prompt

**Priority:** P1 (High)
**Estimate:** 3 hours
**Dependencies:** US-105

---

### US-129: Empty States

**As a** user
**I want to** see helpful text when my library is empty
**So that** I know what to do

**Acceptance Criteria:**
- [ ] Library View empty state: "0 Books. Tap [O] to scan."
- [ ] Use ASCII art or a simple vector outline of a bookshelf

**Priority:** P2 (Medium)
**Estimate:** 2 hours
**Dependencies:** US-117

---

### US-130: Error Toasts (Snackbars)

**As a** user
**I want to** see errors without them blocking me
**So that** I can keep scanning

**Acceptance Criteria:**
- [ ] Custom Snackbar design
- [ ] Black background, white text, red left border
- [ ] Floating at bottom of screen
- [ ] Dismiss on tap

**Priority:** P1 (High)
**Estimate:** 2 hours
**Dependencies:** US-102

---

## Summary Statistics

**Total User Stories:** 30
**Total Estimated Hours:** 98 hours (~12-13 days)

### Priority Breakdown
- **P0 (Critical):** 13 stories
- **P1 (High):** 11 stories
- **P2 (Medium):** 5 stories
- **P3 (Low):** 1 story

### Epic Breakdown
- **Epic 1 (Foundations):** 4 stories, 11 hours
- **Epic 2 (Viewfinder):** 5 stories, 19 hours
- **Epic 3 (Talaria Link):** 6 stories, 22 hours
- **Epic 4 (Library):** 6 stories, 20 hours
- **Epic 5 (Detail & Interaction):** 5 stories, 16 hours
- **Epic 6 (Polish & Launch):** 4 stories, 10 hours

### Critical Path (MVP)
For a minimal viable product, focus on P0 stories first:
1. US-101 → US-102 → US-103 → US-116 (Foundation: 9 hours)
2. US-105 → US-106 → US-107 (Camera: 11 hours)
3. US-110 → US-111 → US-113 → US-114 (Integration: 16 hours)
4. US-117 (Library: 5 hours)

**MVP Total: ~41 hours (5-6 days)**
</file>

<file path="ios/Flutter/AppFrameworkInfo.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>CFBundleDevelopmentRegion</key>
  <string>en</string>
  <key>CFBundleExecutable</key>
  <string>App</string>
  <key>CFBundleIdentifier</key>
  <string>io.flutter.flutter.app</string>
  <key>CFBundleInfoDictionaryVersion</key>
  <string>6.0</string>
  <key>CFBundleName</key>
  <string>App</string>
  <key>CFBundlePackageType</key>
  <string>FMWK</string>
  <key>CFBundleShortVersionString</key>
  <string>1.0</string>
  <key>CFBundleSignature</key>
  <string>????</string>
  <key>CFBundleVersion</key>
  <string>1.0</string>
  <key>MinimumOSVersion</key>
  <string>13.0</string>
</dict>
</plist>
</file>

<file path="ios/Runner/Assets.xcassets/LaunchBackground.imageset/Contents.json">
{
  "images" : [
    {
      "filename" : "background.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="ios/Runner/Assets.xcassets/LaunchImage.imageset/README.md">
# Launch Screen Assets

You can customize the launch screen with your own desired assets by replacing the image files in this directory.

You can also do it by opening your Flutter project's Xcode project with `open ios/Runner.xcworkspace`, selecting `Runner/Assets.xcassets` in the Project Navigator and dropping in the desired images.
</file>

<file path="ios/Runner/Base.lproj/Main.storyboard">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="10117" systemVersion="15F34" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" initialViewController="BYZ-38-t0r">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="10085"/>
    </dependencies>
    <scenes>
        <!--Flutter View Controller-->
        <scene sceneID="tne-QT-ifu">
            <objects>
                <viewController id="BYZ-38-t0r" customClass="FlutterViewController" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="y3c-jy-aDJ"/>
                        <viewControllerLayoutGuide type="bottom" id="wfy-db-euE"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="8bC-Xf-vdC">
                        <rect key="frame" x="0.0" y="0.0" width="600" height="600"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" white="1" alpha="1" colorSpace="custom" customColorSpace="calibratedWhite"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="dkx-z0-nzr" sceneMemberID="firstResponder"/>
            </objects>
        </scene>
    </scenes>
</document>
</file>

<file path="ios/Runner/AppDelegate.swift">
import Flutter
import UIKit
@main
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    GeneratedPluginRegistrant.register(with: self)
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}
</file>

<file path="ios/Runner/Runner-Bridging-Header.h">
#import "GeneratedPluginRegistrant.h"
</file>

<file path="ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>
</file>

<file path="ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>PreviewsEnabled</key>
	<false/>
</dict>
</plist>
</file>

<file path="ios/Runner.xcodeproj/project.xcworkspace/contents.xcworkspacedata">
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>
</file>

<file path="ios/Runner.xcodeproj/xcshareddata/xcschemes/Runner.xcscheme">
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1510"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "97C146ED1CF9000F007C117D"
               BuildableName = "Runner.app"
               BlueprintName = "Runner"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      customLLDBInitFile = "$(SRCROOT)/Flutter/ephemeral/flutter_lldbinit"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
            BuildableName = "Runner.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
      <Testables>
         <TestableReference
            skipped = "NO"
            parallelizable = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "331C8080294A63A400263BE5"
               BuildableName = "RunnerTests.xctest"
               BlueprintName = "RunnerTests"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      customLLDBInitFile = "$(SRCROOT)/Flutter/ephemeral/flutter_lldbinit"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      enableGPUValidationMode = "1"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
            BuildableName = "Runner.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Profile"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
            BuildableName = "Runner.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>
</file>

<file path="ios/Runner.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>
</file>

<file path="ios/Runner.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>PreviewsEnabled</key>
	<false/>
</dict>
</plist>
</file>

<file path="ios/Runner.xcworkspace/contents.xcworkspacedata">
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "group:Runner.xcodeproj">
   </FileRef>
</Workspace>
</file>

<file path="ios/RunnerTests/RunnerTests.swift">
import Flutter
import UIKit
import XCTest
class RunnerTests: XCTestCase {
  func testExample() {
  }
}
</file>

<file path="ios/.gitignore">
**/dgph
*.mode1v3
*.mode2v3
*.moved-aside
*.pbxuser
*.perspectivev3
**/*sync/
.sconsign.dblite
.tags*
**/.vagrant/
**/DerivedData/
Icon?
**/Pods/
**/.symlinks/
profile
xcuserdata
**/.generated/
Flutter/App.framework
Flutter/Flutter.framework
Flutter/Flutter.podspec
Flutter/Generated.xcconfig
Flutter/ephemeral/
Flutter/app.flx
Flutter/app.zip
Flutter/flutter_assets/
Flutter/flutter_export_environment.sh
ServiceDefinitions.json
Runner/GeneratedPluginRegistrant.*

# Exceptions to above rules.
!default.mode1v3
!default.mode2v3
!default.pbxuser
!default.perspectivev3
</file>

<file path="ios/Podfile">
# Uncomment this line to define a global platform for your project
# platform :ios, '13.0'

# CocoaPods analytics sends network stats synchronously affecting flutter build latency.
ENV['COCOAPODS_DISABLE_STATS'] = 'true'

project 'Runner', {
  'Debug' => :debug,
  'Profile' => :release,
  'Release' => :release,
}

def flutter_root
  generated_xcode_build_settings_path = File.expand_path(File.join('..', 'Flutter', 'Generated.xcconfig'), __FILE__)
  unless File.exist?(generated_xcode_build_settings_path)
    raise "#{generated_xcode_build_settings_path} must exist. If you're running pod install manually, make sure flutter pub get is executed first"
  end

  File.foreach(generated_xcode_build_settings_path) do |line|
    matches = line.match(/FLUTTER_ROOT\=(.*)/)
    return matches[1].strip if matches
  end
  raise "FLUTTER_ROOT not found in #{generated_xcode_build_settings_path}. Try deleting Generated.xcconfig, then run flutter pub get"
end

require File.expand_path(File.join('packages', 'flutter_tools', 'bin', 'podhelper'), flutter_root)

flutter_ios_podfile_setup

target 'Runner' do
  use_frameworks!

  flutter_install_all_ios_pods File.dirname(File.realpath(__FILE__))
  target 'RunnerTests' do
    inherit! :search_paths
  end
end

post_install do |installer|
  installer.pods_project.targets.each do |target|
    flutter_additional_ios_build_settings(target)
  end
end
</file>

<file path="lib/core/device_id_provider.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wingtip/core/device_id_service.dart';
final deviceIdServiceProvider = Provider<DeviceIdService>((ref) {
  return DeviceIdService();
});
final deviceIdProvider = FutureProvider<String>((ref) async {
  final service = ref.watch(deviceIdServiceProvider);
  return await service.getDeviceId();
});
</file>

<file path="lib/core/device_id_service.dart">
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:uuid/uuid.dart';
class DeviceIdService {
  DeviceIdService({
    FlutterSecureStorage? secureStorage,
  }) : _secureStorage = secureStorage ?? const FlutterSecureStorage();
  final FlutterSecureStorage _secureStorage;
  static const String _deviceIdKey = 'device_id';
  static const Uuid _uuid = Uuid();
  Future<String> getDeviceId() async {
    String? deviceId = await _secureStorage.read(key: _deviceIdKey);
    if (deviceId == null || deviceId.isEmpty) {
      deviceId = _generateDeviceId();
      await _secureStorage.write(key: _deviceIdKey, value: deviceId);
    }
    return deviceId;
  }
  String _generateDeviceId() {
    return _uuid.v4();
  }
  Future<String> regenerateDeviceId() async {
    final newDeviceId = _generateDeviceId();
    await _secureStorage.write(key: _deviceIdKey, value: newDeviceId);
    return newDeviceId;
  }
  Future<void> clearDeviceId() async {
    await _secureStorage.delete(key: _deviceIdKey);
  }
}
</file>

<file path="lib/core/failed_scans_directory.dart">
import 'dart:io';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';
class FailedScansDirectory {
  static const String _dirName = 'failed_scans';
  static Future<Directory> getDirectory() async {
    final appDocsDir = await getApplicationDocumentsDirectory();
    final failedScansDir = Directory(p.join(appDocsDir.path, _dirName));
    if (!await failedScansDir.exists()) {
      await failedScansDir.create(recursive: true);
    }
    return failedScansDir;
  }
  static Future<String> getImagePath(String jobId) async {
    final dir = await getDirectory();
    return p.join(dir.path, '$jobId.jpg');
  }
  static Future<String> moveImage(String sourcePath, String jobId) async {
    final sourceFile = File(sourcePath);
    if (!await sourceFile.exists()) {
      throw Exception('Source image does not exist: $sourcePath');
    }
    final destinationPath = await getImagePath(jobId);
    await sourceFile.copy(destinationPath);
    await sourceFile.delete();
    return destinationPath;
  }
  static Future<void> deleteImage(String jobId) async {
    final imagePath = await getImagePath(jobId);
    final imageFile = File(imagePath);
    if (await imageFile.exists()) {
      await imageFile.delete();
    }
  }
  static Future<bool> imageExists(String jobId) async {
    final imagePath = await getImagePath(jobId);
    return await File(imagePath).exists();
  }
}
</file>

<file path="lib/core/network_status_provider.dart">
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
final networkStatusProvider = StreamProvider<bool>((ref) {
  final connectivity = Connectivity();
  return connectivity.onConnectivityChanged.map((results) {
    return results.any((result) =>
        result == ConnectivityResult.mobile ||
        result == ConnectivityResult.wifi ||
        result == ConnectivityResult.ethernet);
  });
});
</file>

<file path="lib/core/sse_client_provider.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wingtip/core/sse_client.dart';
final sseClientProvider = Provider<SseClient>((ref) {
  return SseClient(
    timeout: const Duration(minutes: 5),
    maxRetries: 3,
    initialRetryDelay: const Duration(milliseconds: 500),
  );
});
</file>

<file path="lib/core/sse_client.dart">
import 'dart:async';
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;
enum SseEventType {
  progress,
  result,
  complete,
  error,
}
class SseEvent {
  final SseEventType type;
  final Map<String, dynamic> data;
  const SseEvent({
    required this.type,
    required this.data,
  });
  factory SseEvent.fromJson(Map<String, dynamic> json) {
    final typeString = json['type'] as String?;
    final type = switch (typeString) {
      'progress' => SseEventType.progress,
      'result' => SseEventType.result,
      'complete' => SseEventType.complete,
      'error' => SseEventType.error,
      _ => throw FormatException('Unknown event type: $typeString'),
    };
    return SseEvent(
      type: type,
      data: json['data'] as Map<String, dynamic>? ?? {},
    );
  }
  @override
  String toString() => 'SseEvent(type: $type, data: $data)';
}
class SseClient {
  final Duration timeout;
  final int maxRetries;
  final Duration initialRetryDelay;
  SseClient({
    this.timeout = const Duration(minutes: 5),
    this.maxRetries = 3,
    this.initialRetryDelay = const Duration(milliseconds: 500),
  });
  Stream<SseEvent> listen(String streamUrl) async* {
    int retryCount = 0;
    http.Client? client;
    while (retryCount <= maxRetries) {
      try {
        client = http.Client();
        debugPrint('[SseClient] Connecting to: $streamUrl (attempt ${retryCount + 1})');
        final request = http.Request('GET', Uri.parse(streamUrl));
        request.headers['Accept'] = 'text/event-stream';
        request.headers['Cache-Control'] = 'no-cache';
        final streamedResponse = await client.send(request).timeout(timeout);
        if (streamedResponse.statusCode != 200) {
          throw Exception(
            'SSE connection failed with status ${streamedResponse.statusCode}',
          );
        }
        debugPrint('[SseClient] Connected successfully');
        await for (final event in _parseEventStream(streamedResponse.stream)) {
          debugPrint('[SseClient] Received event: $event');
          yield event;
          if (event.type == SseEventType.complete ||
              event.type == SseEventType.error) {
            debugPrint('[SseClient] Stream ended with ${event.type}');
            return;
          }
        }
        debugPrint('[SseClient] Stream ended');
        return;
      } catch (e) {
        debugPrint('[SseClient] Error: $e');
        if (retryCount >= maxRetries) {
          debugPrint('[SseClient] Max retries reached, giving up');
          throw Exception('SSE connection failed after $maxRetries retries: $e');
        }
        retryCount++;
        final delay = _calculateBackoffDelay(retryCount);
        debugPrint('[SseClient] Retrying in ${delay.inMilliseconds}ms...');
        await Future.delayed(delay);
      } finally {
        client?.close();
      }
    }
  }
  Stream<SseEvent> _parseEventStream(Stream<List<int>> byteStream) async* {
    final lines = byteStream
        .transform(utf8.decoder)
        .transform(const LineSplitter());
    await for (final line in lines) {
      if (line.startsWith('data:')) {
        final jsonString = line.substring(5).trim();
        if (jsonString.isNotEmpty) {
          try {
            final json = jsonDecode(jsonString) as Map<String, dynamic>;
            yield SseEvent.fromJson(json);
          } catch (e) {
            debugPrint('[SseClient] Failed to parse event: $e');
          }
        }
      }
    }
  }
  Duration _calculateBackoffDelay(int retryCount) {
    return initialRetryDelay * (1 << (retryCount - 1));
  }
}
</file>

<file path="lib/core/talaria_client_provider.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wingtip/core/device_id_provider.dart';
import 'package:wingtip/core/network_client.dart';
import 'package:wingtip/core/talaria_client.dart';
final talariaClientProvider = FutureProvider<TalariaClient>((ref) async {
  final deviceId = await ref.watch(deviceIdProvider.future);
  final networkClient = NetworkClient(baseUrl: 'https://api.talaria.example.com');
  return TalariaClient(
    dio: networkClient.dio,
    deviceId: deviceId,
  );
});
</file>

<file path="lib/core/theme.dart">
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
class AppTheme {
  static const Color oledBlack = Color(0xFF000000);
  static const Color internationalOrange = Color(0xFFFF3B30);
  static const Color borderGray = Color(0xFF1C1C1E);
  static const Color textPrimary = Color(0xFFFFFFFF);
  static const Color textSecondary = Color(0xFF8E8E93);
  static ThemeData get darkTheme {
    return ThemeData(
      brightness: Brightness.dark,
      scaffoldBackgroundColor: oledBlack,
      colorScheme: const ColorScheme.dark(
        brightness: Brightness.dark,
        primary: internationalOrange,
        onPrimary: textPrimary,
        secondary: internationalOrange,
        onSecondary: textPrimary,
        surface: oledBlack,
        onSurface: textPrimary,
        error: internationalOrange,
        onError: textPrimary,
      ),
      textTheme: TextTheme(
        displayLarge: GoogleFonts.inter(
          fontSize: 57,
          fontWeight: FontWeight.w400,
          letterSpacing: -0.25,
          color: textPrimary,
        ),
        displayMedium: GoogleFonts.inter(
          fontSize: 45,
          fontWeight: FontWeight.w400,
          color: textPrimary,
        ),
        displaySmall: GoogleFonts.inter(
          fontSize: 36,
          fontWeight: FontWeight.w400,
          color: textPrimary,
        ),
        headlineLarge: GoogleFonts.inter(
          fontSize: 32,
          fontWeight: FontWeight.w400,
          color: textPrimary,
        ),
        headlineMedium: GoogleFonts.inter(
          fontSize: 28,
          fontWeight: FontWeight.w400,
          color: textPrimary,
        ),
        headlineSmall: GoogleFonts.inter(
          fontSize: 24,
          fontWeight: FontWeight.w400,
          color: textPrimary,
        ),
        titleLarge: GoogleFonts.inter(
          fontSize: 22,
          fontWeight: FontWeight.w500,
          color: textPrimary,
        ),
        titleMedium: GoogleFonts.inter(
          fontSize: 16,
          fontWeight: FontWeight.w500,
          letterSpacing: 0.15,
          color: textPrimary,
        ),
        titleSmall: GoogleFonts.inter(
          fontSize: 14,
          fontWeight: FontWeight.w500,
          letterSpacing: 0.1,
          color: textPrimary,
        ),
        bodyLarge: GoogleFonts.inter(
          fontSize: 16,
          fontWeight: FontWeight.w400,
          letterSpacing: 0.5,
          color: textPrimary,
        ),
        bodyMedium: GoogleFonts.inter(
          fontSize: 14,
          fontWeight: FontWeight.w400,
          letterSpacing: 0.25,
          color: textPrimary,
        ),
        bodySmall: GoogleFonts.inter(
          fontSize: 12,
          fontWeight: FontWeight.w400,
          letterSpacing: 0.4,
          color: textSecondary,
        ),
        labelLarge: GoogleFonts.inter(
          fontSize: 14,
          fontWeight: FontWeight.w500,
          letterSpacing: 0.1,
          color: textPrimary,
        ),
        labelMedium: GoogleFonts.inter(
          fontSize: 12,
          fontWeight: FontWeight.w500,
          letterSpacing: 0.5,
          color: textPrimary,
        ),
        labelSmall: GoogleFonts.inter(
          fontSize: 11,
          fontWeight: FontWeight.w500,
          letterSpacing: 0.5,
          color: textSecondary,
        ),
      ),
      appBarTheme: AppBarTheme(
        backgroundColor: oledBlack,
        foregroundColor: textPrimary,
        elevation: 0,
        shadowColor: Colors.transparent,
        titleTextStyle: GoogleFonts.inter(
          fontSize: 20,
          fontWeight: FontWeight.w600,
          color: textPrimary,
        ),
        shape: const Border(
          bottom: BorderSide(
            color: borderGray,
            width: 1.0,
          ),
        ),
      ),
      cardTheme: const CardThemeData(
        color: oledBlack,
        elevation: 0,
        shadowColor: Colors.transparent,
        shape: RoundedRectangleBorder(
          side: BorderSide(
            color: borderGray,
            width: 1.0,
          ),
          borderRadius: BorderRadius.all(Radius.circular(8)),
        ),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: internationalOrange,
          foregroundColor: textPrimary,
          elevation: 0,
          shadowColor: Colors.transparent,
          shape: RoundedRectangleBorder(
            side: const BorderSide(
              color: internationalOrange,
              width: 1.0,
            ),
            borderRadius: BorderRadius.circular(8),
          ),
          textStyle: GoogleFonts.inter(
            fontSize: 14,
            fontWeight: FontWeight.w600,
            letterSpacing: 0.5,
          ),
        ),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          foregroundColor: textPrimary,
          elevation: 0,
          shadowColor: Colors.transparent,
          side: const BorderSide(
            color: borderGray,
            width: 1.0,
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
          textStyle: GoogleFonts.inter(
            fontSize: 14,
            fontWeight: FontWeight.w600,
            letterSpacing: 0.5,
          ),
        ),
      ),
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: internationalOrange,
          elevation: 0,
          shadowColor: Colors.transparent,
          textStyle: GoogleFonts.inter(
            fontSize: 14,
            fontWeight: FontWeight.w600,
            letterSpacing: 0.5,
          ),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: oledBlack,
        border: const OutlineInputBorder(
          borderSide: BorderSide(
            color: borderGray,
            width: 1.0,
          ),
          borderRadius: BorderRadius.all(Radius.circular(8)),
        ),
        enabledBorder: const OutlineInputBorder(
          borderSide: BorderSide(
            color: borderGray,
            width: 1.0,
          ),
          borderRadius: BorderRadius.all(Radius.circular(8)),
        ),
        focusedBorder: const OutlineInputBorder(
          borderSide: BorderSide(
            color: internationalOrange,
            width: 1.0,
          ),
          borderRadius: BorderRadius.all(Radius.circular(8)),
        ),
        errorBorder: const OutlineInputBorder(
          borderSide: BorderSide(
            color: internationalOrange,
            width: 1.0,
          ),
          borderRadius: BorderRadius.all(Radius.circular(8)),
        ),
        focusedErrorBorder: const OutlineInputBorder(
          borderSide: BorderSide(
            color: internationalOrange,
            width: 1.0,
          ),
          borderRadius: BorderRadius.all(Radius.circular(8)),
        ),
        labelStyle: GoogleFonts.inter(
          color: textSecondary,
          fontSize: 14,
        ),
        hintStyle: GoogleFonts.inter(
          color: textSecondary,
          fontSize: 14,
        ),
      ),
      dividerTheme: const DividerThemeData(
        color: borderGray,
        thickness: 1.0,
        space: 1.0,
      ),
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
        backgroundColor: oledBlack,
        selectedItemColor: internationalOrange,
        unselectedItemColor: textSecondary,
        elevation: 0,
        type: BottomNavigationBarType.fixed,
        selectedLabelStyle: GoogleFonts.inter(
          fontSize: 12,
          fontWeight: FontWeight.w600,
        ),
        unselectedLabelStyle: GoogleFonts.inter(
          fontSize: 12,
          fontWeight: FontWeight.w400,
        ),
      ),
      floatingActionButtonTheme: const FloatingActionButtonThemeData(
        backgroundColor: internationalOrange,
        foregroundColor: textPrimary,
        elevation: 0,
        shape: RoundedRectangleBorder(
          side: BorderSide(
            color: internationalOrange,
            width: 1.0,
          ),
          borderRadius: BorderRadius.all(Radius.circular(16)),
        ),
      ),
      dialogTheme: DialogThemeData(
        backgroundColor: oledBlack,
        elevation: 0,
        shadowColor: Colors.transparent,
        shape: const RoundedRectangleBorder(
          side: BorderSide(
            color: borderGray,
            width: 1.0,
          ),
          borderRadius: BorderRadius.all(Radius.circular(12)),
        ),
        titleTextStyle: GoogleFonts.inter(
          fontSize: 20,
          fontWeight: FontWeight.w600,
          color: textPrimary,
        ),
        contentTextStyle: GoogleFonts.inter(
          fontSize: 14,
          fontWeight: FontWeight.w400,
          color: textPrimary,
        ),
      ),
      useMaterial3: true,
    );
  }
  static TextStyle monoStyle({
    double? fontSize,
    FontWeight? fontWeight,
    Color? color,
  }) {
    return GoogleFonts.jetBrainsMono(
      fontSize: fontSize ?? 14,
      fontWeight: fontWeight ?? FontWeight.w400,
      color: color ?? textPrimary,
      letterSpacing: 0,
    );
  }
}
</file>

<file path="lib/data/database_provider.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'database.dart';
final databaseProvider = Provider<AppDatabase>((ref) {
  return AppDatabase();
});
</file>

<file path="lib/features/camera/camera_provider.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wingtip/features/camera/camera_service.dart';
final cameraServiceProvider = Provider<CameraService>((ref) {
  return CameraService();
});
</file>

<file path="lib/features/camera/camera_service.dart">
import 'package:camera/camera.dart';
import 'package:flutter/foundation.dart';
class CameraService {
  static final CameraService _instance = CameraService._internal();
  factory CameraService() => _instance;
  CameraService._internal();
  CameraController? _controller;
  bool _isInitialized = false;
  String? _errorMessage;
  DateTime? _initStartTime;
  DateTime? _initEndTime;
  bool get isInitialized => _isInitialized;
  CameraController? get controller => _controller;
  String? get errorMessage => _errorMessage;
  Duration? get initializationDuration {
    if (_initStartTime != null && _initEndTime != null) {
      return _initEndTime!.difference(_initStartTime!);
    }
    return null;
  }
  Future<void> initialize() async {
    if (_isInitialized) return;
    _initStartTime = DateTime.now();
    debugPrint('[CameraService] Starting camera initialization at ${_initStartTime!.toIso8601String()}');
    try {
      final cameras = await availableCameras();
      if (cameras.isEmpty) {
        _errorMessage = 'No cameras available';
        debugPrint('[CameraService] Error: No cameras available');
        return;
      }
      final camera = cameras.first;
      debugPrint('[CameraService] Found ${cameras.length} camera(s), using ${camera.name}');
      _controller = CameraController(
        camera,
        ResolutionPreset.high,
        enableAudio: false,
        imageFormatGroup: ImageFormatGroup.jpeg,
      );
      await _controller!.initialize();
      _isInitialized = true;
      _initEndTime = DateTime.now();
      final duration = initializationDuration;
      debugPrint('[CameraService] Camera initialized successfully in ${duration?.inMilliseconds}ms');
    } catch (e) {
      _errorMessage = 'Failed to initialize camera: $e';
      _initEndTime = DateTime.now();
      debugPrint('[CameraService] Camera initialization failed: $e');
    }
  }
  void dispose() {
    _controller?.dispose();
    _controller = null;
    _isInitialized = false;
  }
}
</file>

<file path="lib/features/camera/image_processor.dart">
import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:image/image.dart' as img;
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';
class ImageProcessingParams {
  final String sourcePath;
  final String outputDir;
  final int maxDimension;
  final int quality;
  ImageProcessingParams({
    required this.sourcePath,
    required this.outputDir,
    required this.maxDimension,
    required this.quality,
  });
}
class ImageProcessingResult {
  final String outputPath;
  final int processingTimeMs;
  final int originalSize;
  final int processedSize;
  ImageProcessingResult({
    required this.outputPath,
    required this.processingTimeMs,
    required this.originalSize,
    required this.processedSize,
  });
}
class ImageProcessor {
  static Future<ImageProcessingResult> processImage(String sourcePath) async {
    final startTime = DateTime.now();
    final sourceFile = File(sourcePath);
    final originalSize = await sourceFile.length();
    debugPrint('[ImageProcessor] Starting image processing for: $sourcePath');
    debugPrint('[ImageProcessor] Original file size: ${(originalSize / 1024).toStringAsFixed(2)} KB');
    final tempDir = await getTemporaryDirectory();
    final params = ImageProcessingParams(
      sourcePath: sourcePath,
      outputDir: tempDir.path,
      maxDimension: 1920,
      quality: 85,
    );
    final outputPath = await compute(_processImageInIsolate, params);
    final processedFile = File(outputPath);
    final processedSize = await processedFile.length();
    final endTime = DateTime.now();
    final processingTimeMs = endTime.difference(startTime).inMilliseconds;
    debugPrint('[ImageProcessor] Processing complete in ${processingTimeMs}ms');
    debugPrint('[ImageProcessor] Processed file size: ${(processedSize / 1024).toStringAsFixed(2)} KB');
    debugPrint('[ImageProcessor] Compression ratio: ${((1 - processedSize / originalSize) * 100).toStringAsFixed(1)}%');
    if (processingTimeMs >= 500) {
      debugPrint('[ImageProcessor] WARNING: Processing time exceeded 500ms threshold');
    }
    return ImageProcessingResult(
      outputPath: outputPath,
      processingTimeMs: processingTimeMs,
      originalSize: originalSize,
      processedSize: processedSize,
    );
  }
  static Future<String> _processImageInIsolate(ImageProcessingParams params) async {
    final imageBytes = await File(params.sourcePath).readAsBytes();
    final image = img.decodeImage(imageBytes);
    if (image == null) {
      throw Exception('Failed to decode image');
    }
    img.Image processedImage = image;
    final maxDim = image.width > image.height ? image.width : image.height;
    if (maxDim > params.maxDimension) {
      if (image.width > image.height) {
        processedImage = img.copyResize(
          image,
          width: params.maxDimension,
          interpolation: img.Interpolation.linear,
        );
      } else {
        processedImage = img.copyResize(
          image,
          height: params.maxDimension,
          interpolation: img.Interpolation.linear,
        );
      }
    }
    final encodedBytes = img.encodeJpg(processedImage, quality: params.quality);
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final outputPath = p.join(params.outputDir, 'processed_$timestamp.jpg');
    final outputFile = File(outputPath);
    await outputFile.writeAsBytes(encodedBytes);
    return outputPath;
  }
}
</file>

<file path="lib/features/camera/permission_primer_screen.dart">
import 'package:flutter/material.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:wingtip/core/theme.dart';
import 'package:wingtip/features/camera/camera_screen.dart';
class PermissionPrimerScreen extends StatelessWidget {
  const PermissionPrimerScreen({super.key});
  Future<void> _handleGrantAccess(BuildContext context) async {
    final status = await Permission.camera.request();
    if (!context.mounted) return;
    if (status.isGranted) {
      Navigator.of(context).pushReplacement(
        MaterialPageRoute(
          builder: (context) => const CameraScreen(),
        ),
      );
    } else if (status.isDenied) {
      _showPermissionDeniedDialog(context, isDenied: true);
    } else if (status.isPermanentlyDenied) {
      _showPermissionDeniedDialog(context, isPermanentlyDenied: true);
    }
  }
  void _showPermissionDeniedDialog(
    BuildContext context, {
    bool isDenied = false,
    bool isPermanentlyDenied = false,
  }) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text('Camera Access Required'),
          content: Text(
            isPermanentlyDenied
                ? 'Camera access has been permanently denied. Please enable it in your device settings to use Wingtip.'
                : 'Wingtip needs camera access to scan book spines. Without it, you won\'t be able to add books to your library.',
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: const Text('Cancel'),
            ),
            if (isPermanentlyDenied)
              TextButton(
                onPressed: () async {
                  Navigator.of(context).pop();
                  await openAppSettings();
                },
                child: const Text('Open Settings'),
              )
            else
              TextButton(
                onPressed: () {
                  Navigator.of(context).pop();
                  _handleGrantAccess(context);
                },
                child: const Text('Try Again'),
              ),
          ],
        );
      },
    );
  }
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppTheme.oledBlack,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(32.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              const Spacer(),
              Icon(
                Icons.camera_alt_outlined,
                size: 120,
                color: AppTheme.internationalOrange,
              ),
              const SizedBox(height: 48),
              Text(
                'Camera Access',
                style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 24),
              Text(
                'Wingtip needs your camera to see books. Images are processed and deleted instantly.',
                style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                  color: AppTheme.textSecondary,
                  height: 1.5,
                ),
                textAlign: TextAlign.center,
              ),
              const Spacer(),
              SizedBox(
                height: 56,
                child: ElevatedButton(
                  onPressed: () => _handleGrantAccess(context),
                  child: const Text('Grant Access'),
                ),
              ),
              const SizedBox(height: 16),
            ],
          ),
        ),
      ),
    );
  }
}
</file>

<file path="lib/features/library/widgets/empty_library_state.dart">
import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:google_fonts/google_fonts.dart';
import '../../../core/theme.dart';
class EmptyLibraryState extends StatelessWidget {
  const EmptyLibraryState({super.key});
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Container(
            width: 120,
            height: 120,
            decoration: BoxDecoration(
              border: Border.all(
                color: AppTheme.borderGray,
                width: 1,
              ),
              borderRadius: BorderRadius.circular(4),
            ),
            padding: const EdgeInsets.all(16),
            child: SvgPicture.asset(
              'assets/images/empty_bookshelf.svg',
              colorFilter: const ColorFilter.mode(
                AppTheme.textSecondary,
                BlendMode.srcIn,
              ),
            ),
          ),
          const SizedBox(height: 24),
          Text(
            '0 Books. Tap [O] to scan.',
            style: GoogleFonts.inter(
              fontSize: 16,
              fontWeight: FontWeight.w400,
              color: AppTheme.textSecondary,
              letterSpacing: 0.5,
            ),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="lib/features/talaria/job_state_provider.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wingtip/features/talaria/job_state.dart';
import 'package:wingtip/features/talaria/job_state_notifier.dart';
final jobStateProvider = NotifierProvider<JobStateNotifier, JobState>(
  JobStateNotifier.new,
);
</file>

<file path="lib/services/csv_export_service_provider.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wingtip/data/database_provider.dart';
import 'package:wingtip/services/csv_export_service.dart';
final csvExportServiceProvider = Provider<CsvExportService>((ref) {
  final database = ref.watch(databaseProvider);
  return CsvExportService(database);
});
</file>

<file path="lib/services/csv_export_service.dart">
import 'dart:io';
import 'package:csv/csv.dart';
import 'package:intl/intl.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
import 'package:share_plus/share_plus.dart';
import 'package:wingtip/data/database.dart';
class CsvExportService {
  final AppDatabase _database;
  CsvExportService(this._database);
  Future<String?> exportLibraryToCsv() async {
    final books = await _database.getAllBooks();
    if (books.isEmpty) {
      return null;
    }
    final List<List<dynamic>> csvData = [
      ['ISBN', 'Title', 'Author', 'Format', 'Added Date', 'Cover URL'],
    ];
    for (final book in books) {
      csvData.add([
        book.isbn,
        book.title,
        book.author,
        book.format ?? '',
        _formatDate(book.addedDate),
        book.coverUrl ?? '',
      ]);
    }
    // Convert to CSV string
    final csvString = const ListToCsvConverter().convert(csvData);
    // Generate filename with current date
    final dateStr = DateFormat('yyyy-MM-dd').format(DateTime.now());
    final filename = 'wingtip_library_$dateStr.csv';
    final tempDir = await getTemporaryDirectory();
    final file = File(p.join(tempDir.path, filename));
    await file.writeAsString(csvString);
    return file.path;
  }
  Future<void> shareExportedCsv(String filePath) async {
    final xFile = XFile(filePath);
    await Share.shareXFiles(
      [xFile],
      subject: 'Wingtip Library Export',
    );
  }
  String _formatDate(int timestamp) {
    final date = DateTime.fromMillisecondsSinceEpoch(timestamp);
    return DateFormat('yyyy-MM-dd').format(date);
  }
}
</file>

<file path="lib/widgets/error_snack_bar.dart">
import 'package:flutter/material.dart';
import 'package:wingtip/core/theme.dart';
class ErrorSnackBar extends SnackBar {
  ErrorSnackBar({
    super.key,
    required String message,
  }) : super(
          content: _ErrorSnackBarContent(message: message),
          backgroundColor: AppTheme.oledBlack,
          behavior: SnackBarBehavior.floating,
          duration: const Duration(seconds: 4),
          elevation: 0,
          shape: const RoundedRectangleBorder(
            borderRadius: BorderRadius.all(Radius.circular(8)),
          ),
          margin: const EdgeInsets.all(16),
          padding: EdgeInsets.zero,
        );
  static void show(
    BuildContext context, {
    required String message,
  }) {
    ScaffoldMessenger.of(context).showSnackBar(
      ErrorSnackBar(message: message),
    );
  }
}
class _ErrorSnackBarContent extends StatelessWidget {
  final String message;
  const _ErrorSnackBarContent({required this.message});
  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: const BoxDecoration(
        color: AppTheme.oledBlack,
        border: Border(
          left: BorderSide(
            color: AppTheme.internationalOrange,
            width: 4.0,
          ),
        ),
        borderRadius: BorderRadius.all(Radius.circular(8)),
      ),
      padding: const EdgeInsets.symmetric(
        horizontal: 16.0,
        vertical: 14.0,
      ),
      child: Text(
        message,
        style: Theme.of(context).textTheme.bodyMedium?.copyWith(
              color: AppTheme.textPrimary,
            ),
      ),
    );
  }
}
</file>

<file path="lib/widgets/network_status_indicator.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:wingtip/core/network_status_provider.dart';
import 'package:wingtip/core/theme.dart';
class NetworkStatusIndicator extends ConsumerWidget {
  const NetworkStatusIndicator({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final networkStatus = ref.watch(networkStatusProvider);
    return networkStatus.when(
      data: (isOnline) {
        if (isOnline) {
          return const SizedBox.shrink();
        }
        return Container(
          padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
          decoration: BoxDecoration(
            color: AppTheme.oledBlack,
            border: Border.all(
              color: AppTheme.textPrimary,
              width: 1.0,
            ),
            borderRadius: BorderRadius.circular(2),
          ),
          child: Text(
            'OFFLINE',
            style: GoogleFonts.inter(
              fontSize: 10,
              fontWeight: FontWeight.w600,
              color: AppTheme.textPrimary,
              letterSpacing: 0.5,
            ),
          ),
        );
      },
      loading: () => const SizedBox.shrink(),
      error: (error, stackTrace) => const SizedBox.shrink(),
    );
  }
}
</file>

<file path="tasks/epic-4.json">
{
  "name": "Epic 4: Failed Scan Queue & Production Resilience",
  "description": "Implement comprehensive error handling and retry system to transform Wingtip from demo-ready to production-ready. The FailedScans table infrastructure exists but is completely unused - this epic brings it to life.",
  "branchName": "ralph/epic-4-resilience",
  "userStories": [
    {
      "id": "US-131",
      "title": "Save Failed Scans to Database",
      "description": "As a system, I want to save failed scans to the database so that users can retry them later without losing data.",
      "acceptanceCriteria": [
        "When SSE error event arrives, save to FailedScans table with jobId, imagePath, errorMessage",
        "Calculate expiresAt timestamp based on retention policy (default 7 days from createdAt)",
        "Store createdAt as current Unix timestamp in milliseconds",
        "Modify JobStateNotifier to call FailedScansRepository on error events",
        "flutter analyze shows no errors",
        "flutter test runs successfully with failed scan persistence tests"
      ],
      "priority": 1,
      "passes": true,
      "notes": "",
      "dependsOn": [],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-132",
      "title": "Failed Scans Repository Layer",
      "description": "As a developer, I want a repository abstraction for failed scans so that I can manage retry logic cleanly.",
      "acceptanceCriteria": [
        "Create lib/data/failed_scans_repository.dart with FailedScansRepository class",
        "Implement saveFailedScan(jobId, imagePath, errorMessage) method",
        "Implement getAllFailedScans() returning Stream<List<FailedScan>>",
        "Implement deleteFailedScan(id) and retryFailedScan(id) methods",
        "Create Riverpod providers: failedScansRepositoryProvider and watchFailedScansProvider",
        "flutter analyze shows no errors",
        "flutter test runs successfully with repository unit tests"
      ],
      "priority": 2,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-131"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-133",
      "title": "Preserve Images for Failed Scans",
      "description": "As a user, I want my failed scan images preserved so that I can retry them without re-capturing.",
      "acceptanceCriteria": [
        "When scan fails, move image from temp directory to persistent app_documents/failed_scans/",
        "Filename format: {jobId}.jpg for easy lookup",
        "Update JobStateNotifier cleanup logic to skip deletion for failed scans",
        "On successful retry: delete image from failed_scans directory",
        "On manual delete: remove both database entry and image file",
        "flutter analyze shows no errors",
        "Manual verification: Failed scan images persist across app restarts"
      ],
      "priority": 3,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-132"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-134",
      "title": "Handle Network Upload Failures",
      "description": "As a user, I want network upload failures saved to retry queue so that temporary connection issues don't lose my scans.",
      "acceptanceCriteria": [
        "Catch DioException, SocketException, TimeoutException in upload flow",
        "Map exception types to user-friendly error messages",
        "Save to FailedScans with appropriate error: 'No internet connection', 'Upload timed out after 30s', 'Server unreachable'",
        "Keep original image in failed_scans directory",
        "Show error toast notification to user",
        "flutter analyze shows no errors",
        "flutter test runs successfully with network failure handling tests"
      ],
      "priority": 4,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-133"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-135",
      "title": "Handle Backend No Books Found Response",
      "description": "As a user, I want to retry images where no books were detected so that I can adjust my scan technique.",
      "acceptanceCriteria": [
        "Detect 404 status or empty result array from backend response",
        "Save to FailedScans with message: 'No books detected in this image'",
        "Preserve original image in failed_scans directory",
        "Allow user to retry same image from failed queue",
        "Show informative toast: 'No books found. Try closer zoom or clearer angle.'",
        "flutter analyze shows no errors",
        "flutter test runs successfully with no-books-found handling tests"
      ],
      "priority": 5,
      "passes": false,
      "notes": "",
      "dependsOn": [
        "US-134"
      ],
      "completionNotes": ""
    },
    {
      "id": "US-136",
      "title": "Failed Scans Tab in Library",
      "description": "As a user, I want to see all my failed scans in one place so that I can review and retry them.",
      "acceptanceCriteria": [
        "Add TabBar to LibraryScreen with tabs: 'All Books' and 'Failed Scans'",
        "Show count badge on Failed tab when failed scans exist (e.g., 'Failed (5)')",
        "Failed tab displays grid view of failed scan thumbnails (same 3-column layout as books)",
        "Empty state: 'No failed scans' with checkmark icon when queue is empty",
        "flutter analyze shows no errors",
        "Manual verification: Tab switches between book library and failed scans"
      ],
      "priority": 6,
      "passes": false,
      "notes": "",
      "dependsOn": [
        "US-135"
      ],
      "completionNotes": ""
    },
    {
      "id": "US-137",
      "title": "Failed Scan Card UI",
      "description": "As a user, I want to see why each scan failed so that I understand what went wrong.",
      "acceptanceCriteria": [
        "Create FailedScanCard widget displaying image thumbnail from failed_scans directory",
        "Apply red 1px border (#FF3B30) to indicate error state",
        "Show error message below thumbnail (truncated to 2 lines with ellipsis)",
        "Display relative timestamp: '2 hours ago', '1 day ago'",
        "Add action buttons: Orange 'Retry' button and Gray 'Delete' button",
        "flutter analyze shows no errors",
        "Manual verification: Failed scan cards display correctly with proper styling"
      ],
      "priority": 7,
      "passes": false,
      "notes": "",
      "dependsOn": [
        "US-136"
      ],
      "completionNotes": ""
    },
    {
      "id": "US-140",
      "title": "Manual Retry Single Scan",
      "description": "As a user, I want to tap Retry on a failed scan so that I can recover from temporary errors.",
      "acceptanceCriteria": [
        "Tap 'Retry' button reads image from failed_scans/{jobId}.jpg",
        "Call existing uploadScan() method with preserved image",
        "Show job in processing queue UI (same as new scans)",
        "On successful upload and completion: delete from FailedScans table and remove image file",
        "On retry failure: update errorMessage with new attempt information",
        "flutter analyze shows no errors",
        "Manual verification: Retry flow matches new scan behavior"
      ],
      "priority": 8,
      "passes": false,
      "notes": "",
      "dependsOn": [
        "US-137"
      ],
      "completionNotes": ""
    },
    {
      "id": "US-142",
      "title": "Auto-Cleanup Expired Failed Scans",
      "description": "As a user, I want old failed scans deleted automatically so that my storage doesn't fill up.",
      "acceptanceCriteria": [
        "Run cleanup job on app startup checking FailedScans.expiresAt < now()",
        "Delete expired database entries and associated image files",
        "Schedule daily cleanup check using background task or app lifecycle hook",
        "Log cleanup results to debug console: 'Cleaned up 3 expired failed scans'",
        "Respect retention policy configured in settings (default 7 days)",
        "flutter analyze shows no errors",
        "flutter test runs successfully with auto-cleanup logic tests"
      ],
      "priority": 9,
      "passes": false,
      "notes": "",
      "dependsOn": [
        "US-140"
      ],
      "completionNotes": ""
    },
    {
      "id": "US-143",
      "title": "Failed Scan Retention Settings",
      "description": "As a user, I want to configure how long failed scans are kept so that I control my storage usage.",
      "acceptanceCriteria": [
        "Add 'Failed Scan Retention' section to Debug Settings page",
        "Options: DropdownButton with values 3 days, 7 days (default), 14 days, 30 days, Never",
        "Display current failed scan count and storage usage: 'Failed Scans: 12 (using 8.4 MB)'",
        "Add 'Clear All Failed Scans Now' button with confirmation dialog",
        "Save retention preference to SharedPreferences",
        "flutter analyze shows no errors",
        "Manual verification: Retention setting persists and affects expiresAt calculation"
      ],
      "priority": 10,
      "passes": false,
      "notes": "",
      "dependsOn": [
        "US-142"
      ],
      "completionNotes": ""
    },
    {
      "id": "US-144",
      "title": "Device ID Management",
      "description": "As a user, I want to see and regenerate my device ID so that I can reset my privacy if needed.",
      "acceptanceCriteria": [
        "Display current X-Device-ID UUID in Debug Settings using JetBrains Mono font",
        "Add 'Copy to Clipboard' button next to device ID",
        "Add 'Regenerate Device ID' button with warning dialog",
        "Warning text: 'This will reset your device identity. Rate limits and analytics will restart. Continue?'",
        "On confirm: generate new UUID, save to FlutterSecureStorage, restart app",
        "flutter analyze shows no errors",
        "Manual verification: Device ID regeneration works and persists"
      ],
      "priority": 11,
      "passes": false,
      "notes": "",
      "dependsOn": [
        "US-143"
      ],
      "completionNotes": ""
    },
    {
      "id": "US-146",
      "title": "Specific Error Messages for Common Failures",
      "description": "As a user, I want to see helpful error messages so that I understand how to fix the problem.",
      "acceptanceCriteria": [
        "Create error message mapping for common HTTP status codes and exceptions",
        "400 Bad Request -> 'Image quality too low. Try again with better lighting.'",
        "404 Not Found -> 'No books detected. Try closer zoom or clearer angle.'",
        "429 Rate Limited -> 'Daily scan limit reached. Retry after [countdown].'",
        "500 Server Error -> 'Server issue. Your image is saved and will retry automatically.'",
        "Timeout -> 'Upload timed out. Check your connection and retry.'",
        "flutter analyze shows no errors",
        "Manual verification: Error messages are user-friendly and actionable"
      ],
      "priority": 12,
      "passes": false,
      "notes": "",
      "dependsOn": [
        "US-144"
      ],
      "completionNotes": ""
    },
    {
      "id": "US-138",
      "title": "Batch Operations for Failed Scans",
      "description": "As a user, I want to retry or delete multiple failed scans at once so that I can clean up efficiently.",
      "acceptanceCriteria": [
        "Add 'Retry All' button at top of Failed Scans tab (orange, AppTheme.accentColor)",
        "Add 'Clear All Failed' button with confirmation dialog: 'Delete all X failed scans?'",
        "Long-press on failed scan card enters select mode with checkboxes",
        "Select mode shows trash icon in app bar for batch delete",
        "Batch delete shows confirmation: 'Delete 5 failed scans?'",
        "flutter analyze shows no errors",
        "Manual verification: Batch operations work smoothly"
      ],
      "priority": 13,
      "passes": false,
      "notes": "",
      "dependsOn": [
        "US-146"
      ],
      "completionNotes": ""
    },
    {
      "id": "US-141",
      "title": "Batch Retry Failed Scans",
      "description": "As a user, I want to retry all failed scans at once so that I can recover from network outages efficiently.",
      "acceptanceCriteria": [
        "Tap 'Retry All' button processes all failed scans sequentially",
        "Throttle uploads to 1 scan per second to avoid rate limiting",
        "Show progress toast: 'Retrying 3 of 12...' that updates as retries complete",
        "After completion, show summary toast: '8 succeeded, 4 failed'",
        "Only remove successful retries from failed queue - keep failures for manual review",
        "flutter analyze shows no errors",
        "Manual verification: Batch retry handles mix of successes and failures correctly"
      ],
      "priority": 14,
      "passes": false,
      "notes": "",
      "dependsOn": [
        "US-138"
      ],
      "completionNotes": ""
    },
    {
      "id": "US-139",
      "title": "Failed Scan Detail View",
      "description": "As a user, I want to see full details about a failed scan so that I can understand what went wrong.",
      "acceptanceCriteria": [
        "Tap on failed scan card opens full-screen detail view",
        "Display full-size original image from failed_scans directory",
        "Show complete error message (not truncated)",
        "Show full timestamp: 'Failed on Jan 18, 2026 at 3:45 PM'",
        "Large 'Retry Scan' button (orange) at bottom",
        "Large 'Delete' button (gray) next to retry",
        "Add expandable 'Why did this fail?' section with contextual help based on error type",
        "flutter analyze shows no errors",
        "Manual verification: Detail view provides helpful debugging information"
      ],
      "priority": 15,
      "passes": false,
      "notes": "",
      "dependsOn": [
        "US-141"
      ],
      "completionNotes": ""
    },
    {
      "id": "US-145",
      "title": "Network Retry on Connection Restored",
      "description": "As a user, I want to be prompted to retry failed scans when my connection returns so that I don't forget about them.",
      "acceptanceCriteria": [
        "Listen to NetworkStatusProvider for offline -> online transitions",
        "When connection restored and failed scans exist, show toast: 'Connection restored. 5 failed scans waiting. Retry all?'",
        "Toast shows two buttons: 'Retry All' and 'Dismiss'",
        "Add setting toggle: 'Auto-retry on reconnect' (default: off)",
        "If auto-retry enabled, automatically trigger retry all when online",
        "flutter analyze shows no errors",
        "Manual verification: Reconnection prompt appears correctly"
      ],
      "priority": 16,
      "passes": false,
      "notes": "",
      "dependsOn": [
        "US-139"
      ],
      "completionNotes": ""
    },
    {
      "id": "US-148",
      "title": "Graceful SSE Stream Interruption Handling",
      "description": "As a user, I want partial results saved when my connection drops mid-scan so that I don't lose everything.",
      "acceptanceCriteria": [
        "Detect SSE connection drops mid-stream (connection closed before 'complete' event)",
        "Save any books already received via 'result' events to database (partial success)",
        "Mark job as failed in FailedScans with error: 'Connection lost during processing'",
        "UI shows partial results in library AND failed scan entry for retry",
        "Retry uploads full image again for complete processing",
        "flutter analyze shows no errors",
        "Manual verification: Partial results + retry option work correctly"
      ],
      "priority": 17,
      "passes": false,
      "notes": "",
      "dependsOn": [
        "US-145"
      ],
      "completionNotes": ""
    },
    {
      "id": "US-150",
      "title": "Background Isolate Image Processing Verification",
      "description": "As a developer, I want to verify image processing never blocks the UI so that the shutter remains responsive.",
      "acceptanceCriteria": [
        "Audit existing image compression code to confirm compute() isolate usage",
        "Add performance timing logs around image processing: 'Image processed in 342ms'",
        "Target: < 500ms average processing time",
        "Verify shutter button remains clickable during processing (no frame drops)",
        "Add metrics to debug settings showing average processing time",
        "flutter analyze shows no errors",
        "Manual verification: Rapid shutter taps never block or jank"
      ],
      "priority": 18,
      "passes": false,
      "notes": "",
      "dependsOn": [
        "US-148"
      ],
      "completionNotes": ""
    },
    {
      "id": "US-151",
      "title": "Session Counter Gamification",
      "description": "As a user, I want to see how many books I've scanned in a session so that I feel accomplished.",
      "acceptanceCriteria": [
        "Add session counter in top-right corner of camera screen",
        "Display format: '5 books scanned...', '10 books scanned...', '25 books scanned!'",
        "Trigger celebratory pulse animation at milestones: 10, 25, 50, 100 books",
        "Increment counter on each successful scan completion",
        "Reset counter when app goes to background or after 5 minutes idle",
        "Use Swiss Utility styling: white text on black, 1px border",
        "flutter analyze shows no errors",
        "Manual verification: Counter updates correctly and resets appropriately"
      ],
      "priority": 19,
      "passes": false,
      "notes": "",
      "dependsOn": [
        "US-150"
      ],
      "completionNotes": ""
    },
    {
      "id": "US-149",
      "title": "Failed Scan Analytics & Insights",
      "description": "As a user, I want to understand why my scans fail so that I can improve my technique.",
      "acceptanceCriteria": [
        "Track failure reason metadata in FailedScans: network_error, quality_too_low, no_books_found, server_error, rate_limited",
        "Add analytics section to Debug Settings page",
        "Display failure breakdown: 'Failure analysis: 60% network, 25% no books, 10% quality, 5% server'",
        "Show pie chart or bar graph visualization (optional, can be text-based)",
        "Include total failed scans count and success rate percentage",
        "flutter analyze shows no errors",
        "Manual verification: Analytics help users understand failure patterns"
      ],
      "priority": 20,
      "passes": false,
      "notes": "",
      "dependsOn": [
        "US-151"
      ],
      "completionNotes": ""
    },
    {
      "id": "US-152",
      "title": "Performance Monitoring Dashboard",
      "description": "As a developer, I want to track performance metrics so that I can verify PRD targets are met.",
      "acceptanceCriteria": [
        "Add 'Performance Metrics' section to Debug Settings page",
        "Display metrics: Cold start time (target < 1000ms), Shutter latency (target < 50ms), Avg upload time, Avg SSE first-result time",
        "Show frame drops during scanning sessions",
        "Format as table with 'Target' vs 'Actual' columns",
        "Color code: Green when meeting target, Red when missing target",
        "Persist metrics using SharedPreferences for historical tracking",
        "flutter analyze shows no errors",
        "Manual verification: Metrics accurately reflect app performance"
      ],
      "priority": 21,
      "passes": false,
      "notes": "",
      "dependsOn": [
        "US-149"
      ],
      "completionNotes": ""
    }
  ],
  "metadata": {
    "createdAt": "2026-01-18T00:00:00.000Z",
    "updatedAt": "2026-01-19T04:37:32.357Z",
    "epicNumber": 4,
    "totalStories": 20,
    "completedStories": 0,
    "estimatedComplexity": "high",
    "blockers": [],
    "notes": "Epic 4 implements the complete failed scan handling system. The FailedScans table already exists in the database schema (created in US-116) but is completely unused. This epic brings the dormant infrastructure to life and transforms Wingtip from demo-ready to production-ready by implementing comprehensive error handling, retry logic, and user-friendly failure recovery."
  }
}
</file>

<file path="tasks/prd-product-requirements-document-project-wingtip-frontend.md">
# Product Requirements Document: Project Wingtip (Frontend)

**Version:** 1.0  
**Status:** Draft  
**Target Platform:** Flutter (iOS/Android)  
**Backend:** [Project Talaria]  
**Author:** Product Team  
**Last Updated:** 2026-01-18

---

## 1. Executive Summary

**Wingtip** is the "dumb" but beautiful lens for the Talaria brain. It is a local-first, offline-capable library manager that uses the camera solely as a data pipe.

### Core Philosophy

**"The Shutter That Remembers"** — While the backend (Talaria) forgets everything instantly, Wingtip remembers everything forever. It is the permanent residence for the data streaming back from the edge.

### Design Principles (The "Slim & Fast" Mandate)

1. **Zero-Blocking UI:** The shutter button must *always* be clickable. Uploads happen in background isolates.
2. **Haptic Fidelity:** Every stage of the SSE stream (Sent → Analyzed → Enriched) provides distinct haptic feedback.
3. **Optimistic fluidity:** The UI should predict success. Book covers animate into place before the full metadata arrives.
4. **Local Sovereignty:** All data lives in SQLite (Drift). The app works 100% offline for viewing/searching, only needing network to *scan*.

---

## 2. Success Metrics (Frontend)

| Metric | Target | Measurement |
| --- | --- | --- |
| **Cold Start Time** | < 1.0s | Time to interactive camera viewfinder |
| **Shutter Latency** | < 50ms | Tap to capture animation start |
| **Jank (Frame Drop)** | 0% | No dropped frames during SSE stream rendering |
| **Battery Impact** | Low | Camera session paused immediately on backgrounding |
| **Offline Reliability** | 100% | Library fully searchable in Airplane Mode |

---

## 3. Tech Stack & Architecture

### 3.1 Core Stack

* **Framework:** Flutter (Latest Stable)
* **Language:** Dart 3.0+
* **State Management:** `flutter_riverpod` (v2, Generator syntax) for reactive UI updates.
* **Local Database:** `drift` (SQLite abstraction) for high-performance structured storage.
* **Camera:** `camerawesome` (Better UI customization than standard `camera` package) or `camera` with custom texture implementation.
* **Networking:** `dio` (Multipart uploads) + `fetch_client` (for SSE streaming handling).

### 3.2 Data Flow (The "Capture Loop")

1. **Capture:** User taps shutter.
   * *UI:* Flash animation, haptic "click", thumbnail flies into a "processing queue" stack.
   * *Logic:* Image saved to temp cache. `ScanRepository` spawns an Isolate to compress/resize.

2. **Upload:**
   * *Logic:* `TalariaClient` uploads to `POST /v3/jobs/scans`.
   * *Header:* Injects `X-Device-ID` (UUID generated on first launch).

3. **Listen (The Stream):**
   * *Logic:* App connects to `GET /v3/jobs/scans/{jobId}/stream`.
   * *State:* Riverpod provider `scanStreamProvider(jobId)` listens to SSE events.

4. **Ingest:**
   * *Event `result`:* Data is upserted immediately into local SQLite `books` table (deduplication by ISBN).
   * *Event `complete`:* Temporary image cache is cleared.

5. **Display:**
   * The "Library" view listens to the SQLite stream, so books "pop" into the list automatically as they are saved.

---

## 4. Database Schema

### 4.1 Core Tables (Drift)

#### Books Table (Minimal Essential Fields)

```dart
class Books extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get isbn => text().unique()();
  TextColumn get title => text()();
  TextColumn get author => text()();
  TextColumn get coverUrl => text().nullable()();
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
  DateTimeColumn get updatedAt => dateTime().withDefault(currentDateAndTime)();
}
```

#### Failed Scans Table (For Retry Queue)

```dart
class FailedScans extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get jobId => text().unique()();
  TextColumn get imagePath => text()(); // Local cached image
  TextColumn get errorMessage => text()();
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
  DateTimeColumn get expiresAt => dateTime()(); // Auto-delete after 7 days
}
```

### 4.2 Deduplication Strategy

* **Silent deduplication by ISBN:** When SSE `result` event arrives, perform `upsert` on ISBN.
* If book already exists, update `updatedAt` timestamp but preserve original `createdAt`.
* No user notification for duplicates (seamless experience).

---

## 5. Feature Specifications

### 5.1 The Viewfinder (Home Screen)

The app opens directly to the camera (Snapchat style) to reduce friction.

* **UI Elements:**
  * **Shutter Button:** Large, bottom center. Animated ring indicates "Processing" load.
  * **Library Peek:** Bottom right thumbnail showing the last scanned book cover. Tapping opens Library.
  * **Settings/Flash:** Minimal top bar.
  * **"Stream" Overlay:** A subtle, transparent log overlay (Matrix style but clean) that fades in/out showing real-time status: *"Analyzing... Found 12 spines... Enriched 'The Martian'..."*.

* **Gestures:**
  * **Swipe Up:** Open Library.
  * **Pinch:** Zoom (Essential for small spines).

### 5.2 The Processing Queue (The "Feed")

Because the user can snap 5 photos in 3 seconds, the UI cannot block.

* **Implementation:** A horizontal "stories" style bar or a floating stack that shows active jobs.
* **States per Job:**
  1. **Uploading:** Indeterminate progress bar.
  2. **Analyzing (Gemini):** Pulsing "AI" icon.
  3. **Enriching:** Rapid cover art flickering as URLs resolve.
  4. **Done:** Disappears and increments the "New Books" badge on the Library icon.
  5. **Failed:** Red border, shows error toast, moves to "Failed" queue with retry option.

### 5.3 Failed Scan Queue

* **Storage:** When backend returns no books or errors occur, save to `FailedScans` table.
* **UI:** Show in "Failed" section of Library with error message and image preview.
* **Actions:**
  * **Retry:** Re-upload same image to backend.
  * **Delete:** Remove from queue.
* **Auto-cleanup:** Delete entries older than 7 days (configurable via settings).

### 5.4 The Library (Local SQLite)

* **View:** Infinite scroll grid of book covers.
* **Search:** Instant local full-text search (FTS5 via Drift) against Title, Author, ISBN.
* **Manual Override:** If Talaria returns `flag: review_needed`, the book card has a yellow "Review" border. Tapping allows manual metadata editing.
* **Export:** "Export CSV" button to dump the SQLite DB to the device file system (User data ownership).
* **Failed Section:** Separate tab/filter showing failed scans with retry options.

### 5.5 Settings & Privacy

* **Device ID:** Display the `X-Device-ID` UUID with a "Regenerate" button (Privacy nuking).
* **Cache Management:** Button to "Clear Cached Images" (covers downloaded from ISBNdb/Google).
* **Failed Scan Retention:** Configure auto-delete period (default: 7 days, options: 3/7/14/30 days, never).

---

## 6. UI/UX "Delighters"

* **The "Spine" Transition:** When a book is identified, if the user taps the notification, the cover art expands from the center, but the background is a blurred version of the *original photo* where the spine was found.
* **Haptic Syntax:**
  * *Light Tap:* Shutter press.
  * *Double Tick:* Scan complete (Server sent `status: complete`).
  * *Heavy Buzz:* Error/Retry needed.

* **Gamification:** A "Session Counter" in the corner during a scanning spree. "12 books... 24 books... 50 books!"

---

## 7. API Integration Contract

### 7.1 Authentication

* **UUID Generation:** On app install, generate `uuid.v4()`. Store in `FlutterSecureStorage`.
* **Headers:** Send `X-Device-ID: <uuid>` on *every* request.

### 7.2 SSE Handling (Talaria Loop)

The app must handle the specific SSE events defined in the Backend PRD:

| Event | Action |
| --- | --- |
| `progress` | Update progress bar percentage on the job card. |
| `result` | **CRITICAL:** Upsert book to Drift DB (dedupe by ISBN). Prefetch `cover_url` to disk cache. |
| `complete` | Trigger "Job Done" haptic. Send `DELETE /cleanup` request. |
| `error` | Save to `FailedScans` table. Show error toast. Keep image in "Failed" queue for retry. |

### 7.3 Error Handling (Resilience)

* **Talaria 400 (Bad Image):** Save to `FailedScans` with error message "Image quality too low". Show toast.
* **Talaria 404 (No Books Found):** Save to `FailedScans` with error message "No books detected". Keep image for retry.
* **Talaria 429 (Rate Limit):** If global/device limit hit, disable shutter button and show countdown.
* **Network Loss:** Queue uploads locally. Retry when connection restored (WorkManager).

---

## 8. Offline Queue Management

### 8.1 Upload Queue Strategy

* **Failed Scan Storage:** Unlimited storage in `FailedScans` table (disk space permitting).
* **Auto-cleanup:** Delete entries older than configured retention period (default: 7 days).
* **User Control:** Settings allow manual deletion of all failed scans or individual items.

### 8.2 Retry Logic

* **Manual Retry:** User taps "Retry" on failed scan card.
* **Batch Retry:** "Retry All Failed" button in Library failed section.
* **Network Resume:** When network connection restored, prompt user to retry failed scans.

---

## 9. Migration from Old App

* Since the backend "Purge" removes user accounts and recommendations, the new app is a fresh start.
* **Onboarding:** A simple 3-slide tutorial explaining: "1. Snap Shelf. 2. AI Analyzes. 3. Books Saved Locally."

---

## 10. Draft `pubspec.yaml` Dependencies

```yaml
dependencies:
  flutter:
    sdk: flutter
  # State
  flutter_riverpod: ^2.4.9
  riverpod_annotation: ^2.3.3
  # Data
  drift: ^2.14.0
  sqlite3_flutter_libs: ^0.5.18
  path_provider: ^2.1.2
  # Network
  dio: ^5.4.0
  fetch_client: ^1.0.0 # Essential for SSE on web/mobile
  # UI/Camera
  camerawesome: ^2.0.0 # Or mobile_scanner if we just want simple UI
  flutter_animate: ^4.5.0
  google_fonts: ^6.1.0
  cached_network_image: ^3.3.1
  # Utils
  uuid: ^4.3.3
  flutter_secure_storage: ^9.0.0
  share_plus: ^7.2.1 # For CSV export

dev_dependencies:
  build_runner: ^2.4.8
  riverpod_generator: ^2.3.9
  drift_dev: ^2.14.0
```

---

## 11. User Stories

### Epic 1: Camera & Capture
- **US-1.1:** As a user, I want to open the app directly to the camera viewfinder so I can start scanning immediately.
- **US-1.2:** As a user, I want the shutter button to always be clickable so I can capture multiple books rapidly.
- **US-1.3:** As a user, I want haptic feedback when I capture a photo so I know the action registered.
- **US-1.4:** As a user, I want to pinch-zoom the camera so I can capture small book spines clearly.

### Epic 2: Upload & Processing
- **US-2.1:** As a user, I want to see my scans processing in a queue so I know what's happening.
- **US-2.2:** As a user, I want uploads to happen in the background so I can continue scanning.
- **US-2.3:** As a user, I want distinct haptic feedback for different processing stages so I understand progress without looking.
- **US-2.4:** As a user, I want to see real-time AI analysis status so I can track what the backend is doing.

### Epic 3: Library Management
- **US-3.1:** As a user, I want to see all my scanned books in a grid view so I can browse my library.
- **US-3.2:** As a user, I want to search my library instantly so I can find books quickly.
- **US-3.3:** As a user, I want my library to work offline so I can access it without internet.
- **US-3.4:** As a user, I want to export my library as CSV so I own my data.

### Epic 4: Error Handling & Retry
- **US-4.1:** As a user, I want failed scans to be saved with the original image so I can retry later.
- **US-4.2:** As a user, I want to see why a scan failed so I can understand what went wrong.
- **US-4.3:** As a user, I want to manually retry failed scans so I can recover from temporary errors.
- **US-4.4:** As a user, I want old failed scans to auto-delete after 7 days so my storage doesn't fill up.

### Epic 5: Settings & Privacy
- **US-5.1:** As a user, I want to see my device ID so I understand how I'm identified.
- **US-5.2:** As a user, I want to regenerate my device ID so I can reset my privacy.
- **US-5.3:** As a user, I want to clear cached images so I can reclaim storage space.
- **US-5.4:** As a user, I want to configure failed scan retention so I control cleanup behavior.

### Epic 6: Gamification & Delight
- **US-6.1:** As a user, I want to see a session counter during scanning sprees so I feel accomplishment.
- **US-6.2:** As a user, I want smooth cover art animations so the app feels polished.
- **US-6.3:** As a user, I want to see the original shelf photo behind book details so I remember context.

---

## 12. Acceptance Criteria

### MVP Release Criteria
- [ ] Camera opens in < 1.0s on cold start
- [ ] Shutter latency < 50ms from tap to animation
- [ ] Background upload isolates don't block UI
- [ ] SSE events properly update UI in real-time
- [ ] Books deduplicate silently by ISBN
- [ ] Failed scans saved to retry queue with image
- [ ] Library search works offline with FTS5
- [ ] CSV export generates valid file
- [ ] Auto-cleanup deletes failed scans after 7 days
- [ ] All haptic feedback implemented per spec

### Performance Criteria
- [ ] Zero dropped frames during SSE rendering
- [ ] Library scrolling at 60fps with 1000+ books
- [ ] Image compression in isolate completes in < 500ms
- [ ] SQLite queries return in < 100ms

### Quality Criteria
- [ ] No memory leaks during scanning sessions
- [ ] Camera session properly releases on background
- [ ] Network failures handled gracefully
- [ ] Rate limiting shows countdown timer

---

## 13. Out of Scope (Future Considerations)

- Reading status tracking (To Read, Reading, Finished)
- Personal ratings and reviews
- Social features / sharing
- Barcode scanning mode
- Multi-language support (MVP is English-only)
- Cloud backup of library data
- Advanced search filters (genre, year, publisher)

---

## 14. Dependencies & Risks

### Dependencies
- Talaria backend API must be stable and available
- ISBNdb/Google Books APIs must be accessible for cover images
- Camera permissions must be granted by user

### Technical Risks
- **SSE Reliability:** Network interruptions during streaming could lose data.
  - *Mitigation:* Implement reconnection logic with exponential backoff.
- **Storage Growth:** Unlimited failed scans could consume device storage.
  - *Mitigation:* Default 7-day auto-cleanup with user override.
- **Camera Performance:** Older devices may struggle with high-res capture.
  - *Mitigation:* Adaptive image quality based on device capabilities.

### UX Risks
- **Over-scanning:** Users might capture blurry/duplicate images rapidly.
  - *Mitigation:* Visual feedback during processing queue buildup.
- **Failed Scan Confusion:** Users may not understand why scans fail.
  - *Mitigation:* Clear error messages with actionable suggestions.
</file>

<file path="web/index.html">
<!DOCTYPE html>
<html>
<head>
  <base href="$FLUTTER_BASE_HREF">
  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="wingtip">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">
  <link rel="icon" type="image/png" href="favicon.png"/>
  <title>wingtip</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>
</file>

<file path="web/manifest.json">
{
    "name": "wingtip",
    "short_name": "wingtip",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}
</file>

<file path=".gitignore">
# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.build/
.buildlog/
.history
.svn/
.swiftpm/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
**/doc/api/
**/ios/Flutter/.last_build_id
.dart_tool/
.flutter-plugins-dependencies
.pub-cache/
.pub/
/build/
/coverage/

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
/android/app/debug
/android/app/profile
/android/app/release
</file>

<file path=".ios-optimizer.yml">
project_name: "Wingtip"
min_ios_version: "15.0"
focus_areas:
  - camera
  - promotion
  - haptics
  - widgets
  - navigation
targets:
  cold_start_ms: 1000
  camera_init_ms: 500
  target_fps: 120
  max_widget_depth: 10
  max_rebuild_count: 50
exclude_patterns:
  - "**/*.g.dart"
  - "**/*.freezed.dart"
  - "**/test/**"
  - "**/build/**"
  - "**/.ralph-tui/**"
camera_settings:
  max_preview_width: 1920
  max_preview_height: 1920
  check_background_pause: true
  verify_disposal: true
  check_permission_handling: true
promotion_settings:
  require_plist_config: true
  check_animation_curves: true
  max_frame_budget_ms: 8.33
  warn_expensive_builds: true
haptic_settings:
  prefer_impact_over_vibrate: true
  verify_patterns:
    light: ["shutter", "tap"]
    medium: ["save", "result", "complete"]
    heavy: ["error", "rate_limit"]
widget_settings:
  require_const_constructors: true
  check_unnecessary_rebuilds: true
  max_depth_without_keys: 5
  prefer_stateless_over_stateful: true
navigation_settings:
  prefer_cupertino_routes: true
  check_route_transitions: true
  verify_gesture_support: true
reporting:
  format: "markdown"
  output_file: "ios-optimization-report.md"
  include_code_snippets: true
  prioritize_by_impact: true
  group_by_category: true
custom_checks:
  - name: "SSE stream handling"
    description: "Verify SSE doesn't block UI thread"
  - name: "Drift watch() vs get()"
    description: "Ensure streams used for reactive UI"
  - name: "Image compression isolate"
    description: "Verify compute() for background processing"
  - name: "Swiss Utility theme"
    description: "Check for elevation: 0, border usage"
</file>

<file path=".metadata">
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "3b62efc2a3da49882f43c372e0bc53daef7295a6"
  channel: "stable"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: 3b62efc2a3da49882f43c372e0bc53daef7295a6
      base_revision: 3b62efc2a3da49882f43c372e0bc53daef7295a6
    - platform: android
      create_revision: 3b62efc2a3da49882f43c372e0bc53daef7295a6
      base_revision: 3b62efc2a3da49882f43c372e0bc53daef7295a6
    - platform: ios
      create_revision: 3b62efc2a3da49882f43c372e0bc53daef7295a6
      base_revision: 3b62efc2a3da49882f43c372e0bc53daef7295a6
    - platform: web
      create_revision: 3b62efc2a3da49882f43c372e0bc53daef7295a6
      base_revision: 3b62efc2a3da49882f43c372e0bc53daef7295a6

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'
</file>

<file path="analysis_options.yaml">
include: package:flutter_lints/flutter.yaml
linter:
  rules:
</file>

<file path="PRD-wingtip.md">
# Product Requirements Document: Project Wingtip (Frontend)

**Version:** 1.0
**Status:** Draft
**Target Platform:** Flutter (iOS/Android)
**Backend:** [Project Talaria]

---

## 1. Executive Summary

**Wingtip** is the "dumb" but beautiful lens for the Talaria brain. It is a local-first, offline-capable library manager that uses the camera solely as a data pipe.

### Core Philosophy

**"The Shutter That Remembers"** — While the backend (Talaria) forgets everything instantly, Wingtip remembers everything forever. It is the permanent residence for the data streaming back from the edge.

### Design Principles (The "Slim & Fast" Mandate)

1. **Zero-Blocking UI:** The shutter button must *always* be clickable. Uploads happen in background isolates.
2. **Haptic Fidelity:** Every stage of the SSE stream (Sent → Analyzed → Enriched) provides distinct haptic feedback.
3. **Optimistic fluidity:** The UI should predict success. Book covers animate into place before the full metadata arrives.
4. **Local Sovereignty:** All data lives in SQLite (Drift). The app works 100% offline for viewing/searching, only needing network to *scan*.

---

## 2. Success Metrics (Frontend)

| Metric | Target | Measurement |
| --- | --- | --- |
| **Cold Start Time** | < 1.0s | Time to interactive camera viewfinder |
| **Shutter Latency** | < 50ms | Tap to capture animation start |
| **Jank (Frame Drop)** | 0% | No dropped frames during SSE stream rendering |
| **Battery Impact** | Low | Camera session paused immediately on backgrounding |
| **Offline Reliability** | 100% | Library fully searchable in Airplane Mode |

---

## 3. Tech Stack & Architecture

### 3.1 Core Stack

* **Framework:** Flutter (Latest Stable)
* **Language:** Dart 3.0+
* **State Management:** `flutter_riverpod` (v2, Generator syntax) for reactive UI updates.
* **Local Database:** `drift` (SQLite abstraction) for high-performance structured storage.
* **Camera:** `camerawesome` (Better UI customization than standard `camera` package) or `camera` with custom texture implementation.
* **Networking:** `dio` (Multipart uploads) + `fetch_client` (for SSE streaming handling).

### 3.2 Data Flow (The "Capture Loop")

1. **Capture:** User taps shutter.
* *UI:* Flash animation, haptic "click", thumbnail flies into a "processing queue" stack.
* *Logic:* Image saved to temp cache. `ScanRepository` spawns an Isolate to compress/resize.


2. **Upload:**
* *Logic:* `TalariaClient` uploads to `POST /v3/jobs/scans`.
* *Header:* Injects `X-Device-ID` (UUID generated on first launch).


3. **Listen (The Stream):**
* *Logic:* App connects to `GET /v3/jobs/scans/{jobId}/stream`.
* *State:* Riverpod provider `scanStreamProvider(jobId)` listens to SSE events.


4. **Ingest:**
* *Event `result`:* Data is upserted immediately into local SQLite `books` table.
* *Event `complete`:* Temporary image cache is cleared.


5. **Display:**
* The "Library" view listens to the SQLite stream, so books "pop" into the list automatically as they are saved.



---

## 4. Feature Specifications

### 4.1 The Viewfinder (Home Screen)

The app opens directly to the camera (Snapchat style) to reduce friction.

* **UI Elements:**
* **Shutter Button:** Large, bottom center. Animated ring indicates "Processing" load.
* **Library Peek:** Bottom right thumbnail showing the last scanned book cover. Tapping opens Library.
* **Settings/Flash:** Minimal top bar.
* **"Stream" Overlay:** A subtle, transparent log overlay (Matrix style but clean) that fades in/out showing real-time status: *"Analyzing... Found 12 spines... Enriched 'The Martian'..."*.


* **Gestures:**
* **Swipe Up:** Open Library.
* **Pinch:** Zoom (Essential for small spines).



### 4.2 The Processing Queue (The "Feed")

Because the user can snap 5 photos in 3 seconds, the UI cannot block.

* **Implementation:** A horizontal "stories" style bar or a floating stack that shows active jobs.
* **States per Job:**
1. **Uploading:** Indeterminate progress bar.
2. **Analyzing (Gemini):** Pulsing "AI" icon.
3. **Enriching:** Rapid cover art flickering as URLs resolve.
4. **Done:** Disappears and increments the "New Books" badge on the Library icon.



### 4.3 The Library (Local SQLite)

* **View:** Infinite scroll grid of book covers.
* **Search:** Instant local full-text search (FTS5 via Drift) against Title, Author, ISBN.
* **Manual Override:** If Talaria returns `flag: review_needed`, the book card has a yellow "Review" border. Tapping allows manual metadata editing.
* **Export:** "Export CSV" button to dump the SQLite DB to the device file system (User data ownership).

### 4.4 Settings & Privacy

* **Device ID:** Display the `X-Device-ID` UUID with a "Regenerate" button (Privacy nuking).
* **Cache Management:** Button to "Clear Cached Images" (covers downloaded from ISBNdb/Google).

---

## 5. UI/UX "Delighters"

* **The "Spine" Transition:** When a book is identified, if the user taps the notification, the cover art expands from the center, but the background is a blurred version of the *original photo* where the spine was found.
* **Haptic Syntax:**
* *Light Tap:* Shutter press.
* *Double Tick:* Scan complete (Server sent `status: complete`).
* *Heavy Buzz:* Error/Retry needed.


* **Gamification:** A "Session Counter" in the corner during a scanning spree. "12 books... 24 books... 50 books!"

---

## 6. API Integration Contract

### 6.1 Authentication

* **UUID Generation:** On app install, generate `uuid.v4()`. Store in `FlutterSecureStorage`.
* **Headers:** Send `X-Device-ID: <uuid>` on *every* request.

### 6.2 SSE Handling (Talaria Loop)

The app must handle the specific SSE events defined in the Backend PRD:

| Event | Action |
| --- | --- |
| `progress` | Update progress bar percentage on the job card. |
| `result` | **CRITICAL:** Upsert book to Drift DB. Prefetch `cover_url` to disk cache. |
| `complete` | Trigger "Job Done" haptic. Send `DELETE /cleanup` request. |
| `error` | Show toast notification. If `429`, show cool-down timer. |

### 6.3 Error Handling (Resilience)

* **Talaria 400 (Bad Image):** Show a "Too Blurry" overlay on the viewfinder immediately.
* **Talaria 429 (Rate Limit):** If global/device limit hit, disable shutter button and show countdown.
* **Network Loss:** Queue uploads locally. Retry when connection restored (WorkManager).

---

## 7. Migration from Old App

* Since the backend "Purge" removes user accounts and recommendations, the new app is a fresh start.
* **Onboarding:** A simple 3-slide tutorial explaining: "1. Snap Shelf. 2. AI Analyzes. 3. Books Saved Locally."

---

## 8. Draft `pubspec.yaml` Dependencies

```yaml
dependencies:
  flutter:
    sdk: flutter
  # State
  flutter_riverpod: ^2.4.9
  riverpod_annotation: ^2.3.3
  # Data
  drift: ^2.14.0
  sqlite3_flutter_libs: ^0.5.18
  path_provider: ^2.1.2
  # Network
  dio: ^5.4.0
  fetch_client: ^1.0.0 # Essential for SSE on web/mobile
  # UI/Camera
  camerawesome: ^2.0.0 # Or mobile_scanner if we just want simple UI
  flutter_animate: ^4.5.0
  google_fonts: ^6.1.0
  cached_network_image: ^3.3.1
  # Utils
  uuid: ^4.3.3
  flutter_secure_storage: ^9.0.0
  share_plus: ^7.2.1 # For CSV export

dev_dependencies:
  build_runner: ^2.4.8
  riverpod_generator: ^2.3.9
  drift_dev: ^2.14.0

```

---

### Next Steps for You

Would you like me to:

1. **Scaffold the Flutter Project:** Generate the directory structure and the core `ScanRepository` class that handles the Multipart Upload + SSE listening loop?
2. **Design the Local DB Schema:** Write the `Drift` table definition for `Books` to ensure it matches the JSON output from Talaria?
3. **Refine the API Client:** Create the Dio interceptor for the `X-Device-ID` injection?
</file>

<file path="README.md">
# Wingtip
</file>

<file path="US-wingtip.md">
### **Design Language: "Swiss Utility"**

* **Typography:** *JetBrains Mono* (headers/data) + *Inter* (body).
* **Palette:** `#000000` (Background), `#FFFFFF` (Text), `#FF3B30` (Accent - "International Orange" for status/action).
* **Borders:** 1px solid white borders on cards. No drop shadows.
* **Motion:** 0ms delay. Snap transitions.

---

# User Stories: Project Wingtip (MVP)

## Epic 1: Foundations & Architecture

*Building the "skeleton" of the app.*

**US-101: Initialize Flutter Project with Riverpod & Drift**
**As a** developer
**I want to** scaffold the app with the latest Flutter stack
**So that** I have a stable foundation for state and data.

* [ ] Project created with `com.ooheynerds.wingtip`.
* [ ] `flutter_riverpod` (v3) installed and `ProviderScope` configured.
* [ ] `drift` (v2) installed with `sqlite3_flutter_libs` for native performance.
* [ ] Folder structure set: `features/`, `core/`, `data/`.

**US-102: Implement "Swiss Utility" Theme System**
**As a** user
**I want to** experience a high-contrast, clean interface
**So that** the app feels precise and professional.

* [ ] Theme mode locked to **Dark** (OLED black).
* [ ] Font set to *JetBrains Mono* for all numbers/IDs and *Inter* for text.
* [ ] Components use 1px solid borders instead of shadows (flat design).
* [ ] Accent color defined as `#FF3B30` (International Orange).

**US-103: Generate & Store Persistent Device ID**
**As a** system
**I want to** generate a UUID v4 on first launch
**So that** I can authenticate with the Talaria backend.

* [ ] On first run, generate `uuid.v4()`.
* [ ] Store securely in `FlutterSecureStorage` key `device_id`.
* [ ] Inject `X-Device-ID` header into all Dio requests.
* [ ] Provide a "Regenerate ID" button in debug settings.

**US-104: Offline-First Network Client**
**As a** system
**I want to** queue requests when offline
**So that** I don't lose scans if the network drops.

* [ ] Configure `Dio` with a connection retry interceptor.
* [ ] Detect network status (Connectivity Plus).
* [ ] If offline, show a subtle "OFFLINE" tag in the top-right corner (Swiss style: small text, boxed border).

---

## Epic 2: The Viewfinder (Capture)

*The primary interface. Fast, dumb, and responsive.*

**US-105: Instant Camera Initialization**
**As a** user
**I want to** see the camera immediately upon opening the app
**So that** I can capture a book spine instantly.

* [ ] App launches directly to `CameraScreen`.
* [ ] Cold start to live feed < 1.0s.
* [ ] Hide system status bar for full immersion.

**US-106: Non-Blocking Shutter Action**
**As a** user
**I want to** tap the shutter button repeatedly without waiting
**So that** I can scan a whole shelf in seconds.

* [ ] Shutter button is a large, white ring at bottom center.
* [ ] On tap: Haptic "Tick" (Light impact).
* [ ] On tap: Screen flashes white (100ms opacity).
* [ ] UI does **not** show a loading spinner on the button itself (always clickable).

**US-107: Background Image Processing**
**As a** system
**I want to** compress and resize images in a background Isolate
**So that** the UI thread never janks.

* [ ] Spawn `compute` isolate for image manipulation.
* [ ] Resize to max 1920px (height or width) to save bandwidth.
* [ ] Compress to JPEG (quality 85).
* [ ] Save temporary file to `NSTemporaryDirectory`.

**US-108: The "Processing Stack" UI**
**As a** user
**I want to** see my active uploads as a queue
**So that** I know the system is working.

* [ ] Horizontal list above the shutter button.
* [ ] Each item is a 40x60px thumbnail of the photo.
* [ ] Status indicators: "Uploading" (Yellow border), "Analyzing" (Blue border), "Done" (Green border).
* [ ] Auto-remove card after 5 seconds of "Done" state.

**US-109: Manual Focus & Zoom**
**As a** user
**I want to** pinch to zoom and tap to focus
**So that** I can capture small text on spines.

* [ ] Pinch gesture controls camera zoom level (1x - 4x).
* [ ] Tap on preview sets focus point.
* [ ] Show a square bracket cursor `[ ]` at focus point (Swiss style).

---

## Epic 3: The Talaria Link (Integration)

*Connecting to the backend brain.*

**US-110: Upload Image to Talaria**
**As a** system
**I want to** POST the image to `/v3/jobs/scans`
**So that** I can start the analysis pipeline.

* [ ] Multipart upload of the processed JPEG.
* [ ] Handle `202 Accepted` response.
* [ ] Parse `jobId` and `streamUrl` from response.
* [ ] Update UI state to "Listening".

**US-111: SSE Stream Listener**
**As a** system
**I want to** listen to Server-Sent Events for a specific Job ID
**So that** I receive real-time updates.

* [ ] Open connection to `streamUrl` using `fetch_client`.
* [ ] Maintain open connection until `complete` event or timeout (5m).
* [ ] Parse incoming JSON chunks (`progress`, `result`, `complete`).

**US-112: Visualize "Progress" Events**
**As a** user
**I want to** see text updates as the AI thinks
**So that** I feel the speed of the system.

* [ ] Overlay transparent text on the specific job thumbnail.
* [ ] Display `stage` messages: "Looking...", "Reading...", "Enriching...".
* [ ] Use Monospace font for these logs.

**US-113: Handle "Result" Events (Data Upsert)**
**As a** system
**I want to** save incoming book data immediately
**So that** the user sees results before the job finishes.

* [ ] Listen for `event: result`.
* [ ] Map JSON to Drift `Book` entity.
* [ ] `INSERT OR REPLACE` into local DB (deduplicate by ISBN).
* [ ] Trigger a specific haptic pattern (Double Click) on success.

**US-114: Handle "Complete" & Cleanup**
**As a** system
**I want to** clean up resources when a job finishes
**So that** I don't waste storage or battery.

* [ ] Listen for `event: complete`.
* [ ] Send `DELETE /v3/jobs/scans/{jobId}/cleanup` request.
* [ ] Delete local temporary JPEG file.
* [ ] Close SSE connection.

**US-115: Handle Global Rate Limits**
**As a** user
**I want to** know if I've hit the daily limit
**So that** I don't waste time snapping photos.

* [ ] Intercept `429 Too Many Requests`.
* [ ] Parse `retryAfterMs`.
* [ ] Disable shutter button.
* [ ] Show a countdown timer overlay: "LIMIT REACHED. RESETS IN HH:MM:SS".

---

## Epic 4: The Library (Drift DB)

*The permanent home for the data.*

**US-116: Drift Database Schema**
**As a** developer
**I want to** define the `Books` table
**So that** I can store metadata efficiently.

* [ ] Columns: `isbn` (PK), `title`, `author`, `coverUrl`, `format`, `addedDate`, `spineConfidence`.
* [ ] Index on `addedDate` (descending) for default sort.

**US-117: Library Grid View**
**As a** user
**I want to** see my books in a clean grid
**So that** I can browse my collection.

* [ ] 3-column grid of cover images.
* [ ] Aspect ratio 1:1.5 (Standard book size).
* [ ] If no cover URL, show a solid grey card with Title/Author in monospace text.
* [ ] Infinite scroll (lazy loading from Drift).

**US-118: Real-time List Updates**
**As a** user
**I want to** see new books pop in automatically
**So that** I don't have to pull-to-refresh.

* [ ] Use Drift's `watch()` method to stream DB updates to the UI.
* [ ] Animate new items: Fade in + Slide up (200ms).

**US-119: Full-Text Search (FTS5)**
**As a** user
**I want to** search my library instantly
**So that** I can find a specific book.

* [ ] Enable FTS5 module in Drift.
* [ ] Search bar at top of Library view.
* [ ] Queries filter `title`, `author`, and `isbn`.
* [ ] Results update as I type (< 100ms latency).

**US-120: "Review Needed" Indicator**
**As a** user
**I want to** see which books had low confidence
**So that** I can manually check them.

* [ ] Check `flag: review_needed` from backend.
* [ ] Overlay a small yellow triangle icon on the book cover.
* [ ] Sort option: "Needs Review First".

**US-121: Export Data to CSV**
**As a** user
**I want to** export my library
**So that** I own my data.

* [ ] "Export" button in settings.
* [ ] Generates `wingtip_library_[date].csv`.
* [ ] Opens system share sheet (Save to Files, AirDrop, etc.).

---

## Epic 5: Detail & Interaction

*The "Swiss Utility" feel comes from these interaction details.*

**US-122: Minimal Book Detail View**
**As a** user
**I want to** tap a book to see its data
**So that** I can verify the scan.

* [ ] Modal bottom sheet (dragging up to full screen).
* [ ] Layout: Large Cover (Left) + Data Fields (Right) - "Passport style".
* [ ] Fields: ISBN (Monospace), Title (Bold), Author, Format.
* [ ] Edit button to manually correct fields.

**US-123: The "Raw Data" Toggle**
**As a** user
**I want to** see the raw JSON for a book
**So that** I can geek out on the metadata.

* [ ] Toggle switch in Detail View: "Visual" vs "JSON".
* [ ] JSON view displays formatted code block in monospace green.

**US-124: Swipe to Delete**
**As a** user
**I want to** remove bad scans easily
**So that** my library stays clean.

* [ ] In Library view, long-press to enter "Select Mode".
* [ ] Select multiple items -> Tap Trash icon.
* [ ] Confirm dialog: "Delete X books?".

**US-125: Haptic Feedback Strategy**
**As a** user
**I want to** feel the app working
**So that** I don't have to look at the screen constantly.

* [ ] Shutter: `HapticFeedback.lightImpact()`.
* [ ] Scan Success: `HapticFeedback.mediumImpact()`.
* [ ] Error: `HapticFeedback.heavyImpact()`.

**US-126: Cache Manager**
**As a** user
**I want to** clear cached cover images
**So that** the app doesn't eat up my storage.

* [ ] Settings option: "Clear Image Cache".
* [ ] Uses `DefaultCacheManager.emptyCache()`.
* [ ] Shows current cache size (e.g., "Cache: 124 MB").

---

## Epic 6: Polish & Launch

*Getting ready for the store.*

**US-127: App Icon & Splash Screen**
**As a** user
**I want to** recognize the app on my home screen
**So that** I can launch it quickly.

* [ ] Icon: Abstract white "Wing" glyph on Black background.
* [ ] Splash: Black screen, white "Wingtip" text (Monospace), fades out.

**US-128: Permission Priming**
**As a** user
**I want to** understand why you need camera access
**So that** I trust the app.

* [ ] Before requesting permission, show a full-screen "Primer" slide.
* [ ] Text: "Wingtip needs your camera to see books. Images are processed and deleted instantly."
* [ ] "Grant Access" button triggers OS prompt.

**US-129: Empty States**
**As a** user
**I want to** see helpful text when my library is empty
**So that** I know what to do.

* [ ] Library View empty state: "0 Books. Tap [O] to scan."
* [ ] Use ASCII art or a simple vector outline of a bookshelf.

**US-130: Error Toasts (Snackbars)**
**As a** user
**I want to** see errors without them blocking me
**So that** I can keep scanning.

* [ ] Custom Snackbar design.
* [ ] Black background, white text, red left border.
* [ ] Floating at bottom of screen.
* [ ] Dismiss on tap.
</file>

<file path="android/app/src/main/res/drawable/launch_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item>
        <bitmap android:gravity="fill" android:src="@drawable/background"/>
    </item>
    <item>
        <bitmap android:gravity="center" android:src="@drawable/splash"/>
    </item>
</layer-list>
</file>

<file path="android/app/src/main/res/drawable-v21/launch_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item>
        <bitmap android:gravity="fill" android:src="@drawable/background"/>
    </item>
    <item>
        <bitmap android:gravity="center" android:src="@drawable/splash"/>
    </item>
</layer-list>
</file>

<file path="android/app/src/main/res/values/styles.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">@drawable/launch_background</item>
        <item name="android:forceDarkAllowed">false</item>
        <item name="android:windowFullscreen">false</item>
        <item name="android:windowDrawsSystemBarBackgrounds">false</item>
        <item name="android:windowLayoutInDisplayCutoutMode">shortEdges</item>
    </style>
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
</file>

<file path="android/app/src/main/res/values-night/styles.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">@drawable/launch_background</item>
        <item name="android:forceDarkAllowed">false</item>
        <item name="android:windowFullscreen">false</item>
        <item name="android:windowDrawsSystemBarBackgrounds">false</item>
        <item name="android:windowLayoutInDisplayCutoutMode">shortEdges</item>
    </style>
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
</file>

<file path="android/app/src/main/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <uses-permission android:name="android.permission.CAMERA"/>
    <uses-feature android:name="android.hardware.camera" android:required="true"/>
    <application
        android:label="wingtip"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>
</file>

<file path="android/app/build.gradle.kts">
plugins {
    id("com.android.application")
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.ooheynerds.wingtip"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_17.toString()
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "com.ooheynerds.wingtip"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
        }
    }
}

flutter {
    source = "../.."
}
</file>

<file path="ios/Flutter/Debug.xcconfig">
#include? "Pods/Target Support Files/Pods-Runner/Pods-Runner.debug.xcconfig"
#include "Generated.xcconfig"
</file>

<file path="ios/Flutter/Release.xcconfig">
#include? "Pods/Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig"
#include "Generated.xcconfig"
</file>

<file path="ios/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json">
{"images":[{"size":"20x20","idiom":"iphone","filename":"Icon-App-20x20@2x.png","scale":"2x"},{"size":"20x20","idiom":"iphone","filename":"Icon-App-20x20@3x.png","scale":"3x"},{"size":"29x29","idiom":"iphone","filename":"Icon-App-29x29@1x.png","scale":"1x"},{"size":"29x29","idiom":"iphone","filename":"Icon-App-29x29@2x.png","scale":"2x"},{"size":"29x29","idiom":"iphone","filename":"Icon-App-29x29@3x.png","scale":"3x"},{"size":"40x40","idiom":"iphone","filename":"Icon-App-40x40@2x.png","scale":"2x"},{"size":"40x40","idiom":"iphone","filename":"Icon-App-40x40@3x.png","scale":"3x"},{"size":"57x57","idiom":"iphone","filename":"Icon-App-57x57@1x.png","scale":"1x"},{"size":"57x57","idiom":"iphone","filename":"Icon-App-57x57@2x.png","scale":"2x"},{"size":"60x60","idiom":"iphone","filename":"Icon-App-60x60@2x.png","scale":"2x"},{"size":"60x60","idiom":"iphone","filename":"Icon-App-60x60@3x.png","scale":"3x"},{"size":"20x20","idiom":"ipad","filename":"Icon-App-20x20@1x.png","scale":"1x"},{"size":"20x20","idiom":"ipad","filename":"Icon-App-20x20@2x.png","scale":"2x"},{"size":"29x29","idiom":"ipad","filename":"Icon-App-29x29@1x.png","scale":"1x"},{"size":"29x29","idiom":"ipad","filename":"Icon-App-29x29@2x.png","scale":"2x"},{"size":"40x40","idiom":"ipad","filename":"Icon-App-40x40@1x.png","scale":"1x"},{"size":"40x40","idiom":"ipad","filename":"Icon-App-40x40@2x.png","scale":"2x"},{"size":"50x50","idiom":"ipad","filename":"Icon-App-50x50@1x.png","scale":"1x"},{"size":"50x50","idiom":"ipad","filename":"Icon-App-50x50@2x.png","scale":"2x"},{"size":"72x72","idiom":"ipad","filename":"Icon-App-72x72@1x.png","scale":"1x"},{"size":"72x72","idiom":"ipad","filename":"Icon-App-72x72@2x.png","scale":"2x"},{"size":"76x76","idiom":"ipad","filename":"Icon-App-76x76@1x.png","scale":"1x"},{"size":"76x76","idiom":"ipad","filename":"Icon-App-76x76@2x.png","scale":"2x"},{"size":"83.5x83.5","idiom":"ipad","filename":"Icon-App-83.5x83.5@2x.png","scale":"2x"},{"size":"1024x1024","idiom":"ios-marketing","filename":"Icon-App-1024x1024@1x.png","scale":"1x"}],"info":{"version":1,"author":"xcode"}}
</file>

<file path="ios/Runner/Assets.xcassets/LaunchImage.imageset/Contents.json">
{
  "images" : [
    {
      "filename" : "LaunchImage.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "LaunchImage@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "filename" : "LaunchImage@3x.png",
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="ios/Runner/Base.lproj/LaunchScreen.storyboard">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="12121" systemVersion="16G29" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="12089"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="Ydg-fD-yQy"/>
                        <viewControllerLayoutGuide type="bottom" id="xbc-2k-c8Z"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <imageView clipsSubviews="YES" userInteractionEnabled="NO" contentMode="scaleToFill" image="LaunchBackground" translatesAutoresizingMaskIntoConstraints="NO" id="tWc-Dq-wcI"/>
                            <imageView opaque="NO" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="center" image="LaunchImage" translatesAutoresizingMaskIntoConstraints="NO" id="YRO-k0-Ey4"></imageView>
                        </subviews>
                        <color key="backgroundColor" red="1" green="1" blue="1" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
                        <constraints>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="leading" secondItem="Ze5-6b-2t3" secondAttribute="leading" id="3T2-ad-Qdv"/>
                            <constraint firstItem="tWc-Dq-wcI" firstAttribute="bottom" secondItem="Ze5-6b-2t3" secondAttribute="bottom" id="RPx-PI-7Xg"/>
                            <constraint firstItem="tWc-Dq-wcI" firstAttribute="top" secondItem="Ze5-6b-2t3" secondAttribute="top" id="SdS-ul-q2q"/>
                            <constraint firstAttribute="trailing" secondItem="tWc-Dq-wcI" secondAttribute="trailing" id="Swv-Gf-Rwn"/>
                            <constraint firstAttribute="trailing" secondItem="YRO-k0-Ey4" secondAttribute="trailing" id="TQA-XW-tRk"/>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="bottom" secondItem="Ze5-6b-2t3" secondAttribute="bottom" id="duK-uY-Gun"/>
                            <constraint firstItem="tWc-Dq-wcI" firstAttribute="leading" secondItem="Ze5-6b-2t3" secondAttribute="leading" id="kV7-tw-vXt"/>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="top" secondItem="Ze5-6b-2t3" secondAttribute="top" id="xPn-NY-SIU"/>
                        </constraints>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
    <resources>
        <image name="LaunchImage" width="1242" height="2688"/>
        <image name="LaunchBackground" width="1" height="1"/>
    </resources>
</document>
</file>

<file path="lib/core/network_client.dart">
import 'package:dio/dio.dart';
class RateLimitException implements Exception {
  final int retryAfterMs;
  final String message;
  RateLimitException({
    required this.retryAfterMs,
    this.message = 'Rate limit exceeded',
  });
  @override
  String toString() => 'RateLimitException: $message (retry after ${retryAfterMs}ms)';
}
class NetworkClient {
  late final Dio _dio;
  NetworkClient({String? baseUrl}) {
    _dio = Dio(
      BaseOptions(
        baseUrl: baseUrl ?? '',
        connectTimeout: const Duration(seconds: 10),
        receiveTimeout: const Duration(seconds: 10),
      ),
    );
    _dio.interceptors.add(RetryInterceptor(dio: _dio));
  }
  Dio get dio => _dio;
}
class RetryInterceptor extends Interceptor {
  final Dio dio;
  final int maxRetries;
  final Duration initialDelay;
  RetryInterceptor({
    required this.dio,
    this.maxRetries = 3,
    this.initialDelay = const Duration(milliseconds: 500),
  });
  @override
  Future<void> onError(
    DioException err,
    ErrorInterceptorHandler handler,
  ) async {
    // Check for 429 rate limit response
    if (err.response?.statusCode == 429) {
      final retryAfterMs = _parseRetryAfter(err.response);
      handler.reject(
        DioException(
          requestOptions: err.requestOptions,
          response: err.response,
          type: err.type,
          error: RateLimitException(retryAfterMs: retryAfterMs),
        ),
      );
      return;
    }
    if (_shouldRetry(err)) {
      final retryCount = err.requestOptions.extra['retryCount'] as int? ?? 0;
      if (retryCount < maxRetries) {
        final delay = _calculateDelay(retryCount);
        await Future.delayed(delay);
        err.requestOptions.extra['retryCount'] = retryCount + 1;
        try {
          final response = await dio.fetch(err.requestOptions);
          return handler.resolve(response);
        } on DioException catch (e) {
          return super.onError(e, handler);
        }
      }
    }
    return super.onError(err, handler);
  }
  int _parseRetryAfter(Response? response) {
    if (response == null) return 60000;
    final retryAfterHeader = response.headers.value('retry-after');
    if (retryAfterHeader != null) {
      final seconds = int.tryParse(retryAfterHeader);
      if (seconds != null) {
        return seconds * 1000;
      }
    }
    if (response.data is Map<String, dynamic>) {
      final data = response.data as Map<String, dynamic>;
      final retryAfterMs = data['retryAfterMs'] as int?;
      if (retryAfterMs != null) {
        return retryAfterMs;
      }
    }
    return 60000;
  }
  bool _shouldRetry(DioException err) {
    return err.type == DioExceptionType.connectionTimeout ||
        err.type == DioExceptionType.sendTimeout ||
        err.type == DioExceptionType.receiveTimeout ||
        err.type == DioExceptionType.connectionError ||
        (err.type == DioExceptionType.badResponse &&
            err.response?.statusCode != null &&
            err.response!.statusCode! >= 500);
  }
  Duration _calculateDelay(int retryCount) {
    return initialDelay * (1 << retryCount);
  }
}
</file>

<file path="lib/core/talaria_client.dart">
import 'package:dio/dio.dart';
class ScanJobResponse {
  final String jobId;
  final String streamUrl;
  ScanJobResponse({
    required this.jobId,
    required this.streamUrl,
  });
  factory ScanJobResponse.fromJson(Map<String, dynamic> json) {
    return ScanJobResponse(
      jobId: json['jobId'] as String,
      streamUrl: json['streamUrl'] as String,
    );
  }
}
class TalariaClient {
  final Dio _dio;
  final String _deviceId;
  TalariaClient({
    required Dio dio,
    required String deviceId,
  })  : _dio = dio,
        _deviceId = deviceId;
  Future<ScanJobResponse> uploadImage(String imagePath) async {
    final formData = FormData.fromMap({
      'image': await MultipartFile.fromFile(
        imagePath,
        filename: imagePath.split('/').last,
      ),
      'device_id': _deviceId,
    });
    final response = await _dio.post(
      '/v3/jobs/scans',
      data: formData,
      options: Options(
        headers: {
          'X-Device-ID': _deviceId,
        },
        validateStatus: (status) => status == 202,
      ),
    );
    return ScanJobResponse.fromJson(response.data as Map<String, dynamic>);
  }
  Future<void> cleanupJob(String jobId) async {
    await _dio.delete(
      '/v3/jobs/scans/$jobId/cleanup',
      options: Options(
        headers: {
          'X-Device-ID': _deviceId,
        },
      ),
    );
  }
}
</file>

<file path="lib/data/database.g.dart">
part of 'database.dart';
class $BooksTable extends Books with TableInfo<$BooksTable, Book> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BooksTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _isbnMeta = const VerificationMeta('isbn');
  @override
  late final GeneratedColumn<String> isbn = GeneratedColumn<String>(
    'isbn',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
    'title',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _authorMeta = const VerificationMeta('author');
  @override
  late final GeneratedColumn<String> author = GeneratedColumn<String>(
    'author',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _coverUrlMeta = const VerificationMeta(
    'coverUrl',
  );
  @override
  late final GeneratedColumn<String> coverUrl = GeneratedColumn<String>(
    'cover_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _formatMeta = const VerificationMeta('format');
  @override
  late final GeneratedColumn<String> format = GeneratedColumn<String>(
    'format',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _addedDateMeta = const VerificationMeta(
    'addedDate',
  );
  @override
  late final GeneratedColumn<int> addedDate = GeneratedColumn<int>(
    'added_date',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _spineConfidenceMeta = const VerificationMeta(
    'spineConfidence',
  );
  @override
  late final GeneratedColumn<double> spineConfidence = GeneratedColumn<double>(
    'spine_confidence',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _reviewNeededMeta = const VerificationMeta(
    'reviewNeeded',
  );
  @override
  late final GeneratedColumn<bool> reviewNeeded = GeneratedColumn<bool>(
    'review_needed',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("review_needed" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  @override
  List<GeneratedColumn> get $columns => [
    isbn,
    title,
    author,
    coverUrl,
    format,
    addedDate,
    spineConfidence,
    reviewNeeded,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'books';
  @override
  VerificationContext validateIntegrity(
    Insertable<Book> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('isbn')) {
      context.handle(
        _isbnMeta,
        isbn.isAcceptableOrUnknown(data['isbn']!, _isbnMeta),
      );
    } else if (isInserting) {
      context.missing(_isbnMeta);
    }
    if (data.containsKey('title')) {
      context.handle(
        _titleMeta,
        title.isAcceptableOrUnknown(data['title']!, _titleMeta),
      );
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('author')) {
      context.handle(
        _authorMeta,
        author.isAcceptableOrUnknown(data['author']!, _authorMeta),
      );
    } else if (isInserting) {
      context.missing(_authorMeta);
    }
    if (data.containsKey('cover_url')) {
      context.handle(
        _coverUrlMeta,
        coverUrl.isAcceptableOrUnknown(data['cover_url']!, _coverUrlMeta),
      );
    }
    if (data.containsKey('format')) {
      context.handle(
        _formatMeta,
        format.isAcceptableOrUnknown(data['format']!, _formatMeta),
      );
    }
    if (data.containsKey('added_date')) {
      context.handle(
        _addedDateMeta,
        addedDate.isAcceptableOrUnknown(data['added_date']!, _addedDateMeta),
      );
    } else if (isInserting) {
      context.missing(_addedDateMeta);
    }
    if (data.containsKey('spine_confidence')) {
      context.handle(
        _spineConfidenceMeta,
        spineConfidence.isAcceptableOrUnknown(
          data['spine_confidence']!,
          _spineConfidenceMeta,
        ),
      );
    }
    if (data.containsKey('review_needed')) {
      context.handle(
        _reviewNeededMeta,
        reviewNeeded.isAcceptableOrUnknown(
          data['review_needed']!,
          _reviewNeededMeta,
        ),
      );
    }
    return context;
  }
  @override
  Set<GeneratedColumn> get $primaryKey => {isbn};
  @override
  Book map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Book(
      isbn: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}isbn'],
      )!,
      title: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}title'],
      )!,
      author: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}author'],
      )!,
      coverUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}cover_url'],
      ),
      format: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}format'],
      ),
      addedDate: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}added_date'],
      )!,
      spineConfidence: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}spine_confidence'],
      ),
      reviewNeeded: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}review_needed'],
      )!,
    );
  }
  @override
  $BooksTable createAlias(String alias) {
    return $BooksTable(attachedDatabase, alias);
  }
}
class Book extends DataClass implements Insertable<Book> {
  final String isbn;
  final String title;
  final String author;
  final String? coverUrl;
  final String? format;
  final int addedDate;
  final double? spineConfidence;
  final bool reviewNeeded;
  const Book({
    required this.isbn,
    required this.title,
    required this.author,
    this.coverUrl,
    this.format,
    required this.addedDate,
    this.spineConfidence,
    required this.reviewNeeded,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['isbn'] = Variable<String>(isbn);
    map['title'] = Variable<String>(title);
    map['author'] = Variable<String>(author);
    if (!nullToAbsent || coverUrl != null) {
      map['cover_url'] = Variable<String>(coverUrl);
    }
    if (!nullToAbsent || format != null) {
      map['format'] = Variable<String>(format);
    }
    map['added_date'] = Variable<int>(addedDate);
    if (!nullToAbsent || spineConfidence != null) {
      map['spine_confidence'] = Variable<double>(spineConfidence);
    }
    map['review_needed'] = Variable<bool>(reviewNeeded);
    return map;
  }
  BooksCompanion toCompanion(bool nullToAbsent) {
    return BooksCompanion(
      isbn: Value(isbn),
      title: Value(title),
      author: Value(author),
      coverUrl: coverUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(coverUrl),
      format: format == null && nullToAbsent
          ? const Value.absent()
          : Value(format),
      addedDate: Value(addedDate),
      spineConfidence: spineConfidence == null && nullToAbsent
          ? const Value.absent()
          : Value(spineConfidence),
      reviewNeeded: Value(reviewNeeded),
    );
  }
  factory Book.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Book(
      isbn: serializer.fromJson<String>(json['isbn']),
      title: serializer.fromJson<String>(json['title']),
      author: serializer.fromJson<String>(json['author']),
      coverUrl: serializer.fromJson<String?>(json['coverUrl']),
      format: serializer.fromJson<String?>(json['format']),
      addedDate: serializer.fromJson<int>(json['addedDate']),
      spineConfidence: serializer.fromJson<double?>(json['spineConfidence']),
      reviewNeeded: serializer.fromJson<bool>(json['reviewNeeded']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'isbn': serializer.toJson<String>(isbn),
      'title': serializer.toJson<String>(title),
      'author': serializer.toJson<String>(author),
      'coverUrl': serializer.toJson<String?>(coverUrl),
      'format': serializer.toJson<String?>(format),
      'addedDate': serializer.toJson<int>(addedDate),
      'spineConfidence': serializer.toJson<double?>(spineConfidence),
      'reviewNeeded': serializer.toJson<bool>(reviewNeeded),
    };
  }
  Book copyWith({
    String? isbn,
    String? title,
    String? author,
    Value<String?> coverUrl = const Value.absent(),
    Value<String?> format = const Value.absent(),
    int? addedDate,
    Value<double?> spineConfidence = const Value.absent(),
    bool? reviewNeeded,
  }) => Book(
    isbn: isbn ?? this.isbn,
    title: title ?? this.title,
    author: author ?? this.author,
    coverUrl: coverUrl.present ? coverUrl.value : this.coverUrl,
    format: format.present ? format.value : this.format,
    addedDate: addedDate ?? this.addedDate,
    spineConfidence: spineConfidence.present
        ? spineConfidence.value
        : this.spineConfidence,
    reviewNeeded: reviewNeeded ?? this.reviewNeeded,
  );
  Book copyWithCompanion(BooksCompanion data) {
    return Book(
      isbn: data.isbn.present ? data.isbn.value : this.isbn,
      title: data.title.present ? data.title.value : this.title,
      author: data.author.present ? data.author.value : this.author,
      coverUrl: data.coverUrl.present ? data.coverUrl.value : this.coverUrl,
      format: data.format.present ? data.format.value : this.format,
      addedDate: data.addedDate.present ? data.addedDate.value : this.addedDate,
      spineConfidence: data.spineConfidence.present
          ? data.spineConfidence.value
          : this.spineConfidence,
      reviewNeeded: data.reviewNeeded.present
          ? data.reviewNeeded.value
          : this.reviewNeeded,
    );
  }
  @override
  String toString() {
    return (StringBuffer('Book(')
          ..write('isbn: $isbn, ')
          ..write('title: $title, ')
          ..write('author: $author, ')
          ..write('coverUrl: $coverUrl, ')
          ..write('format: $format, ')
          ..write('addedDate: $addedDate, ')
          ..write('spineConfidence: $spineConfidence, ')
          ..write('reviewNeeded: $reviewNeeded')
          ..write(')'))
        .toString();
  }
  @override
  int get hashCode => Object.hash(
    isbn,
    title,
    author,
    coverUrl,
    format,
    addedDate,
    spineConfidence,
    reviewNeeded,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Book &&
          other.isbn == this.isbn &&
          other.title == this.title &&
          other.author == this.author &&
          other.coverUrl == this.coverUrl &&
          other.format == this.format &&
          other.addedDate == this.addedDate &&
          other.spineConfidence == this.spineConfidence &&
          other.reviewNeeded == this.reviewNeeded);
}
class BooksCompanion extends UpdateCompanion<Book> {
  final Value<String> isbn;
  final Value<String> title;
  final Value<String> author;
  final Value<String?> coverUrl;
  final Value<String?> format;
  final Value<int> addedDate;
  final Value<double?> spineConfidence;
  final Value<bool> reviewNeeded;
  final Value<int> rowid;
  const BooksCompanion({
    this.isbn = const Value.absent(),
    this.title = const Value.absent(),
    this.author = const Value.absent(),
    this.coverUrl = const Value.absent(),
    this.format = const Value.absent(),
    this.addedDate = const Value.absent(),
    this.spineConfidence = const Value.absent(),
    this.reviewNeeded = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BooksCompanion.insert({
    required String isbn,
    required String title,
    required String author,
    this.coverUrl = const Value.absent(),
    this.format = const Value.absent(),
    required int addedDate,
    this.spineConfidence = const Value.absent(),
    this.reviewNeeded = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : isbn = Value(isbn),
       title = Value(title),
       author = Value(author),
       addedDate = Value(addedDate);
  static Insertable<Book> custom({
    Expression<String>? isbn,
    Expression<String>? title,
    Expression<String>? author,
    Expression<String>? coverUrl,
    Expression<String>? format,
    Expression<int>? addedDate,
    Expression<double>? spineConfidence,
    Expression<bool>? reviewNeeded,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (isbn != null) 'isbn': isbn,
      if (title != null) 'title': title,
      if (author != null) 'author': author,
      if (coverUrl != null) 'cover_url': coverUrl,
      if (format != null) 'format': format,
      if (addedDate != null) 'added_date': addedDate,
      if (spineConfidence != null) 'spine_confidence': spineConfidence,
      if (reviewNeeded != null) 'review_needed': reviewNeeded,
      if (rowid != null) 'rowid': rowid,
    });
  }
  BooksCompanion copyWith({
    Value<String>? isbn,
    Value<String>? title,
    Value<String>? author,
    Value<String?>? coverUrl,
    Value<String?>? format,
    Value<int>? addedDate,
    Value<double?>? spineConfidence,
    Value<bool>? reviewNeeded,
    Value<int>? rowid,
  }) {
    return BooksCompanion(
      isbn: isbn ?? this.isbn,
      title: title ?? this.title,
      author: author ?? this.author,
      coverUrl: coverUrl ?? this.coverUrl,
      format: format ?? this.format,
      addedDate: addedDate ?? this.addedDate,
      spineConfidence: spineConfidence ?? this.spineConfidence,
      reviewNeeded: reviewNeeded ?? this.reviewNeeded,
      rowid: rowid ?? this.rowid,
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (isbn.present) {
      map['isbn'] = Variable<String>(isbn.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (author.present) {
      map['author'] = Variable<String>(author.value);
    }
    if (coverUrl.present) {
      map['cover_url'] = Variable<String>(coverUrl.value);
    }
    if (format.present) {
      map['format'] = Variable<String>(format.value);
    }
    if (addedDate.present) {
      map['added_date'] = Variable<int>(addedDate.value);
    }
    if (spineConfidence.present) {
      map['spine_confidence'] = Variable<double>(spineConfidence.value);
    }
    if (reviewNeeded.present) {
      map['review_needed'] = Variable<bool>(reviewNeeded.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }
  @override
  String toString() {
    return (StringBuffer('BooksCompanion(')
          ..write('isbn: $isbn, ')
          ..write('title: $title, ')
          ..write('author: $author, ')
          ..write('coverUrl: $coverUrl, ')
          ..write('format: $format, ')
          ..write('addedDate: $addedDate, ')
          ..write('spineConfidence: $spineConfidence, ')
          ..write('reviewNeeded: $reviewNeeded, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}
class $FailedScansTable extends FailedScans
    with TableInfo<$FailedScansTable, FailedScan> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FailedScansTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _jobIdMeta = const VerificationMeta('jobId');
  @override
  late final GeneratedColumn<String> jobId = GeneratedColumn<String>(
    'job_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _imagePathMeta = const VerificationMeta(
    'imagePath',
  );
  @override
  late final GeneratedColumn<String> imagePath = GeneratedColumn<String>(
    'image_path',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _errorMessageMeta = const VerificationMeta(
    'errorMessage',
  );
  @override
  late final GeneratedColumn<String> errorMessage = GeneratedColumn<String>(
    'error_message',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _expiresAtMeta = const VerificationMeta(
    'expiresAt',
  );
  @override
  late final GeneratedColumn<int> expiresAt = GeneratedColumn<int>(
    'expires_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    jobId,
    imagePath,
    errorMessage,
    createdAt,
    expiresAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'failed_scans';
  @override
  VerificationContext validateIntegrity(
    Insertable<FailedScan> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('job_id')) {
      context.handle(
        _jobIdMeta,
        jobId.isAcceptableOrUnknown(data['job_id']!, _jobIdMeta),
      );
    } else if (isInserting) {
      context.missing(_jobIdMeta);
    }
    if (data.containsKey('image_path')) {
      context.handle(
        _imagePathMeta,
        imagePath.isAcceptableOrUnknown(data['image_path']!, _imagePathMeta),
      );
    } else if (isInserting) {
      context.missing(_imagePathMeta);
    }
    if (data.containsKey('error_message')) {
      context.handle(
        _errorMessageMeta,
        errorMessage.isAcceptableOrUnknown(
          data['error_message']!,
          _errorMessageMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_errorMessageMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('expires_at')) {
      context.handle(
        _expiresAtMeta,
        expiresAt.isAcceptableOrUnknown(data['expires_at']!, _expiresAtMeta),
      );
    } else if (isInserting) {
      context.missing(_expiresAtMeta);
    }
    return context;
  }
  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FailedScan map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FailedScan(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      jobId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}job_id'],
      )!,
      imagePath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}image_path'],
      )!,
      errorMessage: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}error_message'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      expiresAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}expires_at'],
      )!,
    );
  }
  @override
  $FailedScansTable createAlias(String alias) {
    return $FailedScansTable(attachedDatabase, alias);
  }
}
class FailedScan extends DataClass implements Insertable<FailedScan> {
  final int id;
  final String jobId;
  final String imagePath;
  final String errorMessage;
  final int createdAt;
  final int expiresAt;
  const FailedScan({
    required this.id,
    required this.jobId,
    required this.imagePath,
    required this.errorMessage,
    required this.createdAt,
    required this.expiresAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['job_id'] = Variable<String>(jobId);
    map['image_path'] = Variable<String>(imagePath);
    map['error_message'] = Variable<String>(errorMessage);
    map['created_at'] = Variable<int>(createdAt);
    map['expires_at'] = Variable<int>(expiresAt);
    return map;
  }
  FailedScansCompanion toCompanion(bool nullToAbsent) {
    return FailedScansCompanion(
      id: Value(id),
      jobId: Value(jobId),
      imagePath: Value(imagePath),
      errorMessage: Value(errorMessage),
      createdAt: Value(createdAt),
      expiresAt: Value(expiresAt),
    );
  }
  factory FailedScan.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FailedScan(
      id: serializer.fromJson<int>(json['id']),
      jobId: serializer.fromJson<String>(json['jobId']),
      imagePath: serializer.fromJson<String>(json['imagePath']),
      errorMessage: serializer.fromJson<String>(json['errorMessage']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      expiresAt: serializer.fromJson<int>(json['expiresAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'jobId': serializer.toJson<String>(jobId),
      'imagePath': serializer.toJson<String>(imagePath),
      'errorMessage': serializer.toJson<String>(errorMessage),
      'createdAt': serializer.toJson<int>(createdAt),
      'expiresAt': serializer.toJson<int>(expiresAt),
    };
  }
  FailedScan copyWith({
    int? id,
    String? jobId,
    String? imagePath,
    String? errorMessage,
    int? createdAt,
    int? expiresAt,
  }) => FailedScan(
    id: id ?? this.id,
    jobId: jobId ?? this.jobId,
    imagePath: imagePath ?? this.imagePath,
    errorMessage: errorMessage ?? this.errorMessage,
    createdAt: createdAt ?? this.createdAt,
    expiresAt: expiresAt ?? this.expiresAt,
  );
  FailedScan copyWithCompanion(FailedScansCompanion data) {
    return FailedScan(
      id: data.id.present ? data.id.value : this.id,
      jobId: data.jobId.present ? data.jobId.value : this.jobId,
      imagePath: data.imagePath.present ? data.imagePath.value : this.imagePath,
      errorMessage: data.errorMessage.present
          ? data.errorMessage.value
          : this.errorMessage,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      expiresAt: data.expiresAt.present ? data.expiresAt.value : this.expiresAt,
    );
  }
  @override
  String toString() {
    return (StringBuffer('FailedScan(')
          ..write('id: $id, ')
          ..write('jobId: $jobId, ')
          ..write('imagePath: $imagePath, ')
          ..write('errorMessage: $errorMessage, ')
          ..write('createdAt: $createdAt, ')
          ..write('expiresAt: $expiresAt')
          ..write(')'))
        .toString();
  }
  @override
  int get hashCode =>
      Object.hash(id, jobId, imagePath, errorMessage, createdAt, expiresAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FailedScan &&
          other.id == this.id &&
          other.jobId == this.jobId &&
          other.imagePath == this.imagePath &&
          other.errorMessage == this.errorMessage &&
          other.createdAt == this.createdAt &&
          other.expiresAt == this.expiresAt);
}
class FailedScansCompanion extends UpdateCompanion<FailedScan> {
  final Value<int> id;
  final Value<String> jobId;
  final Value<String> imagePath;
  final Value<String> errorMessage;
  final Value<int> createdAt;
  final Value<int> expiresAt;
  const FailedScansCompanion({
    this.id = const Value.absent(),
    this.jobId = const Value.absent(),
    this.imagePath = const Value.absent(),
    this.errorMessage = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.expiresAt = const Value.absent(),
  });
  FailedScansCompanion.insert({
    this.id = const Value.absent(),
    required String jobId,
    required String imagePath,
    required String errorMessage,
    required int createdAt,
    required int expiresAt,
  }) : jobId = Value(jobId),
       imagePath = Value(imagePath),
       errorMessage = Value(errorMessage),
       createdAt = Value(createdAt),
       expiresAt = Value(expiresAt);
  static Insertable<FailedScan> custom({
    Expression<int>? id,
    Expression<String>? jobId,
    Expression<String>? imagePath,
    Expression<String>? errorMessage,
    Expression<int>? createdAt,
    Expression<int>? expiresAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (jobId != null) 'job_id': jobId,
      if (imagePath != null) 'image_path': imagePath,
      if (errorMessage != null) 'error_message': errorMessage,
      if (createdAt != null) 'created_at': createdAt,
      if (expiresAt != null) 'expires_at': expiresAt,
    });
  }
  FailedScansCompanion copyWith({
    Value<int>? id,
    Value<String>? jobId,
    Value<String>? imagePath,
    Value<String>? errorMessage,
    Value<int>? createdAt,
    Value<int>? expiresAt,
  }) {
    return FailedScansCompanion(
      id: id ?? this.id,
      jobId: jobId ?? this.jobId,
      imagePath: imagePath ?? this.imagePath,
      errorMessage: errorMessage ?? this.errorMessage,
      createdAt: createdAt ?? this.createdAt,
      expiresAt: expiresAt ?? this.expiresAt,
    );
  }
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (jobId.present) {
      map['job_id'] = Variable<String>(jobId.value);
    }
    if (imagePath.present) {
      map['image_path'] = Variable<String>(imagePath.value);
    }
    if (errorMessage.present) {
      map['error_message'] = Variable<String>(errorMessage.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (expiresAt.present) {
      map['expires_at'] = Variable<int>(expiresAt.value);
    }
    return map;
  }
  @override
  String toString() {
    return (StringBuffer('FailedScansCompanion(')
          ..write('id: $id, ')
          ..write('jobId: $jobId, ')
          ..write('imagePath: $imagePath, ')
          ..write('errorMessage: $errorMessage, ')
          ..write('createdAt: $createdAt, ')
          ..write('expiresAt: $expiresAt')
          ..write(')'))
        .toString();
  }
}
abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $BooksTable books = $BooksTable(this);
  late final $FailedScansTable failedScans = $FailedScansTable(this);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [books, failedScans];
}
typedef $$BooksTableCreateCompanionBuilder =
    BooksCompanion Function({
      required String isbn,
      required String title,
      required String author,
      Value<String?> coverUrl,
      Value<String?> format,
      required int addedDate,
      Value<double?> spineConfidence,
      Value<bool> reviewNeeded,
      Value<int> rowid,
    });
typedef $$BooksTableUpdateCompanionBuilder =
    BooksCompanion Function({
      Value<String> isbn,
      Value<String> title,
      Value<String> author,
      Value<String?> coverUrl,
      Value<String?> format,
      Value<int> addedDate,
      Value<double?> spineConfidence,
      Value<bool> reviewNeeded,
      Value<int> rowid,
    });
class $$BooksTableFilterComposer extends Composer<_$AppDatabase, $BooksTable> {
  $$BooksTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get isbn => $composableBuilder(
    column: $table.isbn,
    builder: (column) => ColumnFilters(column),
  );
  ColumnFilters<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnFilters(column),
  );
  ColumnFilters<String> get author => $composableBuilder(
    column: $table.author,
    builder: (column) => ColumnFilters(column),
  );
  ColumnFilters<String> get coverUrl => $composableBuilder(
    column: $table.coverUrl,
    builder: (column) => ColumnFilters(column),
  );
  ColumnFilters<String> get format => $composableBuilder(
    column: $table.format,
    builder: (column) => ColumnFilters(column),
  );
  ColumnFilters<int> get addedDate => $composableBuilder(
    column: $table.addedDate,
    builder: (column) => ColumnFilters(column),
  );
  ColumnFilters<double> get spineConfidence => $composableBuilder(
    column: $table.spineConfidence,
    builder: (column) => ColumnFilters(column),
  );
  ColumnFilters<bool> get reviewNeeded => $composableBuilder(
    column: $table.reviewNeeded,
    builder: (column) => ColumnFilters(column),
  );
}
class $$BooksTableOrderingComposer
    extends Composer<_$AppDatabase, $BooksTable> {
  $$BooksTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get isbn => $composableBuilder(
    column: $table.isbn,
    builder: (column) => ColumnOrderings(column),
  );
  ColumnOrderings<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnOrderings(column),
  );
  ColumnOrderings<String> get author => $composableBuilder(
    column: $table.author,
    builder: (column) => ColumnOrderings(column),
  );
  ColumnOrderings<String> get coverUrl => $composableBuilder(
    column: $table.coverUrl,
    builder: (column) => ColumnOrderings(column),
  );
  ColumnOrderings<String> get format => $composableBuilder(
    column: $table.format,
    builder: (column) => ColumnOrderings(column),
  );
  ColumnOrderings<int> get addedDate => $composableBuilder(
    column: $table.addedDate,
    builder: (column) => ColumnOrderings(column),
  );
  ColumnOrderings<double> get spineConfidence => $composableBuilder(
    column: $table.spineConfidence,
    builder: (column) => ColumnOrderings(column),
  );
  ColumnOrderings<bool> get reviewNeeded => $composableBuilder(
    column: $table.reviewNeeded,
    builder: (column) => ColumnOrderings(column),
  );
}
class $$BooksTableAnnotationComposer
    extends Composer<_$AppDatabase, $BooksTable> {
  $$BooksTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get isbn =>
      $composableBuilder(column: $table.isbn, builder: (column) => column);
  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);
  GeneratedColumn<String> get author =>
      $composableBuilder(column: $table.author, builder: (column) => column);
  GeneratedColumn<String> get coverUrl =>
      $composableBuilder(column: $table.coverUrl, builder: (column) => column);
  GeneratedColumn<String> get format =>
      $composableBuilder(column: $table.format, builder: (column) => column);
  GeneratedColumn<int> get addedDate =>
      $composableBuilder(column: $table.addedDate, builder: (column) => column);
  GeneratedColumn<double> get spineConfidence => $composableBuilder(
    column: $table.spineConfidence,
    builder: (column) => column,
  );
  GeneratedColumn<bool> get reviewNeeded => $composableBuilder(
    column: $table.reviewNeeded,
    builder: (column) => column,
  );
}
class $$BooksTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BooksTable,
          Book,
          $$BooksTableFilterComposer,
          $$BooksTableOrderingComposer,
          $$BooksTableAnnotationComposer,
          $$BooksTableCreateCompanionBuilder,
          $$BooksTableUpdateCompanionBuilder,
          (Book, BaseReferences<_$AppDatabase, $BooksTable, Book>),
          Book,
          PrefetchHooks Function()
        > {
  $$BooksTableTableManager(_$AppDatabase db, $BooksTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BooksTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BooksTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BooksTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> isbn = const Value.absent(),
                Value<String> title = const Value.absent(),
                Value<String> author = const Value.absent(),
                Value<String?> coverUrl = const Value.absent(),
                Value<String?> format = const Value.absent(),
                Value<int> addedDate = const Value.absent(),
                Value<double?> spineConfidence = const Value.absent(),
                Value<bool> reviewNeeded = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BooksCompanion(
                isbn: isbn,
                title: title,
                author: author,
                coverUrl: coverUrl,
                format: format,
                addedDate: addedDate,
                spineConfidence: spineConfidence,
                reviewNeeded: reviewNeeded,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String isbn,
                required String title,
                required String author,
                Value<String?> coverUrl = const Value.absent(),
                Value<String?> format = const Value.absent(),
                required int addedDate,
                Value<double?> spineConfidence = const Value.absent(),
                Value<bool> reviewNeeded = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BooksCompanion.insert(
                isbn: isbn,
                title: title,
                author: author,
                coverUrl: coverUrl,
                format: format,
                addedDate: addedDate,
                spineConfidence: spineConfidence,
                reviewNeeded: reviewNeeded,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}
typedef $$BooksTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BooksTable,
      Book,
      $$BooksTableFilterComposer,
      $$BooksTableOrderingComposer,
      $$BooksTableAnnotationComposer,
      $$BooksTableCreateCompanionBuilder,
      $$BooksTableUpdateCompanionBuilder,
      (Book, BaseReferences<_$AppDatabase, $BooksTable, Book>),
      Book,
      PrefetchHooks Function()
    >;
typedef $$FailedScansTableCreateCompanionBuilder =
    FailedScansCompanion Function({
      Value<int> id,
      required String jobId,
      required String imagePath,
      required String errorMessage,
      required int createdAt,
      required int expiresAt,
    });
typedef $$FailedScansTableUpdateCompanionBuilder =
    FailedScansCompanion Function({
      Value<int> id,
      Value<String> jobId,
      Value<String> imagePath,
      Value<String> errorMessage,
      Value<int> createdAt,
      Value<int> expiresAt,
    });
class $$FailedScansTableFilterComposer
    extends Composer<_$AppDatabase, $FailedScansTable> {
  $$FailedScansTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );
  ColumnFilters<String> get jobId => $composableBuilder(
    column: $table.jobId,
    builder: (column) => ColumnFilters(column),
  );
  ColumnFilters<String> get imagePath => $composableBuilder(
    column: $table.imagePath,
    builder: (column) => ColumnFilters(column),
  );
  ColumnFilters<String> get errorMessage => $composableBuilder(
    column: $table.errorMessage,
    builder: (column) => ColumnFilters(column),
  );
  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );
  ColumnFilters<int> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnFilters(column),
  );
}
class $$FailedScansTableOrderingComposer
    extends Composer<_$AppDatabase, $FailedScansTable> {
  $$FailedScansTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );
  ColumnOrderings<String> get jobId => $composableBuilder(
    column: $table.jobId,
    builder: (column) => ColumnOrderings(column),
  );
  ColumnOrderings<String> get imagePath => $composableBuilder(
    column: $table.imagePath,
    builder: (column) => ColumnOrderings(column),
  );
  ColumnOrderings<String> get errorMessage => $composableBuilder(
    column: $table.errorMessage,
    builder: (column) => ColumnOrderings(column),
  );
  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
  ColumnOrderings<int> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnOrderings(column),
  );
}
class $$FailedScansTableAnnotationComposer
    extends Composer<_$AppDatabase, $FailedScansTable> {
  $$FailedScansTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);
  GeneratedColumn<String> get jobId =>
      $composableBuilder(column: $table.jobId, builder: (column) => column);
  GeneratedColumn<String> get imagePath =>
      $composableBuilder(column: $table.imagePath, builder: (column) => column);
  GeneratedColumn<String> get errorMessage => $composableBuilder(
    column: $table.errorMessage,
    builder: (column) => column,
  );
  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);
  GeneratedColumn<int> get expiresAt =>
      $composableBuilder(column: $table.expiresAt, builder: (column) => column);
}
class $$FailedScansTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FailedScansTable,
          FailedScan,
          $$FailedScansTableFilterComposer,
          $$FailedScansTableOrderingComposer,
          $$FailedScansTableAnnotationComposer,
          $$FailedScansTableCreateCompanionBuilder,
          $$FailedScansTableUpdateCompanionBuilder,
          (
            FailedScan,
            BaseReferences<_$AppDatabase, $FailedScansTable, FailedScan>,
          ),
          FailedScan,
          PrefetchHooks Function()
        > {
  $$FailedScansTableTableManager(_$AppDatabase db, $FailedScansTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FailedScansTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FailedScansTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FailedScansTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> jobId = const Value.absent(),
                Value<String> imagePath = const Value.absent(),
                Value<String> errorMessage = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> expiresAt = const Value.absent(),
              }) => FailedScansCompanion(
                id: id,
                jobId: jobId,
                imagePath: imagePath,
                errorMessage: errorMessage,
                createdAt: createdAt,
                expiresAt: expiresAt,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String jobId,
                required String imagePath,
                required String errorMessage,
                required int createdAt,
                required int expiresAt,
              }) => FailedScansCompanion.insert(
                id: id,
                jobId: jobId,
                imagePath: imagePath,
                errorMessage: errorMessage,
                createdAt: createdAt,
                expiresAt: expiresAt,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}
typedef $$FailedScansTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FailedScansTable,
      FailedScan,
      $$FailedScansTableFilterComposer,
      $$FailedScansTableOrderingComposer,
      $$FailedScansTableAnnotationComposer,
      $$FailedScansTableCreateCompanionBuilder,
      $$FailedScansTableUpdateCompanionBuilder,
      (
        FailedScan,
        BaseReferences<_$AppDatabase, $FailedScansTable, FailedScan>,
      ),
      FailedScan,
      PrefetchHooks Function()
    >;
class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$BooksTableTableManager get books =>
      $$BooksTableTableManager(_db, _db.books);
  $$FailedScansTableTableManager get failedScans =>
      $$FailedScansTableTableManager(_db, _db.failedScans);
}
</file>

<file path="lib/data/failed_scans_repository.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wingtip/core/failed_scans_directory.dart';
import 'database.dart';
import 'database_provider.dart';
class FailedScansRepository {
  final AppDatabase _database;
  FailedScansRepository(this._database);
  Future<void> saveFailedScan({
    required String jobId,
    required String imagePath,
    required String errorMessage,
    Duration retentionPeriod = const Duration(days: 7),
  }) async {
    await _database.saveFailedScan(
      jobId: jobId,
      imagePath: imagePath,
      errorMessage: errorMessage,
      retentionPeriod: retentionPeriod,
    );
  }
  Stream<List<FailedScan>> getAllFailedScans() {
    return _database.select(_database.failedScans).watch();
  }
  Future<void> deleteFailedScan(int id) async {
    final scan = await (_database.select(_database.failedScans)
          ..where((t) => t.id.equals(id)))
        .getSingleOrNull();
    if (scan != null) {
      await FailedScansDirectory.deleteImage(scan.jobId);
      await (_database.delete(_database.failedScans)
            ..where((t) => t.id.equals(id)))
          .go();
    }
  }
  Future<FailedScan?> retryFailedScan(int id) async {
    final scan = await (_database.select(_database.failedScans)
          ..where((t) => t.id.equals(id)))
        .getSingleOrNull();
    return scan;
  }
}
final failedScansRepositoryProvider = Provider<FailedScansRepository>((ref) {
  final database = ref.watch(databaseProvider);
  return FailedScansRepository(database);
});
final watchFailedScansProvider = StreamProvider<List<FailedScan>>((ref) {
  final repository = ref.watch(failedScansRepositoryProvider);
  return repository.getAllFailedScans();
});
</file>

<file path="lib/features/library/book_detail_bottom_sheet.dart">
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:google_fonts/google_fonts.dart';
import '../../data/database.dart';
class BookDetailBottomSheet extends StatefulWidget {
  final Book book;
  const BookDetailBottomSheet({
    super.key,
    required this.book,
  });
  @override
  State<BookDetailBottomSheet> createState() => _BookDetailBottomSheetState();
  static Future<void> show(BuildContext context, Book book) {
    return showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => BookDetailBottomSheet(book: book),
    );
  }
}
class _BookDetailBottomSheetState extends State<BookDetailBottomSheet> {
  bool _showJsonView = false;
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return DraggableScrollableSheet(
      initialChildSize: 0.6,
      minChildSize: 0.4,
      maxChildSize: 0.95,
      expand: false,
      builder: (context, scrollController) {
        return Container(
          decoration: BoxDecoration(
            color: theme.scaffoldBackgroundColor,
            border: Border(
              top: BorderSide(
                color: theme.dividerColor,
                width: 1,
              ),
            ),
            borderRadius: const BorderRadius.vertical(
              top: Radius.circular(12),
            ),
          ),
          child: Column(
            children: [
              Column(
                children: [
                  Container(
                    margin: const EdgeInsets.only(top: 12, bottom: 8),
                    width: 36,
                    height: 4,
                    decoration: BoxDecoration(
                      color: theme.dividerColor,
                      borderRadius: BorderRadius.circular(2),
                    ),
                  ),
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 8),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text(
                          'Visual',
                          style: theme.textTheme.bodyMedium?.copyWith(
                            color: !_showJsonView
                                ? theme.colorScheme.primary
                                : theme.colorScheme.onSurface.withValues(alpha: 0.6),
                            fontWeight: !_showJsonView ? FontWeight.bold : FontWeight.normal,
                          ),
                        ),
                        const SizedBox(width: 12),
                        Switch(
                          value: _showJsonView,
                          onChanged: (value) {
                            setState(() {
                              _showJsonView = value;
                            });
                          },
                        ),
                        const SizedBox(width: 12),
                        Text(
                          'JSON',
                          style: theme.textTheme.bodyMedium?.copyWith(
                            color: _showJsonView
                                ? theme.colorScheme.primary
                                : theme.colorScheme.onSurface.withValues(alpha: 0.6),
                            fontWeight: _showJsonView ? FontWeight.bold : FontWeight.normal,
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
              Expanded(
                child: SingleChildScrollView(
                  controller: scrollController,
                  padding: const EdgeInsets.all(24),
                  child: _showJsonView
                      ? _buildJsonView(context)
                      : _buildVisualView(context),
                ),
              ),
            ],
          ),
        );
      },
    );
  }
  Widget _buildVisualView(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildCoverImage(context),
            const SizedBox(width: 24),
            Expanded(
              child: _buildMetadataSection(context),
            ),
          ],
        ),
        const SizedBox(height: 24),
        SizedBox(
          width: double.infinity,
          child: ElevatedButton(
            onPressed: () {
            },
            child: const Text('Edit'),
          ),
        ),
      ],
    );
  }
  Widget _buildJsonView(BuildContext context) {
    final jsonString = const JsonEncoder.withIndent('  ').convert(widget.book.toJson());
    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        Container(
          decoration: BoxDecoration(
            color: Colors.black,
            borderRadius: BorderRadius.circular(8),
            border: Border.all(
              color: const Color(0xFF00FF00).withValues(alpha: 0.3),
              width: 1,
            ),
          ),
          padding: const EdgeInsets.all(16),
          child: SelectableText(
            jsonString,
            style: GoogleFonts.jetBrainsMono(
              fontSize: 13,
              color: const Color(0xFF00FF00),
              height: 1.5,
            ),
          ),
        ),
        const SizedBox(height: 16),
        SizedBox(
          width: double.infinity,
          child: ElevatedButton.icon(
            onPressed: () {
              Clipboard.setData(ClipboardData(text: jsonString));
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(
                  content: Text('JSON copied to clipboard'),
                  duration: Duration(seconds: 2),
                ),
              );
            },
            icon: const Icon(Icons.copy),
            label: const Text('Copy JSON'),
          ),
        ),
      ],
    );
  }
  Widget _buildCoverImage(BuildContext context) {
    const imageWidth = 120.0;
    const imageHeight = 180.0;
    if (widget.book.coverUrl != null && widget.book.coverUrl!.isNotEmpty) {
      return ClipRRect(
        borderRadius: BorderRadius.circular(4),
        child: Container(
          width: imageWidth,
          height: imageHeight,
          decoration: BoxDecoration(
            border: Border.all(
              color: Colors.white,
              width: 1,
            ),
            borderRadius: BorderRadius.circular(4),
          ),
          child: CachedNetworkImage(
            imageUrl: widget.book.coverUrl!,
            fit: BoxFit.cover,
            placeholder: (context, url) => Container(
              color: Colors.grey[900],
              child: const Center(
                child: CircularProgressIndicator(),
              ),
            ),
            errorWidget: (context, url, error) => _buildFallbackCover(context),
          ),
        ),
      );
    }
    return _buildFallbackCover(context);
  }
  Widget _buildFallbackCover(BuildContext context) {
    const imageWidth = 120.0;
    const imageHeight = 180.0;
    return Container(
      width: imageWidth,
      height: imageHeight,
      decoration: BoxDecoration(
        border: Border.all(
          color: Colors.white,
          width: 1,
        ),
        borderRadius: BorderRadius.circular(4),
      ),
      padding: const EdgeInsets.all(8),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Text(
            widget.book.title,
            style: GoogleFonts.jetBrainsMono(
              fontSize: 12,
              fontWeight: FontWeight.bold,
              color: Colors.white,
            ),
            textAlign: TextAlign.center,
            maxLines: 3,
            overflow: TextOverflow.ellipsis,
          ),
          const SizedBox(height: 4),
          Text(
            widget.book.author,
            style: GoogleFonts.jetBrainsMono(
              fontSize: 10,
              color: Colors.white70,
            ),
            textAlign: TextAlign.center,
            maxLines: 2,
            overflow: TextOverflow.ellipsis,
          ),
        ],
      ),
    );
  }
  Widget _buildMetadataSection(BuildContext context) {
    final theme = Theme.of(context);
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildMetadataField(
          context,
          label: 'ISBN',
          value: widget.book.isbn,
          valueStyle: GoogleFonts.jetBrainsMono(
            fontSize: 14,
            color: theme.colorScheme.onSurface,
          ),
        ),
        const SizedBox(height: 16),
        _buildMetadataField(
          context,
          label: 'Title',
          value: widget.book.title,
          valueStyle: theme.textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 16),
        _buildMetadataField(
          context,
          label: 'Author',
          value: widget.book.author,
          valueStyle: theme.textTheme.bodyLarge,
        ),
        const SizedBox(height: 16),
        _buildMetadataField(
          context,
          label: 'Format',
          value: widget.book.format ?? 'Unknown',
          valueStyle: theme.textTheme.bodyLarge,
        ),
      ],
    );
  }
  Widget _buildMetadataField(
    BuildContext context, {
    required String label,
    required String value,
    TextStyle? valueStyle,
  }) {
    final theme = Theme.of(context);
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: theme.textTheme.labelSmall?.copyWith(
            color: theme.colorScheme.onSurface.withValues(alpha: 0.6),
          ),
        ),
        const SizedBox(height: 4),
        Text(
          value,
          style: valueStyle ?? theme.textTheme.bodyMedium,
        ),
      ],
    );
  }
}
</file>

<file path="tasks/prd.json">
{
  "name": "Project Wingtip",
  "description": "A local-first, offline-capable library manager that uses the camera to scan book spines and enriches them via the Talaria backend",
  "branchName": "ralph/wingtip-mvp",
  "userStories": [
    {
      "id": "US-101",
      "title": "Initialize Flutter Project with Riverpod & Drift",
      "description": "As a developer, I want to scaffold the app with the latest Flutter stack so that I have a stable foundation for state and data.",
      "acceptanceCriteria": [
        "Project created with com.ooheynerds.wingtip package name",
        "flutter_riverpod (v3) installed and ProviderScope configured in main.dart",
        "drift (v2) installed with sqlite3_flutter_libs for native performance",
        "Folder structure created: features/, core/, data/",
        "flutter analyze shows no errors",
        "flutter test runs successfully (even if no tests yet)"
      ],
      "priority": 1,
      "passes": true,
      "notes": "",
      "dependsOn": [],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-102",
      "title": "Implement Swiss Utility Theme System",
      "description": "As a user, I want to experience a high-contrast, clean interface so that the app feels precise and professional.",
      "acceptanceCriteria": [
        "Theme mode locked to Dark with OLED black (#000000) background",
        "JetBrains Mono font configured for numbers/IDs, Inter for body text",
        "ThemeData uses 1px solid borders instead of shadows (elevation set to 0)",
        "Accent color defined as #FF3B30 (International Orange)",
        "flutter analyze shows no errors",
        "flutter test runs successfully"
      ],
      "priority": 2,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-101"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-103",
      "title": "Generate & Store Persistent Device ID",
      "description": "As a system, I want to generate a UUID v4 on first launch so that I can authenticate with the Talaria backend.",
      "acceptanceCriteria": [
        "On first run, generate uuid.v4() using uuid package",
        "Store securely in FlutterSecureStorage with key 'device_id'",
        "Create DeviceIdProvider that reads from secure storage",
        "Add debug setting UI to regenerate device ID",
        "flutter analyze shows no errors",
        "flutter test runs successfully with unit tests for device ID generation"
      ],
      "priority": 3,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-101"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-116",
      "title": "Drift Database Schema",
      "description": "As a developer, I want to define the Books table so that I can store metadata efficiently.",
      "acceptanceCriteria": [
        "Create Books table with columns: isbn (TEXT PRIMARY KEY), title (TEXT), author (TEXT), coverUrl (TEXT NULLABLE), format (TEXT NULLABLE), addedDate (INTEGER), spineConfidence (REAL NULLABLE)",
        "Create index on addedDate descending for default sort",
        "Run drift build_runner to generate database code",
        "Create FailedScans table with: id, jobId, imagePath, errorMessage, createdAt, expiresAt",
        "flutter analyze shows no errors",
        "flutter test runs successfully with database tests"
      ],
      "priority": 4,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-101"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-104",
      "title": "Offline-First Network Client",
      "description": "As a system, I want to queue requests when offline so that I don't lose scans if the network drops.",
      "acceptanceCriteria": [
        "Configure Dio with connection retry interceptor (3 retries with exponential backoff)",
        "Add connectivity_plus package and implement network status detection",
        "Create NetworkStatusProvider using Riverpod",
        "Show 'OFFLINE' tag in top-right corner when disconnected (Swiss style: small text, 1px white border)",
        "flutter analyze shows no errors",
        "flutter test runs successfully with network client tests"
      ],
      "priority": 5,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-103"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-105",
      "title": "Instant Camera Initialization",
      "description": "As a user, I want to see the camera immediately upon opening the app so that I can capture a book spine instantly.",
      "acceptanceCriteria": [
        "App launches directly to CameraScreen widget",
        "Camera initializes in background during splash",
        "Cold start to live camera feed measures < 1.0s (add performance logging)",
        "System status bar hidden for full immersion",
        "flutter analyze shows no errors",
        "Manual verification: Cold start performance < 1.0s"
      ],
      "priority": 6,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-101",
        "US-102"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-106",
      "title": "Non-Blocking Shutter Action",
      "description": "As a user, I want to tap the shutter button repeatedly without waiting so that I can scan a whole shelf in seconds.",
      "acceptanceCriteria": [
        "Shutter button renders as large white ring at bottom center (80x80px)",
        "On tap: HapticFeedback.lightImpact() triggers immediately",
        "On tap: Full-screen white flash overlay (100ms duration, opacity animation)",
        "Shutter button remains enabled during processing (no loading spinner on button)",
        "flutter analyze shows no errors",
        "Manual verification: Rapid tapping works without blocking"
      ],
      "priority": 7,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-105"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-107",
      "title": "Background Image Processing",
      "description": "As a system, I want to compress and resize images in a background Isolate so that the UI thread never janks.",
      "acceptanceCriteria": [
        "Use compute() to spawn isolate for image manipulation",
        "Resize image to max 1920px on longest dimension",
        "Compress to JPEG quality 85",
        "Save temporary file to platform temp directory",
        "Add performance logging to verify processing time < 500ms",
        "flutter analyze shows no errors",
        "flutter test runs successfully with image processing tests"
      ],
      "priority": 8,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-106"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-110",
      "title": "Upload Image to Talaria",
      "description": "As a system, I want to POST the image to /v3/jobs/scans so that I can start the analysis pipeline.",
      "acceptanceCriteria": [
        "Create TalariaClient with Dio for multipart upload",
        "POST processed JPEG to /v3/jobs/scans endpoint",
        "Handle 202 Accepted response correctly",
        "Parse jobId and streamUrl from JSON response",
        "Update UI state to 'Listening' via Riverpod provider",
        "flutter analyze shows no errors",
        "flutter test runs successfully with HTTP client mocking tests"
      ],
      "priority": 9,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-107",
        "US-103"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-111",
      "title": "SSE Stream Listener",
      "description": "As a system, I want to listen to Server-Sent Events for a specific Job ID so that I receive real-time updates.",
      "acceptanceCriteria": [
        "Open SSE connection to streamUrl using fetch_client or http package",
        "Maintain connection until 'complete' event or 5-minute timeout",
        "Parse incoming JSON chunks for events: progress, result, complete, error",
        "Handle connection errors with exponential backoff retry (max 3 retries)",
        "Close connection properly on complete or error",
        "flutter analyze shows no errors",
        "flutter test runs successfully with SSE stream tests"
      ],
      "priority": 10,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-110"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-113",
      "title": "Handle Result Events - Data Upsert",
      "description": "As a system, I want to save incoming book data immediately so that the user sees results before the job finishes.",
      "acceptanceCriteria": [
        "Listen for 'event: result' from SSE stream",
        "Map JSON payload to Drift Book entity",
        "Execute INSERT OR REPLACE into books table (deduplicate by ISBN)",
        "Trigger HapticFeedback.mediumImpact() on successful save",
        "Prefetch cover image URL to cached_network_image cache",
        "flutter analyze shows no errors",
        "flutter test runs successfully with data upsert tests"
      ],
      "priority": 11,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-111",
        "US-116"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-114",
      "title": "Handle Complete & Cleanup",
      "description": "As a system, I want to clean up resources when a job finishes so that I don't waste storage or battery.",
      "acceptanceCriteria": [
        "Listen for 'event: complete' from SSE stream",
        "Send DELETE request to /v3/jobs/scans/{jobId}/cleanup",
        "Delete local temporary JPEG file from temp directory",
        "Close SSE connection cleanly",
        "Update job state to 'completed' in UI",
        "flutter analyze shows no errors",
        "flutter test runs successfully with cleanup tests"
      ],
      "priority": 12,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-111"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-117",
      "title": "Library Grid View",
      "description": "As a user, I want to see my books in a clean grid so that I can browse my collection.",
      "acceptanceCriteria": [
        "Create 3-column GridView of book covers using GridView.builder",
        "Set aspect ratio to 1:1.5 for standard book proportions",
        "Show grey fallback card with Title/Author in JetBrains Mono if no coverUrl",
        "Implement infinite scroll with lazy loading from Drift database",
        "Add 1px white borders to each card (Swiss style)",
        "flutter analyze shows no errors",
        "Manual verification: Grid displays correctly with and without cover images"
      ],
      "priority": 13,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-116",
        "US-102"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-108",
      "title": "The Processing Stack UI",
      "description": "As a user, I want to see my active uploads as a queue so that I know the system is working.",
      "acceptanceCriteria": [
        "Create horizontal ListView above shutter button for active jobs",
        "Each job renders as 40x60px thumbnail of captured image",
        "Apply colored borders: Yellow (Uploading), Blue (Analyzing), Green (Done)",
        "Auto-remove job card after 5 seconds in 'Done' state with fade animation",
        "Show job count badge when queue has items",
        "flutter analyze shows no errors",
        "Manual verification: Queue UI updates correctly during scan workflow"
      ],
      "priority": 14,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-107"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-109",
      "title": "Manual Focus & Zoom",
      "description": "As a user, I want to pinch to zoom and tap to focus so that I can capture small text on spines.",
      "acceptanceCriteria": [
        "Implement pinch gesture detector for camera zoom (1x - 4x range)",
        "Implement tap gesture detector to set camera focus point",
        "Show square bracket cursor [ ] at tap location for 1 second (Swiss style)",
        "Zoom level indicator shows current zoom (e.g., '2.5x') in top corner",
        "flutter analyze shows no errors",
        "Manual verification: Pinch zoom and tap focus work smoothly"
      ],
      "priority": 15,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-105"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-112",
      "title": "Visualize Progress Events",
      "description": "As a user, I want to see text updates as the AI thinks so that I feel the speed of the system.",
      "acceptanceCriteria": [
        "Listen for 'event: progress' from SSE stream",
        "Overlay transparent text on job thumbnail in processing queue",
        "Display stage messages: 'Looking...', 'Reading...', 'Enriching...'",
        "Use JetBrains Mono font for status text",
        "Animate text fade in/out transitions (200ms)",
        "flutter analyze shows no errors",
        "Manual verification: Progress text updates appear during scan"
      ],
      "priority": 16,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-111",
        "US-108"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-115",
      "title": "Handle Global Rate Limits",
      "description": "As a user, I want to know if I've hit the daily limit so that I don't waste time snapping photos.",
      "acceptanceCriteria": [
        "Intercept HTTP 429 Too Many Requests response",
        "Parse retryAfterMs from response headers or body",
        "Disable shutter button when rate limited",
        "Show countdown timer overlay: 'LIMIT REACHED. RESETS IN HH:MM:SS'",
        "Re-enable shutter when countdown expires",
        "flutter analyze shows no errors",
        "flutter test runs successfully with rate limit handling tests"
      ],
      "priority": 17,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-110"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-118",
      "title": "Real-time List Updates",
      "description": "As a user, I want to see new books pop in automatically so that I don't have to pull-to-refresh.",
      "acceptanceCriteria": [
        "Use Drift's watch() method to create stream of book updates",
        "Connect stream to Riverpod StreamProvider",
        "Library grid listens to provider and rebuilds automatically",
        "Animate new items with fade in + slide up (200ms duration)",
        "flutter analyze shows no errors",
        "Manual verification: New books appear automatically after scan"
      ],
      "priority": 18,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-117"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-119",
      "title": "Full-Text Search (FTS5)",
      "description": "As a user, I want to search my library instantly so that I can find a specific book.",
      "acceptanceCriteria": [
        "Enable FTS5 module in Drift database configuration",
        "Create FTS5 virtual table for books (title, author, isbn)",
        "Add search TextField at top of Library view",
        "Implement search query that filters on title, author, and isbn",
        "Results update as user types with < 100ms latency",
        "flutter analyze shows no errors",
        "flutter test runs successfully with FTS5 search tests"
      ],
      "priority": 19,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-116",
        "US-117"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-122",
      "title": "Minimal Book Detail View",
      "description": "As a user, I want to tap a book to see its data so that I can verify the scan.",
      "acceptanceCriteria": [
        "Create modal bottom sheet that opens on book card tap",
        "Bottom sheet draggable to full screen",
        "Layout: Large cover image on left, metadata fields on right (passport style)",
        "Display fields: ISBN (JetBrains Mono), Title (bold), Author, Format",
        "Add Edit button to allow manual field correction",
        "flutter analyze shows no errors",
        "Manual verification: Bottom sheet UI matches Swiss Utility design"
      ],
      "priority": 20,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-117",
        "US-102"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-125",
      "title": "Haptic Feedback Strategy",
      "description": "As a user, I want to feel the app working so that I don't have to look at the screen constantly.",
      "acceptanceCriteria": [
        "Shutter tap: HapticFeedback.lightImpact()",
        "Scan success (result event): HapticFeedback.mediumImpact()",
        "Error or retry needed: HapticFeedback.heavyImpact()",
        "Verify haptics work on both iOS and Android",
        "flutter analyze shows no errors",
        "Manual verification: Haptic patterns are distinct and appropriate"
      ],
      "priority": 21,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-106",
        "US-113"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-128",
      "title": "Permission Priming",
      "description": "As a user, I want to understand why you need camera access so that I trust the app.",
      "acceptanceCriteria": [
        "Before requesting camera permission, show full-screen primer slide",
        "Display text: 'Wingtip needs your camera to see books. Images are processed and deleted instantly.'",
        "Add 'Grant Access' button that triggers OS permission prompt",
        "Handle permission denied state gracefully",
        "flutter analyze shows no errors",
        "Manual verification: Permission flow works on both iOS and Android"
      ],
      "priority": 22,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-105"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-130",
      "title": "Error Toasts (Snackbars)",
      "description": "As a user, I want to see errors without them blocking me so that I can keep scanning.",
      "acceptanceCriteria": [
        "Create custom SnackBar widget matching Swiss Utility design",
        "Black background, white text, #FF3B30 red left border (4px width)",
        "Display at bottom of screen, floating above content",
        "Dismiss on tap or after 4 seconds",
        "flutter analyze shows no errors",
        "Manual verification: Error snackbar matches design spec"
      ],
      "priority": 23,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-102"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-120",
      "title": "Review Needed Indicator",
      "description": "As a user, I want to see which books had low confidence so that I can manually check them.",
      "acceptanceCriteria": [
        "Check for 'review_needed' flag in book data from backend",
        "Overlay small yellow triangle warning icon on book cover (top-right corner)",
        "Add 'Needs Review' filter option in library",
        "Implement 'Needs Review First' sort option",
        "flutter analyze shows no errors",
        "Manual verification: Review indicator displays correctly"
      ],
      "priority": 24,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-117",
        "US-113"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-121",
      "title": "Export Data to CSV",
      "description": "As a user, I want to export my library so that I own my data.",
      "acceptanceCriteria": [
        "Add 'Export Library' button in settings screen",
        "Generate CSV with headers: ISBN, Title, Author, Format, Added Date, Cover URL",
        "Filename format: wingtip_library_YYYY-MM-DD.csv",
        "Open system share sheet for file sharing (Files, AirDrop, etc.)",
        "flutter analyze shows no errors",
        "Manual verification: CSV export contains all book data correctly formatted"
      ],
      "priority": 25,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-116"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-124",
      "title": "Swipe to Delete",
      "description": "As a user, I want to remove bad scans easily so that my library stays clean.",
      "acceptanceCriteria": [
        "Long-press on book card enters 'Select Mode' with checkboxes",
        "Allow multi-select of books in Select Mode",
        "Show trash icon in app bar when items selected",
        "Display confirmation dialog: 'Delete X books?' before deletion",
        "Execute batch delete from database on confirmation",
        "flutter analyze shows no errors",
        "Manual verification: Multi-select and delete flow works smoothly"
      ],
      "priority": 26,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-117"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-126",
      "title": "Cache Manager",
      "description": "As a user, I want to clear cached cover images so that the app doesn't eat up my storage.",
      "acceptanceCriteria": [
        "Add 'Clear Image Cache' option in settings screen",
        "Use DefaultCacheManager.emptyCache() to clear cached_network_image cache",
        "Display current cache size in settings (e.g., 'Cache: 124 MB')",
        "Show confirmation toast after cache cleared",
        "flutter analyze shows no errors",
        "Manual verification: Cache size updates and images re-download after clear"
      ],
      "priority": 27,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-117"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-127",
      "title": "App Icon & Splash Screen",
      "description": "As a user, I want to recognize the app on my home screen so that I can launch it quickly.",
      "acceptanceCriteria": [
        "Design and implement app icon: Abstract white wing glyph on black background",
        "Create adaptive icons for iOS and Android",
        "Implement splash screen: Black background with white 'Wingtip' text in JetBrains Mono",
        "Splash fades out after 500ms or when camera initializes",
        "flutter analyze shows no errors",
        "Manual verification: Icon and splash screen display correctly on both platforms"
      ],
      "priority": 28,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-102"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-129",
      "title": "Empty States",
      "description": "As a user, I want to see helpful text when my library is empty so that I know what to do.",
      "acceptanceCriteria": [
        "Show empty state in Library when no books exist",
        "Display text: '0 Books. Tap [O] to scan.'",
        "Include simple vector outline of bookshelf (SVG asset)",
        "Empty state uses Swiss Utility styling (white on black, 1px borders)",
        "flutter analyze shows no errors",
        "Manual verification: Empty state displays on fresh install"
      ],
      "priority": 29,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-117"
      ],
      "completionNotes": "Completed by agent"
    },
    {
      "id": "US-123",
      "title": "The Raw Data Toggle",
      "description": "As a user, I want to see the raw JSON for a book so that I can geek out on the metadata.",
      "acceptanceCriteria": [
        "Add toggle switch in Book Detail View: 'Visual' vs 'JSON'",
        "JSON view displays formatted code block using syntax highlighting",
        "Use JetBrains Mono font in green (#00FF00) for JSON",
        "Make JSON text selectable/copyable",
        "flutter analyze shows no errors",
        "Manual verification: JSON toggle works and displays valid JSON"
      ],
      "priority": 30,
      "passes": true,
      "notes": "",
      "dependsOn": [
        "US-122"
      ],
      "completionNotes": "Completed by agent"
    }
  ],
  "metadata": {
    "updatedAt": "2026-01-19T02:26:01.823Z"
  }
}
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Wingtip is a local-first, offline-capable library manager Flutter app that uses the camera to scan book spines. It connects to the Talaria backend for AI-powered book identification and enrichment, but stores all data locally in SQLite. The app follows a "Swiss Utility" design philosophy: high-contrast, clean, zero-elevation interfaces with OLED black backgrounds and 1px borders instead of shadows.

**Platform Priority: iOS-first.** All development decisions, performance targets, and UX patterns should prioritize iOS. Android and web are secondary targets.

## Core Commands

### Build & Development
```bash
# Install dependencies
flutter pub get

# Run code generation for Drift database
flutter pub run build_runner build --delete-conflicting-outputs

# Run the app (defaults to connected device)
flutter run

# Run on iOS simulator
flutter run -d iPhone

# Run on specific device
flutter run -d <device-id>

# Build for iOS (primary target)
flutter build ios --release

# Build for Android (secondary)
flutter build apk
```

### Testing & Analysis
```bash
# Run all tests
flutter test

# Run specific test file
flutter test test/path/to/test_file.dart

# Run tests with coverage
flutter test --coverage

# Static analysis
flutter analyze
```

### Asset & Icon Generation
```bash
# Generate app icons
flutter pub run flutter_launcher_icons

# Generate splash screens
flutter pub run flutter_native_splash:create
```

## Architecture & Code Structure

### Directory Layout
- `lib/core/` - Cross-cutting concerns (network, theme, device ID)
- `lib/data/` - Database layer (Drift schema, providers)
- `lib/features/` - Feature modules (camera, library, talaria integration)
- `lib/services/` - Background services
- `lib/widgets/` - Reusable UI components
- `test/` - Unit and widget tests mirroring lib/ structure

### State Management Pattern
This app uses **Riverpod 3.x** for all state management:

- Providers are defined using the generator syntax with annotations
- UI components use `ConsumerWidget` or `Consumer` to access providers
- Business logic lives in Notifier classes (e.g., `JobStateNotifier`)
- Database streams are exposed via `StreamProvider`

**Key Providers:**
- `deviceIdProvider` - Persistent UUID from secure storage
- `databaseProvider` - Drift database instance
- `talariaClientProvider` - HTTP client for Talaria API
- `networkStatusProvider` - Connectivity monitoring
- `jobStateNotifierProvider` - Active scan job queue
- `booksProvider` - Stream of books from database
- `searchQueryProvider` - Current search query state

### Data Flow: The Capture Loop

1. **Capture** - User taps shutter → Image saved to temp cache → Background isolate compresses/resizes
2. **Upload** - Multipart POST to `/v3/jobs/scans` with `X-Device-ID` header
3. **Listen** - Connect to SSE stream at returned `streamUrl`
4. **Ingest** - SSE events (`progress`, `result`, `complete`, `error`) trigger UI updates and database upserts
5. **Display** - Library auto-refreshes via Drift's `.watch()` streams

### Database Schema (Drift)

**Books Table:**
- `isbn` (TEXT, PRIMARY KEY)
- `title` (TEXT)
- `author` (TEXT)
- `coverUrl` (TEXT, nullable)
- `format` (TEXT, nullable)
- `addedDate` (INTEGER, timestamp)
- `spineConfidence` (REAL, nullable)
- `reviewNeeded` (BOOL, default false)

**Full-Text Search:**
- Uses SQLite FTS5 virtual table `books_fts`
- Automatically synced via triggers on insert/update/delete
- Search via `database.searchBooks(query)`

**Failed Scans Table:**
- Tracks jobs that errored for debugging

### API Integration

**Base URL:** Not hardcoded - configured via `NetworkClient(baseUrl: ...)`

**Headers:**
- `X-Device-ID: <uuid>` on all requests

**Endpoints:**
- `POST /v3/jobs/scans` - Upload image, returns `{jobId, streamUrl}`
- `GET /v3/jobs/scans/{jobId}/stream` - SSE stream of job events
- `DELETE /v3/jobs/scans/{jobId}/cleanup` - Clean up server resources

**SSE Event Types:**
- `progress` - Analysis progress updates (0.0 - 1.0)
- `result` - Book metadata found (upsert to DB immediately)
- `complete` - Job finished successfully
- `error` - Job failed with error message

**Error Handling:**
- 429 Rate Limit → Parse `retryAfterMs`, disable shutter, show countdown
- Connection errors → Retry with exponential backoff (max 3 retries)
- 400 Bad Image → Show "Too Blurry" UI feedback

### Theme System

**Swiss Utility Design Tokens:**
- OLED Black: `#000000`
- International Orange: `#FF3B30` (accent)
- Border Gray: `#1C1C1E`
- Text Primary: `#FFFFFF`
- Text Secondary: `#8E8E93`

**Typography:**
- Body/UI text: Inter (via Google Fonts)
- Numbers/ISBNs/JSON: JetBrains Mono (via `AppTheme.monoStyle()`)

**Key Principles:**
- Zero elevation on all components
- 1px solid borders instead of shadows
- Dark mode only (no light theme)
- Haptic feedback at every interaction stage

### Haptic Feedback Strategy

**iOS-focused haptic design** - haptics are critical to the Wingtip UX:

- **Light Impact** - Shutter tap
- **Medium Impact** - Book saved to database
- **Heavy Impact** - Error or rate limit hit

Trigger via `HapticFeedback.lightImpact()` etc.

On iOS, these map to UIImpactFeedbackGenerator with different intensities. Android haptics are best-effort.

## Common Development Tasks

### Adding a New Book Field

1. Update `Books` table in `lib/data/database.dart`:
   ```dart
   TextColumn get newField => text().nullable()();
   ```

2. Increment `schemaVersion` in `AppDatabase`

3. Add migration in `onUpgrade`:
   ```dart
   if (from < 4) {
     await m.addColumn(books, books.newField);
   }
   ```

4. Run code generation:
   ```bash
   flutter pub run build_runner build --delete-conflicting-outputs
   ```

5. Update `_saveBookResult()` in `job_state_notifier.dart` to map the new field

### Adding a New SSE Event Type

1. Add enum value to `SseEventType` in `lib/core/sse_client.dart`

2. Update switch statement in `SseEvent.fromJson()`

3. Handle the event in `JobStateNotifier._handleSseEvent()`

### Testing Image Processing Pipeline

Use fixture images in `test/fixtures/`:

```dart
final testImage = File('test/fixtures/test_book_spine.jpg');
final processor = ImageProcessor();
final result = await processor.processImage(testImage.path);
```

### Debugging SSE Streams

Enable verbose logging in `lib/core/sse_client.dart` - all events are already logged with `debugPrint()`. Run with:

```bash
flutter run --verbose
```

Look for `[SseClient]` and `[JobStateNotifier]` prefixed logs.

### Performance Monitoring

Cold start metrics are logged automatically in `main.dart`:
- `[Performance] App started at ...`
- `[Performance] Camera initialization started`
- `[Performance] Cold start completed in Xms`

Target: < 1000ms cold start to live camera.

## Background Processing

Image compression runs in an isolate via `compute()` to avoid blocking the UI thread:

```dart
final result = await compute(_processImageInIsolate, imagePath);
```

Target: < 500ms processing time per image.

## Offline Behavior

- Library is 100% functional offline (viewing, searching, deleting)
- Only camera scanning requires network connection
- Network status shown in top-right corner when offline
- Failed uploads are NOT queued - user must manually retry

## Testing Strategy

- Unit tests for database queries (`test/data/`)
- Unit tests for network clients and SSE parsing (`test/core/`)
- Widget tests for UI components (`test/features/`)
- Mock providers using Riverpod's testing utilities

Example:
```dart
final container = ProviderContainer(
  overrides: [
    databaseProvider.overrideWithValue(mockDatabase),
  ],
);
```

## Known Constraints

- Camera permission is required before showing camera screen
- SQLite FTS5 module must be available on the platform
- SSE timeout is 5 minutes - longer jobs will fail
- Rate limits are enforced by backend - no client-side bypass
- Images are resized to max 1920px and compressed to JPEG quality 85
</file>

<file path=".ralph-tui/progress.md">
# Ralph Progress Log

This file tracks progress across iterations. It's automatically updated
after each iteration and included in agent prompts for context.

## Codebase Patterns (Study These First)

*Add reusable patterns discovered during development here.*

---

## ✓ Iteration 1 - US-131: Save Failed Scans to Database
*2026-01-19T04:25:46.112Z (194s)*

**Status:** Completed

**Notes:**
ror handling with debug logging included\n\n3. **Tests**\n   - Added 4 comprehensive tests to database_test.dart verifying the saveFailedScan method\n   - Added 5 tests to job_state_notifier_test.dart for failed scan persistence integration\n   - All tests verify timestamps, retention periods, multiple scans, and error message handling\n\n### Quality Checks:\n- ✅ flutter analyze: No issues found\n- ✅ flutter test: All relevant tests pass (47/47)\n- ✅ Commit created with proper message format\n\n

---
## ✓ Iteration 2 - US-132: Failed Scans Repository Layer
*2026-01-19T04:28:37.896Z (171s)*

**Status:** Completed

**Notes:**
r` - streams all failed scans for UI consumption\n\n**Comprehensive Testing:**\n- Created `test/data/failed_scans_repository_test.dart` with 14 test cases\n- Tests cover all methods with edge cases (empty data, non-existent IDs, multiple records)\n- All tests passing\n\n### Quality Checks\n- `flutter analyze` - No errors\n- `flutter test test/data/` - All 34 data layer tests passing (20 existing + 14 new)\n\n### Commit\n- Committed with message: `feat: US-132 - Failed Scans Repository Layer`\n\n

---
## ✓ Iteration 3 - US-133: Preserve Images for Failed Scans
*2026-01-19T04:33:03.756Z (265s)*

**Status:** Completed

**Notes:**
anual delete\n\n### All Acceptance Criteria Met:\n- ✅ When scan fails, move image from temp directory to persistent `app_documents/failed_scans/`\n- ✅ Filename format: `{jobId}.jpg` for easy lookup\n- ✅ Cleanup logic skips deletion for failed scans\n- ✅ On successful retry: delete image from failed_scans directory\n- ✅ On manual delete: remove both database entry and image file\n- ✅ flutter analyze shows no errors\n- ✅ Committed with message: `feat: US-133 - Preserve Images for Failed Scans`\n\n

---
## ✓ Iteration 4 - US-134: Handle Network Upload Failures
*2026-01-19T04:37:31.352Z (267s)*

**Status:** Completed

**Notes:**
mapping\n   - TimeoutException → \"Upload timed out after 30s\" mapping\n   - Failed scan persistence for network errors\n   - Failed scan persistence for timeouts\n   - Failed scan persistence for server unreachable\n   - Multiple network failures handling\n\n### Quality Checks\n- ✅ `flutter analyze` shows no errors\n- ✅ All tests pass (32/32 in job_state_notifier_test.dart)\n- ✅ Follows existing code patterns and architecture\n- ✅ Maintains iOS-first design philosophy with haptic feedback\n\n

---
</file>

<file path=".ralph-tui/ralph.lock">
{
  "pid": 24937,
  "sessionId": "62442e98-26fd-4859-9a1a-268232362edd",
  "acquiredAt": "2026-01-19T04:22:23.479Z",
  "cwd": "/Users/juju/dev_repos/wingtip",
  "hostname": "Justins-Air.oooe.home"
}
</file>

<file path=".ralph-tui/session-meta.json">
{
  "id": "53af4af6-8cad-4a18-b88f-8601f0492fca",
  "status": "running",
  "startedAt": "2026-01-19T04:22:23.481Z",
  "updatedAt": "2026-01-19T04:37:31.357Z",
  "agentPlugin": "claude",
  "trackerPlugin": "json",
  "prdPath": "tasks/epic-4.json",
  "currentIteration": 4,
  "maxIterations": 25,
  "totalTasks": 0,
  "tasksCompleted": 4,
  "cwd": "/Users/juju/dev_repos/wingtip"
}
</file>

<file path=".ralph-tui/session.json">
{
  "version": 1,
  "sessionId": "53af4af6-8cad-4a18-b88f-8601f0492fca",
  "status": "running",
  "startedAt": "2026-01-19T04:22:23.875Z",
  "updatedAt": "2026-01-19T04:37:32.361Z",
  "currentIteration": 4,
  "maxIterations": 25,
  "tasksCompleted": 4,
  "isPaused": false,
  "agentPlugin": "claude",
  "trackerState": {
    "plugin": "json",
    "prdPath": "tasks/epic-4.json",
    "totalTasks": 21,
    "tasks": [
      {
        "id": "US-131",
        "title": "Save Failed Scans to Database",
        "status": "completed",
        "completedInSession": true
      },
      {
        "id": "US-132",
        "title": "Failed Scans Repository Layer",
        "status": "completed",
        "completedInSession": true
      },
      {
        "id": "US-133",
        "title": "Preserve Images for Failed Scans",
        "status": "completed",
        "completedInSession": true
      },
      {
        "id": "US-134",
        "title": "Handle Network Upload Failures",
        "status": "completed",
        "completedInSession": true
      },
      {
        "id": "US-135",
        "title": "Handle Backend No Books Found Response",
        "status": "open",
        "completedInSession": false
      },
      {
        "id": "US-136",
        "title": "Failed Scans Tab in Library",
        "status": "open",
        "completedInSession": false
      },
      {
        "id": "US-137",
        "title": "Failed Scan Card UI",
        "status": "open",
        "completedInSession": false
      },
      {
        "id": "US-140",
        "title": "Manual Retry Single Scan",
        "status": "open",
        "completedInSession": false
      },
      {
        "id": "US-142",
        "title": "Auto-Cleanup Expired Failed Scans",
        "status": "open",
        "completedInSession": false
      },
      {
        "id": "US-143",
        "title": "Failed Scan Retention Settings",
        "status": "open",
        "completedInSession": false
      },
      {
        "id": "US-144",
        "title": "Device ID Management",
        "status": "open",
        "completedInSession": false
      },
      {
        "id": "US-146",
        "title": "Specific Error Messages for Common Failures",
        "status": "open",
        "completedInSession": false
      },
      {
        "id": "US-138",
        "title": "Batch Operations for Failed Scans",
        "status": "open",
        "completedInSession": false
      },
      {
        "id": "US-141",
        "title": "Batch Retry Failed Scans",
        "status": "open",
        "completedInSession": false
      },
      {
        "id": "US-139",
        "title": "Failed Scan Detail View",
        "status": "open",
        "completedInSession": false
      },
      {
        "id": "US-145",
        "title": "Network Retry on Connection Restored",
        "status": "open",
        "completedInSession": false
      },
      {
        "id": "US-148",
        "title": "Graceful SSE Stream Interruption Handling",
        "status": "open",
        "completedInSession": false
      },
      {
        "id": "US-150",
        "title": "Background Isolate Image Processing Verification",
        "status": "open",
        "completedInSession": false
      },
      {
        "id": "US-151",
        "title": "Session Counter Gamification",
        "status": "open",
        "completedInSession": false
      },
      {
        "id": "US-149",
        "title": "Failed Scan Analytics & Insights",
        "status": "open",
        "completedInSession": false
      },
      {
        "id": "US-152",
        "title": "Performance Monitoring Dashboard",
        "status": "open",
        "completedInSession": false
      }
    ]
  },
  "iterations": [
    {
      "iteration": 1,
      "status": "completed",
      "taskId": "US-131",
      "taskTitle": "Save Failed Scans to Database",
      "taskCompleted": true,
      "durationMs": 194143,
      "startedAt": "2026-01-19T04:22:31.959Z",
      "endedAt": "2026-01-19T04:25:46.102Z"
    },
    {
      "iteration": 2,
      "status": "completed",
      "taskId": "US-132",
      "taskTitle": "Failed Scans Repository Layer",
      "taskCompleted": true,
      "durationMs": 170765,
      "startedAt": "2026-01-19T04:25:47.122Z",
      "endedAt": "2026-01-19T04:28:37.887Z"
    },
    {
      "iteration": 3,
      "status": "completed",
      "taskId": "US-133",
      "taskTitle": "Preserve Images for Failed Scans",
      "taskCompleted": true,
      "durationMs": 264847,
      "startedAt": "2026-01-19T04:28:38.903Z",
      "endedAt": "2026-01-19T04:33:03.750Z"
    },
    {
      "iteration": 4,
      "status": "completed",
      "taskId": "US-134",
      "taskTitle": "Handle Network Upload Failures",
      "taskCompleted": true,
      "durationMs": 266582,
      "startedAt": "2026-01-19T04:33:04.761Z",
      "endedAt": "2026-01-19T04:37:31.343Z"
    }
  ],
  "skippedTaskIds": [],
  "cwd": "/Users/juju/dev_repos/wingtip",
  "activeTaskIds": [
    "US-135"
  ],
  "subagentPanelVisible": false
}
</file>

<file path="ios/Runner/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
	<dict>
		<key>CFBundleDevelopmentRegion</key>
		<string>$(DEVELOPMENT_LANGUAGE)</string>
		<key>CFBundleDisplayName</key>
		<string>Wingtip</string>
		<key>CFBundleExecutable</key>
		<string>$(EXECUTABLE_NAME)</string>
		<key>CFBundleIdentifier</key>
		<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
		<key>CFBundleInfoDictionaryVersion</key>
		<string>6.0</string>
		<key>CFBundleName</key>
		<string>wingtip</string>
		<key>CFBundlePackageType</key>
		<string>APPL</string>
		<key>CFBundleShortVersionString</key>
		<string>$(FLUTTER_BUILD_NAME)</string>
		<key>CFBundleSignature</key>
		<string>????</string>
		<key>CFBundleVersion</key>
		<string>$(FLUTTER_BUILD_NUMBER)</string>
		<key>LSRequiresIPhoneOS</key>
		<true/>
		<key>UILaunchStoryboardName</key>
		<string>LaunchScreen</string>
		<key>UIMainStoryboardFile</key>
		<string>Main</string>
		<key>UISupportedInterfaceOrientations</key>
		<array>
			<string>UIInterfaceOrientationPortrait</string>
			<string>UIInterfaceOrientationLandscapeLeft</string>
			<string>UIInterfaceOrientationLandscapeRight</string>
		</array>
		<key>UISupportedInterfaceOrientations~ipad</key>
		<array>
			<string>UIInterfaceOrientationPortrait</string>
			<string>UIInterfaceOrientationPortraitUpsideDown</string>
			<string>UIInterfaceOrientationLandscapeLeft</string>
			<string>UIInterfaceOrientationLandscapeRight</string>
		</array>
		<key>CADisableMinimumFrameDurationOnPhone</key>
		<true/>
		<key>UIApplicationSupportsIndirectInputEvents</key>
		<true/>
		<key>NSCameraUsageDescription</key>
		<string>Camera access is required to scan book spines.</string>
		<key>UIStatusBarHidden</key>
		<false/>
	</dict>
</plist>
</file>

<file path="lib/features/talaria/processing_stack_widget.dart">
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:wingtip/features/talaria/job_state.dart';
import 'package:wingtip/features/talaria/job_state_provider.dart';
class ProcessingStackWidget extends ConsumerStatefulWidget {
  const ProcessingStackWidget({super.key});
  @override
  ConsumerState<ProcessingStackWidget> createState() => _ProcessingStackWidgetState();
}
class _ProcessingStackWidgetState extends ConsumerState<ProcessingStackWidget> {
  final Map<String, bool> _removingJobs = {};
  @override
  Widget build(BuildContext context) {
    final jobState = ref.watch(jobStateProvider);
    final jobs = jobState.jobs;
    if (jobs.isEmpty) {
      return const SizedBox.shrink();
    }
    return Positioned(
      left: 16,
      right: 16,
      bottom: 140,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
            decoration: BoxDecoration(
              color: Colors.black.withValues(alpha: 0.7),
              borderRadius: BorderRadius.circular(12),
              border: Border.all(
                color: Colors.white.withValues(alpha: 0.3),
                width: 1,
              ),
            ),
            child: Text(
              '${jobs.length} ${jobs.length == 1 ? 'job' : 'jobs'}',
              style: const TextStyle(
                color: Colors.white,
                fontSize: 12,
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          const SizedBox(height: 8),
          SizedBox(
            height: 60,
            child: ListView.builder(
              scrollDirection: Axis.horizontal,
              itemCount: jobs.length,
              itemBuilder: (context, index) {
                final job = jobs[index];
                final isRemoving = _removingJobs[job.id] ?? false;
                if (job.status == JobStatus.completed && !isRemoving) {
                  _scheduleRemoval(job.id);
                }
                return AnimatedOpacity(
                  opacity: isRemoving ? 0.0 : 1.0,
                  duration: const Duration(milliseconds: 300),
                  child: Padding(
                    padding: EdgeInsets.only(right: index < jobs.length - 1 ? 8 : 0),
                    child: JobCardWidget(job: job),
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
  void _scheduleRemoval(String jobId) {
    Future.delayed(const Duration(seconds: 5), () {
      if (mounted) {
        setState(() {
          _removingJobs[jobId] = true;
        });
        Future.delayed(const Duration(milliseconds: 300), () {
          _removingJobs.remove(jobId);
        });
      }
    });
  }
}
class JobCardWidget extends StatelessWidget {
  final ScanJob job;
  const JobCardWidget({
    super.key,
    required this.job,
  });
  @override
  Widget build(BuildContext context) {
    final borderColor = _getBorderColor(job.status);
    return Container(
      width: 40,
      height: 60,
      decoration: BoxDecoration(
        border: Border.all(
          color: borderColor,
          width: 3,
        ),
        borderRadius: BorderRadius.circular(4),
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(1),
        child: Stack(
          fit: StackFit.expand,
          children: [
            _buildThumbnail(),
            _buildProgressOverlay(),
          ],
        ),
      ),
    );
  }
  Widget _buildThumbnail() {
    final imageFile = File(job.imagePath);
    if (!imageFile.existsSync()) {
      return Container(
        color: Colors.grey[900],
        child: const Icon(
          Icons.image_not_supported,
          color: Colors.white54,
          size: 20,
        ),
      );
    }
    return Image.file(
      imageFile,
      fit: BoxFit.cover,
      errorBuilder: (context, error, stackTrace) {
        return Container(
          color: Colors.grey[900],
          child: const Icon(
            Icons.broken_image,
            color: Colors.white54,
            size: 20,
          ),
        );
      },
    );
  }
  Widget _buildProgressOverlay() {
    final message = job.progressMessage;
    final showMessage = message != null && message.isNotEmpty;
    return AnimatedOpacity(
      opacity: showMessage ? 1.0 : 0.0,
      duration: const Duration(milliseconds: 200),
      child: showMessage
          ? Container(
              color: Colors.black.withValues(alpha: 0.6),
              alignment: Alignment.center,
              padding: const EdgeInsets.all(2),
              child: Text(
                message,
                textAlign: TextAlign.center,
                style: GoogleFonts.jetBrainsMono(
                  fontSize: 7,
                  fontWeight: FontWeight.w500,
                  color: Colors.white,
                  height: 1.2,
                ),
              ),
            )
          : const SizedBox.shrink(),
    );
  }
  Color _getBorderColor(JobStatus status) {
    switch (status) {
      case JobStatus.uploading:
        return Colors.yellow;
      case JobStatus.listening:
      case JobStatus.processing:
        return Colors.blue;
      case JobStatus.completed:
        return Colors.green;
      case JobStatus.error:
        return Colors.red;
    }
  }
}
</file>

<file path="ios/Runner.xcodeproj/project.pbxproj">
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXBuildFile section */
		1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */ = {isa = PBXBuildFile; fileRef = 1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */; };
		331C808B294A63AB00263BE5 /* RunnerTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 331C807B294A618700263BE5 /* RunnerTests.swift */; };
		3B3967161E833CAA004F5970 /* AppFrameworkInfo.plist in Resources */ = {isa = PBXBuildFile; fileRef = 3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */; };
		74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 74858FAE1ED2DC5600515810 /* AppDelegate.swift */; };
		97C146FC1CF9000F007C117D /* Main.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FA1CF9000F007C117D /* Main.storyboard */; };
		97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FD1CF9000F007C117D /* Assets.xcassets */; };
		97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		331C8085294A63A400263BE5 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 97C146E61CF9000F007C117D /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 97C146ED1CF9000F007C117D;
			remoteInfo = Runner;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXCopyFilesBuildPhase section */
		9705A1C41CF9048500538489 /* Embed Frameworks */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "";
			dstSubfolderSpec = 10;
			files = (
			);
			name = "Embed Frameworks";
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = GeneratedPluginRegistrant.h; sourceTree = "<group>"; };
		1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GeneratedPluginRegistrant.m; sourceTree = "<group>"; };
		331C807B294A618700263BE5 /* RunnerTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RunnerTests.swift; sourceTree = "<group>"; };
		331C8081294A63A400263BE5 /* RunnerTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = RunnerTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; name = AppFrameworkInfo.plist; path = Flutter/AppFrameworkInfo.plist; sourceTree = "<group>"; };
		74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "Runner-Bridging-Header.h"; sourceTree = "<group>"; };
		74858FAE1ED2DC5600515810 /* AppDelegate.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		7AFA3C8E1D35360C0083082E /* Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; name = Release.xcconfig; path = Flutter/Release.xcconfig; sourceTree = "<group>"; };
		9740EEB21CF90195004384FC /* Debug.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Debug.xcconfig; path = Flutter/Debug.xcconfig; sourceTree = "<group>"; };
		9740EEB31CF90195004384FC /* Generated.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Generated.xcconfig; path = Flutter/Generated.xcconfig; sourceTree = "<group>"; };
		97C146EE1CF9000F007C117D /* Runner.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Runner.app; sourceTree = BUILT_PRODUCTS_DIR; };
		97C146FB1CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/Main.storyboard; sourceTree = "<group>"; };
		97C146FD1CF9000F007C117D /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		97C147001CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/LaunchScreen.storyboard; sourceTree = "<group>"; };
		97C147021CF9000F007C117D /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		97C146EB1CF9000F007C117D /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		331C8082294A63A400263BE5 /* RunnerTests */ = {
			isa = PBXGroup;
			children = (
				331C807B294A618700263BE5 /* RunnerTests.swift */,
			);
			path = RunnerTests;
			sourceTree = "<group>";
		};
		9740EEB11CF90186004384FC /* Flutter */ = {
			isa = PBXGroup;
			children = (
				3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */,
				9740EEB21CF90195004384FC /* Debug.xcconfig */,
				7AFA3C8E1D35360C0083082E /* Release.xcconfig */,
				9740EEB31CF90195004384FC /* Generated.xcconfig */,
			);
			name = Flutter;
			sourceTree = "<group>";
		};
		97C146E51CF9000F007C117D = {
			isa = PBXGroup;
			children = (
				9740EEB11CF90186004384FC /* Flutter */,
				97C146F01CF9000F007C117D /* Runner */,
				97C146EF1CF9000F007C117D /* Products */,
				331C8082294A63A400263BE5 /* RunnerTests */,
			);
			sourceTree = "<group>";
		};
		97C146EF1CF9000F007C117D /* Products */ = {
			isa = PBXGroup;
			children = (
				97C146EE1CF9000F007C117D /* Runner.app */,
				331C8081294A63A400263BE5 /* RunnerTests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		97C146F01CF9000F007C117D /* Runner */ = {
			isa = PBXGroup;
			children = (
				97C146FA1CF9000F007C117D /* Main.storyboard */,
				97C146FD1CF9000F007C117D /* Assets.xcassets */,
				97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */,
				97C147021CF9000F007C117D /* Info.plist */,
				1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */,
				1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */,
				74858FAE1ED2DC5600515810 /* AppDelegate.swift */,
				74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */,
			);
			path = Runner;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		331C8080294A63A400263BE5 /* RunnerTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 331C8087294A63A400263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */;
			buildPhases = (
				331C807D294A63A400263BE5 /* Sources */,
				331C807F294A63A400263BE5 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				331C8086294A63A400263BE5 /* PBXTargetDependency */,
			);
			name = RunnerTests;
			productName = RunnerTests;
			productReference = 331C8081294A63A400263BE5 /* RunnerTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		97C146ED1CF9000F007C117D /* Runner */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget "Runner" */;
			buildPhases = (
				9740EEB61CF901F6004384FC /* Run Script */,
				97C146EA1CF9000F007C117D /* Sources */,
				97C146EB1CF9000F007C117D /* Frameworks */,
				97C146EC1CF9000F007C117D /* Resources */,
				9705A1C41CF9048500538489 /* Embed Frameworks */,
				3B06AD1E1E4923F5004D2608 /* Thin Binary */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = Runner;
			productName = Runner;
			productReference = 97C146EE1CF9000F007C117D /* Runner.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		97C146E61CF9000F007C117D /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = YES;
				LastUpgradeCheck = 1510;
				ORGANIZATIONNAME = "";
				TargetAttributes = {
					331C8080294A63A400263BE5 = {
						CreatedOnToolsVersion = 14.0;
						TestTargetID = 97C146ED1CF9000F007C117D;
					};
					97C146ED1CF9000F007C117D = {
						CreatedOnToolsVersion = 7.3.1;
						LastSwiftMigration = 1100;
					};
				};
			};
			buildConfigurationList = 97C146E91CF9000F007C117D /* Build configuration list for PBXProject "Runner" */;
			compatibilityVersion = "Xcode 9.3";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 97C146E51CF9000F007C117D;
			productRefGroup = 97C146EF1CF9000F007C117D /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				97C146ED1CF9000F007C117D /* Runner */,
				331C8080294A63A400263BE5 /* RunnerTests */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		331C807F294A63A400263BE5 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EC1CF9000F007C117D /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */,
				3B3967161E833CAA004F5970 /* AppFrameworkInfo.plist in Resources */,
				97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */,
				97C146FC1CF9000F007C117D /* Main.storyboard in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		3B06AD1E1E4923F5004D2608 /* Thin Binary */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
				"${TARGET_BUILD_DIR}/${INFOPLIST_PATH}",
			);
			name = "Thin Binary";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" embed_and_thin";
		};
		9740EEB61CF901F6004384FC /* Run Script */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
			);
			name = "Run Script";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" build";
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		331C807D294A63A400263BE5 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				331C808B294A63AB00263BE5 /* RunnerTests.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EA1CF9000F007C117D /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */,
				1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		331C8086294A63A400263BE5 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 97C146ED1CF9000F007C117D /* Runner */;
			targetProxy = 331C8085294A63A400263BE5 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin PBXVariantGroup section */
		97C146FA1CF9000F007C117D /* Main.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				97C146FB1CF9000F007C117D /* Base */,
			);
			name = Main.storyboard;
			sourceTree = "<group>";
		};
		97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				97C147001CF9000F007C117D /* Base */,
			);
			name = LaunchScreen.storyboard;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		249021D3217E4FDB00AE95B9 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 13.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
				VALIDATE_PRODUCT = YES;
			};
			name = Profile;
		};
		249021D4217E4FDB00AE95B9 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_INCLUDE_ALL_APPICON_ASSETS = YES;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				DEVELOPMENT_TEAM = 8Z67H8Y8DW;
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				INFOPLIST_KEY_CFBundleDisplayName = libScan;
				INFOPLIST_KEY_LSApplicationCategoryType = "public.app-category.utilities";
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.ooheynerds.wingtip;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SUPPORTED_PLATFORMS = "iphoneos iphonesimulator";
				SUPPORTS_MACCATALYST = NO;
				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = NO;
				SUPPORTS_XR_DESIGNED_FOR_IPHONE_IPAD = NO;
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Profile;
		};
		331C8088294A63A400263BE5 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.ooheynerds.wingtip.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Debug;
		};
		331C8089294A63A400263BE5 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.ooheynerds.wingtip.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Release;
		};
		331C808A294A63A400263BE5 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.ooheynerds.wingtip.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Profile;
		};
		97C147031CF9000F007C117D /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = AppIcon;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 13.0;
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
		97C147041CF9000F007C117D /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = AppIcon;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 13.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
				TARGETED_DEVICE_FAMILY = "1,2";
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		97C147061CF9000F007C117D /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 9740EEB21CF90195004384FC /* Debug.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_INCLUDE_ALL_APPICON_ASSETS = YES;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				DEVELOPMENT_TEAM = 8Z67H8Y8DW;
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				INFOPLIST_KEY_CFBundleDisplayName = libScan;
				INFOPLIST_KEY_LSApplicationCategoryType = "public.app-category.utilities";
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.ooheynerds.wingtip;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SUPPORTED_PLATFORMS = "iphoneos iphonesimulator";
				SUPPORTS_MACCATALYST = NO;
				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = NO;
				SUPPORTS_XR_DESIGNED_FOR_IPHONE_IPAD = NO;
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Debug;
		};
		97C147071CF9000F007C117D /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_INCLUDE_ALL_APPICON_ASSETS = YES;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				DEVELOPMENT_TEAM = 8Z67H8Y8DW;
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				INFOPLIST_KEY_CFBundleDisplayName = libScan;
				INFOPLIST_KEY_LSApplicationCategoryType = "public.app-category.utilities";
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.ooheynerds.wingtip;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SUPPORTED_PLATFORMS = "iphoneos iphonesimulator";
				SUPPORTS_MACCATALYST = NO;
				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = NO;
				SUPPORTS_XR_DESIGNED_FOR_IPHONE_IPAD = NO;
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2";
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		331C8087294A63A400263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				331C8088294A63A400263BE5 /* Debug */,
				331C8089294A63A400263BE5 /* Release */,
				331C808A294A63A400263BE5 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		97C146E91CF9000F007C117D /* Build configuration list for PBXProject "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				97C147031CF9000F007C117D /* Debug */,
				97C147041CF9000F007C117D /* Release */,
				249021D3217E4FDB00AE95B9 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				97C147061CF9000F007C117D /* Debug */,
				97C147071CF9000F007C117D /* Release */,
				249021D4217E4FDB00AE95B9 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 97C146E61CF9000F007C117D /* Project object */;
}
</file>

<file path="lib/features/debug/debug_settings_page.dart">
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_cache_manager/flutter_cache_manager.dart';
import 'package:path_provider/path_provider.dart';
import 'package:wingtip/core/device_id_provider.dart';
import 'package:wingtip/services/csv_export_service_provider.dart';
import 'package:wingtip/widgets/error_snack_bar.dart';
class DebugSettingsPage extends ConsumerWidget {
  const DebugSettingsPage({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final deviceIdAsync = ref.watch(deviceIdProvider);
    return Scaffold(
      appBar: AppBar(
        title: const Text('Debug Settings'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Device ID',
              style: Theme.of(context).textTheme.titleLarge,
            ),
            const SizedBox(height: 16),
            deviceIdAsync.when(
              data: (deviceId) => _DeviceIdSection(deviceId: deviceId),
              loading: () => const Center(child: CircularProgressIndicator()),
              error: (error, stack) => Text(
                'Error: $error',
                style: TextStyle(color: Theme.of(context).colorScheme.error),
              ),
            ),
            const SizedBox(height: 32),
            const Divider(),
            const SizedBox(height: 16),
            Text(
              'Export Library',
              style: Theme.of(context).textTheme.titleLarge,
            ),
            const SizedBox(height: 16),
            OutlinedButton.icon(
              onPressed: () async {
                final csvExportService = ref.read(csvExportServiceProvider);
                try {
                  final filePath = await csvExportService.exportLibraryToCsv();
                  if (filePath == null) {
                    if (context.mounted) {
                      ErrorSnackBar.show(
                        context,
                        message: 'No books to export',
                      );
                    }
                    return;
                  }
                  await csvExportService.shareExportedCsv(filePath);
                } catch (e) {
                  if (context.mounted) {
                    ErrorSnackBar.show(
                      context,
                      message: 'Failed to export library: $e',
                    );
                  }
                }
              },
              icon: const Icon(Icons.download),
              label: const Text('Export Library'),
            ),
            const SizedBox(height: 32),
            const Divider(),
            const SizedBox(height: 16),
            Text(
              'Test Error Snackbar',
              style: Theme.of(context).textTheme.titleLarge,
            ),
            const SizedBox(height: 16),
            OutlinedButton.icon(
              onPressed: () {
                ErrorSnackBar.show(
                  context,
                  message: 'This is a test error message',
                );
              },
              icon: const Icon(Icons.error_outline),
              label: const Text('Show Error Snackbar'),
            ),
            const SizedBox(height: 32),
            const Divider(),
            const SizedBox(height: 16),
            Text(
              'Image Cache',
              style: Theme.of(context).textTheme.titleLarge,
            ),
            const SizedBox(height: 16),
            _ImageCacheSection(),
          ],
        ),
      ),
    );
  }
}
class _DeviceIdSection extends ConsumerWidget {
  const _DeviceIdSection({required this.deviceId});
  final String deviceId;
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Expanded(
                  child: SelectableText(
                    deviceId,
                    style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                          fontFamily: 'monospace',
                        ),
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.copy),
                  tooltip: 'Copy to clipboard',
                  onPressed: () async {
                    await Clipboard.setData(ClipboardData(text: deviceId));
                    if (context.mounted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text('Device ID copied to clipboard'),
                          duration: Duration(seconds: 2),
                        ),
                      );
                    }
                  },
                ),
              ],
            ),
            const SizedBox(height: 16),
            ElevatedButton.icon(
              onPressed: () async {
                final confirmed = await showDialog<bool>(
                  context: context,
                  builder: (context) => AlertDialog(
                    title: const Text('Regenerate Device ID?'),
                    content: const Text(
                      'This will generate a new device ID. This action is irreversible and should only be used for debugging.',
                    ),
                    actions: [
                      TextButton(
                        onPressed: () => Navigator.of(context).pop(false),
                        child: const Text('Cancel'),
                      ),
                      ElevatedButton(
                        onPressed: () => Navigator.of(context).pop(true),
                        child: const Text('Regenerate'),
                      ),
                    ],
                  ),
                );
                if (confirmed == true && context.mounted) {
                  final service = ref.read(deviceIdServiceProvider);
                  await service.regenerateDeviceId();
                  ref.invalidate(deviceIdProvider);
                  if (context.mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(
                        content: Text('Device ID regenerated'),
                        duration: Duration(seconds: 2),
                      ),
                    );
                  }
                }
              },
              icon: const Icon(Icons.refresh),
              label: const Text('Regenerate Device ID'),
            ),
          ],
        ),
      ),
    );
  }
}
class _ImageCacheSection extends ConsumerStatefulWidget {
  const _ImageCacheSection();
  @override
  ConsumerState<_ImageCacheSection> createState() => _ImageCacheSectionState();
}
class _ImageCacheSectionState extends ConsumerState<_ImageCacheSection> {
  String _cacheSize = 'Calculating...';
  bool _isClearing = false;
  @override
  void initState() {
    super.initState();
    _calculateCacheSize();
  }
  Future<void> _calculateCacheSize() async {
    try {
      final tempDir = await getTemporaryDirectory();
      final cacheDir = Directory('${tempDir.path}/libCachedImageData');
      int totalSize = 0;
      if (await cacheDir.exists()) {
        await for (final entity in cacheDir.list(recursive: true, followLinks: false)) {
          if (entity is File) {
            try {
              final fileSize = await entity.length();
              totalSize += fileSize;
            } catch (e) {
            }
          }
        }
      }
      if (mounted) {
        setState(() {
          _cacheSize = _formatBytes(totalSize);
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _cacheSize = 'Error calculating';
        });
      }
    }
  }
  String _formatBytes(int bytes) {
    if (bytes < 1024) return '$bytes B';
    if (bytes < 1024 * 1024) return '${(bytes / 1024).toStringAsFixed(1)} KB';
    if (bytes < 1024 * 1024 * 1024) {
      return '${(bytes / (1024 * 1024)).toStringAsFixed(1)} MB';
    }
    return '${(bytes / (1024 * 1024 * 1024)).toStringAsFixed(1)} GB';
  }
  Future<void> _clearCache() async {
    setState(() {
      _isClearing = true;
    });
    try {
      final cacheManager = DefaultCacheManager();
      await cacheManager.emptyCache();
      await _calculateCacheSize();
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Image cache cleared'),
            duration: Duration(seconds: 2),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ErrorSnackBar.show(
          context,
          message: 'Failed to clear cache: $e',
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isClearing = false;
        });
      }
    }
  }
  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'Cache Size',
                  style: Theme.of(context).textTheme.bodyLarge,
                ),
                Text(
                  _cacheSize,
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                        fontFamily: 'monospace',
                        fontWeight: FontWeight.bold,
                      ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: _isClearing ? null : _clearCache,
                icon: _isClearing
                    ? const SizedBox(
                        width: 16,
                        height: 16,
                        child: CircularProgressIndicator(strokeWidth: 2),
                      )
                    : const Icon(Icons.delete_outline),
                label: Text(_isClearing ? 'Clearing...' : 'Clear Image Cache'),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
</file>

<file path="lib/features/library/library_provider.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/database.dart';
import '../../data/database_provider.dart';
class SearchQueryNotifier extends Notifier<String> {
  @override
  String build() => '';
  void setQuery(String query) {
    state = query;
  }
}
final searchQueryProvider = NotifierProvider<SearchQueryNotifier, String>(
  SearchQueryNotifier.new,
);
class ReviewNeededFilterNotifier extends Notifier<bool?> {
  @override
  bool? build() => null;
  void setFilter(bool? filter) {
    state = filter;
  }
  void toggleNeedsReview() {
    state = state == true ? null : true;
  }
}
final reviewNeededFilterProvider = NotifierProvider<ReviewNeededFilterNotifier, bool?>(
  ReviewNeededFilterNotifier.new,
);
class SortReviewFirstNotifier extends Notifier<bool> {
  @override
  bool build() => false;
  void setSortReviewFirst(bool sort) {
    state = sort;
  }
  void toggle() {
    state = !state;
  }
}
final sortReviewFirstProvider = NotifierProvider<SortReviewFirstNotifier, bool>(
  SortReviewFirstNotifier.new,
);
final booksProvider = StreamProvider<List<Book>>((ref) {
  final database = ref.watch(databaseProvider);
  final searchQuery = ref.watch(searchQueryProvider);
  final reviewNeededFilter = ref.watch(reviewNeededFilterProvider);
  final sortReviewFirst = ref.watch(sortReviewFirstProvider);
  return database.searchBooks(
    searchQuery,
    reviewNeeded: reviewNeededFilter,
    sortReviewFirst: sortReviewFirst,
  );
});
final allBooksProvider = StreamProvider<List<Book>>((ref) {
  return ref.watch(booksProvider.future).asStream().asyncExpand((books) => Stream.value(books));
});
class SelectModeNotifier extends Notifier<bool> {
  @override
  bool build() => false;
  void enable() {
    state = true;
  }
  void disable() {
    state = false;
    ref.read(selectedBooksProvider.notifier).clear();
  }
  void toggle() {
    state = !state;
    if (!state) {
      ref.read(selectedBooksProvider.notifier).clear();
    }
  }
}
final selectModeProvider = NotifierProvider<SelectModeNotifier, bool>(
  SelectModeNotifier.new,
);
class SelectedBooksNotifier extends Notifier<Set<String>> {
  @override
  Set<String> build() => {};
  void toggle(String isbn) {
    if (state.contains(isbn)) {
      state = {...state}..remove(isbn);
    } else {
      state = {...state, isbn};
    }
  }
  void clear() {
    state = {};
  }
  void selectAll(List<String> isbns) {
    state = {...isbns};
  }
}
final selectedBooksProvider = NotifierProvider<SelectedBooksNotifier, Set<String>>(
  SelectedBooksNotifier.new,
);
</file>

<file path="lib/features/talaria/job_state.dart">
class ScanJob {
  final String id;
  final String? jobId;
  final String? streamUrl;
  final String imagePath;
  final JobStatus status;
  final String? errorMessage;
  final double? progress;
  final String? progressMessage;
  final Map<String, dynamic>? result;
  final DateTime createdAt;
  const ScanJob({
    required this.id,
    this.jobId,
    this.streamUrl,
    required this.imagePath,
    required this.status,
    this.errorMessage,
    this.progress,
    this.progressMessage,
    this.result,
    required this.createdAt,
  });
  factory ScanJob.uploading(String imagePath) {
    return ScanJob(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      status: JobStatus.uploading,
      imagePath: imagePath,
      createdAt: DateTime.now(),
    );
  }
  ScanJob copyWith({
    String? jobId,
    String? streamUrl,
    JobStatus? status,
    String? errorMessage,
    double? progress,
    String? progressMessage,
    Map<String, dynamic>? result,
  }) {
    return ScanJob(
      id: id,
      jobId: jobId ?? this.jobId,
      streamUrl: streamUrl ?? this.streamUrl,
      imagePath: imagePath,
      status: status ?? this.status,
      errorMessage: errorMessage ?? this.errorMessage,
      progress: progress ?? this.progress,
      progressMessage: progressMessage ?? this.progressMessage,
      result: result ?? this.result,
      createdAt: createdAt,
    );
  }
}
class RateLimitInfo {
  final DateTime expiresAt;
  final int retryAfterMs;
  const RateLimitInfo({
    required this.expiresAt,
    required this.retryAfterMs,
  });
  bool get isActive => DateTime.now().isBefore(expiresAt);
  int get remainingMs {
    final remaining = expiresAt.difference(DateTime.now()).inMilliseconds;
    return remaining > 0 ? remaining : 0;
  }
}
class JobState {
  final List<ScanJob> jobs;
  final RateLimitInfo? rateLimit;
  const JobState({
    this.jobs = const [],
    this.rateLimit,
  });
  factory JobState.idle() {
    return const JobState(jobs: []);
  }
  JobState copyWith({
    List<ScanJob>? jobs,
    RateLimitInfo? rateLimit,
  }) {
    return JobState(
      jobs: jobs ?? this.jobs,
      rateLimit: rateLimit ?? this.rateLimit,
    );
  }
  JobState clearRateLimit() {
    return JobState(
      jobs: jobs,
      rateLimit: null,
    );
  }
  List<ScanJob> get activeJobs {
    return jobs
        .where((job) =>
            job.status != JobStatus.completed && job.status != JobStatus.error)
        .toList();
  }
  ScanJob? getJobById(String id) {
    try {
      return jobs.firstWhere((job) => job.id == id);
    } catch (e) {
      return null;
    }
  }
  ScanJob? getJobByJobId(String jobId) {
    try {
      return jobs.firstWhere((job) => job.jobId == jobId);
    } catch (e) {
      return null;
    }
  }
}
enum JobStatus {
  uploading,
  listening,
  processing,
  completed,
  error,
}
</file>

<file path="lib/data/database.dart">
import 'dart:io';
import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
import 'package:sqlite3_flutter_libs/sqlite3_flutter_libs.dart';
part 'database.g.dart';
@DataClassName('Book')
class Books extends Table {
  TextColumn get isbn => text()();
  TextColumn get title => text()();
  TextColumn get author => text()();
  TextColumn get coverUrl => text().nullable()();
  TextColumn get format => text().nullable()();
  IntColumn get addedDate => integer()();
  RealColumn get spineConfidence => real().nullable()();
  BoolColumn get reviewNeeded => boolean().withDefault(const Constant(false))();
  @override
  Set<Column> get primaryKey => {isbn};
}
@DataClassName('FailedScan')
class FailedScans extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get jobId => text()();
  TextColumn get imagePath => text()();
  TextColumn get errorMessage => text()();
  IntColumn get createdAt => integer()();
  IntColumn get expiresAt => integer()();
}
@DriftDatabase(tables: [Books, FailedScans])
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(_openConnection());
  AppDatabase.test(super.executor);
  @override
  int get schemaVersion => 3;
  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onCreate: (Migrator m) async {
        await m.createAll();
        await customStatement(
          'CREATE INDEX idx_books_added_date ON books(added_date DESC)',
        );
        await customStatement(
          '''CREATE VIRTUAL TABLE books_fts USING fts5(
            isbn,
            title,
            author,
            content=books,
            content_rowid=rowid
          )''',
        );
        await customStatement(
          '''CREATE TRIGGER books_fts_insert AFTER INSERT ON books BEGIN
            INSERT INTO books_fts(rowid, isbn, title, author)
            VALUES (new.rowid, new.isbn, new.title, new.author);
          END''',
        );
        await customStatement(
          '''CREATE TRIGGER books_fts_delete AFTER DELETE ON books BEGIN
            INSERT INTO books_fts(books_fts, rowid, isbn, title, author)
            VALUES('delete', old.rowid, old.isbn, old.title, old.author);
          END''',
        );
        await customStatement(
          '''CREATE TRIGGER books_fts_update AFTER UPDATE ON books BEGIN
            INSERT INTO books_fts(books_fts, rowid, isbn, title, author)
            VALUES('delete', old.rowid, old.isbn, old.title, old.author);
            INSERT INTO books_fts(rowid, isbn, title, author)
            VALUES (new.rowid, new.isbn, new.title, new.author);
          END''',
        );
      },
      onUpgrade: (Migrator m, int from, int to) async {
        if (from < 2) {
          // Create FTS5 virtual table for full-text search
          await customStatement(
            '''CREATE VIRTUAL TABLE books_fts USING fts5(
              isbn,
              title,
              author,
              content=books,
              content_rowid=rowid
            )''',
          );
          // Populate FTS table with existing data
          await customStatement(
            '''INSERT INTO books_fts(rowid, isbn, title, author)
            SELECT rowid, isbn, title, author FROM books''',
          );
          // Create triggers to keep FTS5 table in sync
          await customStatement(
            '''CREATE TRIGGER books_fts_insert AFTER INSERT ON books BEGIN
              INSERT INTO books_fts(rowid, isbn, title, author)
              VALUES (new.rowid, new.isbn, new.title, new.author);
            END''',
          );
          await customStatement(
            '''CREATE TRIGGER books_fts_delete AFTER DELETE ON books BEGIN
              INSERT INTO books_fts(books_fts, rowid, isbn, title, author)
              VALUES('delete', old.rowid, old.isbn, old.title, old.author);
            END''',
          );
          await customStatement(
            '''CREATE TRIGGER books_fts_update AFTER UPDATE ON books BEGIN
              INSERT INTO books_fts(books_fts, rowid, isbn, title, author)
              VALUES('delete', old.rowid, old.isbn, old.title, old.author);
              INSERT INTO books_fts(rowid, isbn, title, author)
              VALUES (new.rowid, new.isbn, new.title, new.author);
            END''',
          );
        }
        if (from < 3) {
          // Add review_needed column
          await m.addColumn(books, books.reviewNeeded);
        }
      },
    );
  }
  // Query all books ordered by added date descending
  Stream<List<Book>> watchAllBooks({bool? reviewNeeded, bool sortReviewFirst = false}) {
    final query = select(books);
    if (reviewNeeded != null) {
      query.where((t) => t.reviewNeeded.equals(reviewNeeded));
    }
    if (sortReviewFirst) {
      query.orderBy([
        (t) => OrderingTerm.desc(t.reviewNeeded),
        (t) => OrderingTerm.desc(t.addedDate),
      ]);
    } else {
      query.orderBy([(t) => OrderingTerm.desc(t.addedDate)]);
    }
    return query.watch();
  }
  Future<List<Book>> getAllBooks({bool? reviewNeeded, bool sortReviewFirst = false}) {
    final query = select(books);
    if (reviewNeeded != null) {
      query.where((t) => t.reviewNeeded.equals(reviewNeeded));
    }
    if (sortReviewFirst) {
      query.orderBy([
        (t) => OrderingTerm.desc(t.reviewNeeded),
        (t) => OrderingTerm.desc(t.addedDate),
      ]);
    } else {
      query.orderBy([(t) => OrderingTerm.desc(t.addedDate)]);
    }
    return query.get();
  }
  // Search books using FTS5
  Stream<List<Book>> searchBooks(String query, {bool? reviewNeeded, bool sortReviewFirst = false}) {
    if (query.isEmpty) {
      return watchAllBooks(reviewNeeded: reviewNeeded, sortReviewFirst: sortReviewFirst);
    }
    // Escape special FTS5 characters and prepare query
    // Remove hyphens for better ISBN matching
    final escapedQuery = query
        .replaceAll('"', '""')
        .replaceAll('*', '')
        .replaceAll(':', '')
        .replaceAll('-', ' ');
    // Build WHERE clause
    final whereClause = reviewNeeded != null
        ? 'WHERE books_fts MATCH ? AND b.review_needed = ?'
        : 'WHERE books_fts MATCH ?';
    // Build ORDER BY clause
    final orderByClause = sortReviewFirst
        ? 'ORDER BY b.review_needed DESC, b.added_date DESC'
        : 'ORDER BY b.added_date DESC';
    // Build variables list
    final variables = reviewNeeded != null
        ? [Variable.withString('$escapedQuery*'), Variable.withBool(reviewNeeded)]
        : [Variable.withString('$escapedQuery*')];
    // Use FTS5 MATCH query with prefix matching
    return customSelect(
      '''SELECT b.* FROM books b
         INNER JOIN books_fts fts ON b.rowid = fts.rowid
         $whereClause
         $orderByClause''',
      variables: variables,
      readsFrom: {books},
    ).watch().map((rows) {
      return rows.map((row) => books.map(row.data)).toList();
    });
  }
  Future<List<Book>> searchBooksOnce(String query, {bool? reviewNeeded, bool sortReviewFirst = false}) {
    if (query.isEmpty) {
      return getAllBooks(reviewNeeded: reviewNeeded, sortReviewFirst: sortReviewFirst);
    }
    final escapedQuery = query
        .replaceAll('"', '""')
        .replaceAll('*', '')
        .replaceAll(':', '')
        .replaceAll('-', ' ');
    // Build WHERE clause
    final whereClause = reviewNeeded != null
        ? 'WHERE books_fts MATCH ? AND b.review_needed = ?'
        : 'WHERE books_fts MATCH ?';
    // Build ORDER BY clause
    final orderByClause = sortReviewFirst
        ? 'ORDER BY b.review_needed DESC, b.added_date DESC'
        : 'ORDER BY b.added_date DESC';
    final variables = reviewNeeded != null
        ? [Variable.withString('$escapedQuery*'), Variable.withBool(reviewNeeded)]
        : [Variable.withString('$escapedQuery*')];
    return customSelect(
      '''SELECT b.* FROM books b
         INNER JOIN books_fts fts ON b.rowid = fts.rowid
         $whereClause
         $orderByClause''',
      variables: variables,
      readsFrom: {books},
    ).map((row) => books.map(row.data)).get();
  }
  // Delete multiple books by ISBN
  Future<int> deleteBooks(List<String> isbns) async {
    if (isbns.isEmpty) return 0;
    return (delete(books)..where((t) => t.isbn.isIn(isbns))).go();
  }
  // Save a failed scan to the database
  Future<void> saveFailedScan({
    required String jobId,
    required String imagePath,
    required String errorMessage,
    Duration retentionPeriod = const Duration(days: 7),
  }) async {
    final now = DateTime.now().millisecondsSinceEpoch;
    final expiresAt = now + retentionPeriod.inMilliseconds;
    final failedScan = FailedScansCompanion(
      jobId: Value(jobId),
      imagePath: Value(imagePath),
      errorMessage: Value(errorMessage),
      createdAt: Value(now),
      expiresAt: Value(expiresAt),
    );
    await into(failedScans).insert(failedScan);
  }
  // Get a failed scan by job ID
  Future<FailedScan?> getFailedScan(String jobId) async {
    final query = select(failedScans)..where((t) => t.jobId.equals(jobId));
    return query.getSingleOrNull();
  }
  // Delete a failed scan by job ID
  Future<void> deleteFailedScan(String jobId) async {
    await (delete(failedScans)..where((t) => t.jobId.equals(jobId))).go();
  }
}
LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    // Ensure FTS5 is available
    if (Platform.isAndroid) {
      await applyWorkaroundToOpenSqlite3OnOldAndroidVersions();
    }
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'wingtip.db'));
    return NativeDatabase(
      file,
      setup: (database) {
        database.execute('PRAGMA compile_options');
      },
    );
  });
}
</file>

<file path="lib/features/library/library_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:google_fonts/google_fonts.dart';
import '../../core/theme.dart';
import '../../data/database.dart';
import '../../data/database_provider.dart';
import 'library_provider.dart';
import 'book_detail_bottom_sheet.dart';
import 'widgets/empty_library_state.dart';
class LibraryScreen extends ConsumerStatefulWidget {
  const LibraryScreen({super.key});
  @override
  ConsumerState<LibraryScreen> createState() => _LibraryScreenState();
}
class _LibraryScreenState extends ConsumerState<LibraryScreen> {
  final Set<String> _seenBookIsbns = {};
  final TextEditingController _searchController = TextEditingController();
  @override
  void initState() {
    super.initState();
    _searchController.addListener(_onSearchChanged);
  }
  @override
  void dispose() {
    _searchController.removeListener(_onSearchChanged);
    _searchController.dispose();
    super.dispose();
  }
  void _onSearchChanged() {
    ref.read(searchQueryProvider.notifier).setQuery(_searchController.text);
  }
  Future<void> _showDeleteConfirmation(BuildContext context, int count) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: AppTheme.borderGray,
        title: Text(
          'Delete $count ${count == 1 ? 'book' : 'books'}?',
          style: const TextStyle(color: AppTheme.textPrimary),
        ),
        content: Text(
          'This action cannot be undone.',
          style: const TextStyle(color: AppTheme.textSecondary),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text(
              'Cancel',
              style: TextStyle(color: AppTheme.textSecondary),
            ),
          ),
          TextButton(
            onPressed: () => Navigator.of(context).pop(true),
            child: const Text(
              'Delete',
              style: TextStyle(color: AppTheme.internationalOrange),
            ),
          ),
        ],
      ),
    );
    if (confirmed == true && context.mounted) {
      final selectedBooks = ref.read(selectedBooksProvider);
      final database = ref.read(databaseProvider);
      await database.deleteBooks(selectedBooks.toList());
      ref.read(selectModeProvider.notifier).disable();
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Deleted $count ${count == 1 ? 'book' : 'books'}'),
            backgroundColor: AppTheme.borderGray,
          ),
        );
      }
    }
  }
  @override
  Widget build(BuildContext context) {
    final booksAsync = ref.watch(booksProvider);
    final selectMode = ref.watch(selectModeProvider);
    final selectedBooks = ref.watch(selectedBooksProvider);
    return Scaffold(
      backgroundColor: AppTheme.oledBlack,
      appBar: AppBar(
        title: Text(selectMode ? '${selectedBooks.length} selected' : 'Library'),
        backgroundColor: AppTheme.oledBlack,
        elevation: 0,
        leading: selectMode
            ? IconButton(
                icon: const Icon(Icons.close),
                onPressed: () {
                  ref.read(selectModeProvider.notifier).disable();
                },
              )
            : null,
        actions: selectMode && selectedBooks.isNotEmpty
            ? [
                IconButton(
                  icon: const Icon(Icons.delete),
                  onPressed: () => _showDeleteConfirmation(context, selectedBooks.length),
                ),
              ]
            : null,
        bottom: PreferredSize(
          preferredSize: const Size.fromHeight(1),
          child: Container(
            color: AppTheme.borderGray,
            height: 1,
          ),
        ),
      ),
      body: Column(
        children: [
          Padding(
            padding: const EdgeInsets.all(16),
            child: TextField(
              controller: _searchController,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    color: AppTheme.textPrimary,
                  ),
              decoration: InputDecoration(
                hintText: 'Search by title, author, or ISBN...',
                hintStyle: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      color: AppTheme.textSecondary,
                    ),
                prefixIcon: const Icon(
                  Icons.search,
                  color: AppTheme.textSecondary,
                ),
                suffixIcon: _searchController.text.isNotEmpty
                    ? IconButton(
                        icon: const Icon(
                          Icons.clear,
                          color: AppTheme.textSecondary,
                        ),
                        onPressed: () {
                          _searchController.clear();
                        },
                      )
                    : null,
                filled: true,
                fillColor: AppTheme.borderGray.withValues(alpha: 0.3),
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8),
                  borderSide: BorderSide.none,
                ),
                contentPadding: const EdgeInsets.symmetric(
                  horizontal: 16,
                  vertical: 12,
                ),
              ),
            ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 0),
            child: Row(
              children: [
                Expanded(
                  child: Consumer(
                    builder: (context, ref, child) {
                      final reviewFilter = ref.watch(reviewNeededFilterProvider);
                      return OutlinedButton.icon(
                        onPressed: () {
                          ref.read(reviewNeededFilterProvider.notifier).toggleNeedsReview();
                        },
                        icon: Icon(
                          reviewFilter == true ? Icons.filter_alt : Icons.filter_alt_outlined,
                          size: 16,
                        ),
                        label: const Text('Needs Review'),
                        style: OutlinedButton.styleFrom(
                          foregroundColor: reviewFilter == true
                              ? AppTheme.internationalOrange
                              : AppTheme.textSecondary,
                          side: BorderSide(
                            color: reviewFilter == true
                                ? AppTheme.internationalOrange
                                : AppTheme.borderGray,
                          ),
                          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                        ),
                      );
                    },
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Consumer(
                    builder: (context, ref, child) {
                      final sortReviewFirst = ref.watch(sortReviewFirstProvider);
                      return OutlinedButton.icon(
                        onPressed: () {
                          ref.read(sortReviewFirstProvider.notifier).toggle();
                        },
                        icon: Icon(
                          sortReviewFirst ? Icons.sort : Icons.sort_outlined,
                          size: 16,
                        ),
                        label: const Text('Review First'),
                        style: OutlinedButton.styleFrom(
                          foregroundColor: sortReviewFirst
                              ? AppTheme.internationalOrange
                              : AppTheme.textSecondary,
                          side: BorderSide(
                            color: sortReviewFirst
                                ? AppTheme.internationalOrange
                                : AppTheme.borderGray,
                          ),
                          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                        ),
                      );
                    },
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 8),
          Expanded(
            child: booksAsync.when(
              data: (books) {
                if (books.isEmpty) {
                  final searchQuery = ref.watch(searchQueryProvider);
                  if (searchQuery.isEmpty) {
                    return const EmptyLibraryState();
                  }
                  return Center(
                    child: Text(
                      'No books found',
                      style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                            color: AppTheme.textSecondary,
                          ),
                    ),
                  );
                }
                return GridView.builder(
            padding: const EdgeInsets.all(16),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 3,
              childAspectRatio: 1 / 1.5,
              crossAxisSpacing: 12,
              mainAxisSpacing: 12,
            ),
            itemCount: books.length,
            itemBuilder: (context, index) {
              final book = books[index];
              final isNew = !_seenBookIsbns.contains(book.isbn);
              if (isNew) {
                _seenBookIsbns.add(book.isbn);
              }
              return AnimatedBookCard(
                key: ValueKey(book.isbn),
                book: book,
                isNew: isNew,
              );
            },
          );
        },
        loading: () => const Center(
          child: CircularProgressIndicator(
            color: AppTheme.internationalOrange,
          ),
        ),
        error: (error, stack) => Center(
          child: Text(
            'Error loading books',
            style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                  color: AppTheme.textSecondary,
                ),
          ),
        ),
      ),
    ),
        ],
      ),
    );
  }
}
class AnimatedBookCard extends StatefulWidget {
  final Book book;
  final bool isNew;
  const AnimatedBookCard({
    super.key,
    required this.book,
    required this.isNew,
  });
  @override
  State<AnimatedBookCard> createState() => _AnimatedBookCardState();
}
class _AnimatedBookCardState extends State<AnimatedBookCard>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _fadeAnimation;
  late Animation<Offset> _slideAnimation;
  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 200),
      vsync: this,
    );
    _fadeAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeOut,
    ));
    _slideAnimation = Tween<Offset>(
      begin: const Offset(0, 0.3),
      end: Offset.zero,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeOut,
    ));
    if (widget.isNew) {
      _controller.forward();
    } else {
      _controller.value = 1.0;
    }
  }
  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }
  @override
  Widget build(BuildContext context) {
    return FadeTransition(
      opacity: _fadeAnimation,
      child: SlideTransition(
        position: _slideAnimation,
        child: BookCard(book: widget.book),
      ),
    );
  }
}
class BookCard extends ConsumerWidget {
  final Book book;
  const BookCard({super.key, required this.book});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final selectMode = ref.watch(selectModeProvider);
    final selectedBooks = ref.watch(selectedBooksProvider);
    final isSelected = selectedBooks.contains(book.isbn);
    return GestureDetector(
      onTap: () {
        if (selectMode) {
          ref.read(selectedBooksProvider.notifier).toggle(book.isbn);
        } else {
          BookDetailBottomSheet.show(context, book);
        }
      },
      onLongPress: () {
        if (!selectMode) {
          ref.read(selectModeProvider.notifier).enable();
          ref.read(selectedBooksProvider.notifier).toggle(book.isbn);
        }
      },
      child: Container(
        decoration: BoxDecoration(
          border: Border.all(
            color: selectMode && isSelected ? AppTheme.internationalOrange : Colors.white,
            width: selectMode && isSelected ? 2 : 1,
          ),
          borderRadius: BorderRadius.circular(4),
        ),
        child: ClipRRect(
          borderRadius: BorderRadius.circular(3),
          child: AspectRatio(
            aspectRatio: 1 / 1.5,
            child: Stack(
              children: [
                book.coverUrl != null && book.coverUrl!.isNotEmpty
                    ? CachedNetworkImage(
                        imageUrl: book.coverUrl!,
                        fit: BoxFit.cover,
                        placeholder: (context, url) => Container(
                          color: AppTheme.borderGray,
                          child: const Center(
                            child: CircularProgressIndicator(
                              color: AppTheme.internationalOrange,
                              strokeWidth: 2,
                            ),
                          ),
                        ),
                        errorWidget: (context, url, error) => _buildFallbackCard(),
                      )
                    : _buildFallbackCard(),
                if (book.reviewNeeded && !selectMode)
                  Positioned(
                    top: 4,
                    right: 4,
                    child: Container(
                      width: 20,
                      height: 20,
                      decoration: const BoxDecoration(
                        color: Color(0xFFFFCC00),
                        shape: BoxShape.circle,
                      ),
                      child: const Icon(
                        Icons.warning,
                        size: 14,
                        color: Colors.black,
                      ),
                    ),
                  ),
                if (selectMode)
                  Positioned(
                    top: 4,
                    right: 4,
                    child: Container(
                      width: 24,
                      height: 24,
                      decoration: BoxDecoration(
                        color: isSelected ? AppTheme.internationalOrange : AppTheme.borderGray,
                        shape: BoxShape.circle,
                        border: Border.all(
                          color: Colors.white,
                          width: 2,
                        ),
                      ),
                      child: isSelected
                          ? const Icon(
                              Icons.check,
                              size: 16,
                              color: Colors.white,
                            )
                          : null,
                    ),
                  ),
              ],
            ),
          ),
        ),
      ),
    );
  }
  Widget _buildFallbackCard() {
    return Container(
      color: AppTheme.borderGray,
      padding: const EdgeInsets.all(8),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          Flexible(
            child: Text(
              book.title,
              style: GoogleFonts.jetBrainsMono(
                fontSize: 12,
                fontWeight: FontWeight.w500,
                color: AppTheme.textPrimary,
                letterSpacing: 0,
              ),
              textAlign: TextAlign.center,
              maxLines: 3,
              overflow: TextOverflow.ellipsis,
            ),
          ),
          const SizedBox(height: 8),
          Flexible(
            child: Text(
              book.author,
              style: GoogleFonts.jetBrainsMono(
                fontSize: 10,
                fontWeight: FontWeight.w400,
                color: AppTheme.textSecondary,
                letterSpacing: 0,
              ),
              textAlign: TextAlign.center,
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="lib/main.dart">
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:wingtip/core/theme.dart';
import 'package:wingtip/features/camera/camera_screen.dart';
import 'package:wingtip/features/camera/camera_service.dart';
import 'package:wingtip/features/camera/permission_primer_screen.dart';
import 'package:flutter_native_splash/flutter_native_splash.dart';
void main() async {
  WidgetsBinding widgetsBinding = WidgetsFlutterBinding.ensureInitialized();
  FlutterNativeSplash.preserve(widgetsBinding: widgetsBinding);
  final appStartTime = DateTime.now();
  debugPrint('[Performance] App started at ${appStartTime.toIso8601String()}');
  SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersive);
  final splashTimer = Future.delayed(const Duration(milliseconds: 500));
  final cameraPermissionStatus = await Permission.camera.status;
  if (cameraPermissionStatus.isGranted) {
    final cameraService = CameraService();
    final cameraInitFuture = cameraService.initialize();
    debugPrint('[Performance] Camera initialization started');
    await Future.wait([cameraInitFuture, splashTimer]);
    final coldStartTime = DateTime.now().difference(appStartTime);
    debugPrint('[Performance] Cold start completed in ${coldStartTime.inMilliseconds}ms');
    if (cameraService.initializationDuration != null) {
      debugPrint('[Performance] Camera initialization took ${cameraService.initializationDuration!.inMilliseconds}ms');
    }
  } else {
    await splashTimer;
    debugPrint('[Performance] Camera permission not granted, showing primer screen');
  }
  runApp(ProviderScope(child: MyApp(hasPermission: cameraPermissionStatus.isGranted)));
}
class MyApp extends StatefulWidget {
  final bool hasPermission;
  const MyApp({super.key, required this.hasPermission});
  @override
  State<MyApp> createState() => _MyAppState();
}
class _MyAppState extends State<MyApp> {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      FlutterNativeSplash.remove();
    });
  }
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Wingtip',
      theme: AppTheme.darkTheme,
      themeMode: ThemeMode.dark,
      home: widget.hasPermission ? const CameraScreen() : const PermissionPrimerScreen(),
    );
  }
}
</file>

<file path="lib/features/camera/camera_screen.dart">
import 'dart:async';
import 'package:camera/camera.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wingtip/core/theme.dart';
import 'package:wingtip/features/camera/camera_provider.dart';
import 'package:wingtip/features/camera/image_processor.dart';
import 'package:wingtip/features/talaria/job_state.dart';
import 'package:wingtip/features/talaria/processing_stack_widget.dart';
import 'package:wingtip/features/talaria/job_state_provider.dart';
import 'package:wingtip/features/library/library_screen.dart';
import 'package:wingtip/widgets/error_snack_bar.dart';
class CameraScreen extends ConsumerStatefulWidget {
  const CameraScreen({super.key});
  @override
  ConsumerState<CameraScreen> createState() => _CameraScreenState();
}
class _CameraScreenState extends ConsumerState<CameraScreen> {
  bool _showFlash = false;
  double _currentZoom = 1.0;
  double _minZoom = 1.0;
  double _maxZoom = 4.0;
  double _baseScale = 1.0;
  Offset? _focusPoint;
  bool _showFocusIndicator = false;
  Timer? _countdownTimer;
  final Set<String> _shownErrorJobIds = {};
  @override
  void initState() {
    super.initState();
    _initializeZoomLevels();
    _startCountdownTimer();
    _setupJobErrorListener();
  }
  void _setupJobErrorListener() {
    ref.listenManual(jobStateProvider, (previous, next) {
      if (!mounted) return;
      for (final job in next.jobs) {
        if (job.status == JobStatus.error &&
            job.errorMessage != null &&
            !_shownErrorJobIds.contains(job.id)) {
          _shownErrorJobIds.add(job.id);
          ErrorSnackBar.show(
            context,
            message: job.errorMessage!,
          );
        }
      }
    });
  }
  @override
  void dispose() {
    _countdownTimer?.cancel();
    super.dispose();
  }
  void _startCountdownTimer() {
    _countdownTimer = Timer.periodic(const Duration(seconds: 1), (_) {
      if (mounted) {
        setState(() {
        });
      }
    });
  }
  Future<void> _initializeZoomLevels() async {
    final cameraService = ref.read(cameraServiceProvider);
    if (cameraService.controller != null) {
      final maxZoom = await cameraService.controller!.getMaxZoomLevel();
      final minZoom = await cameraService.controller!.getMinZoomLevel();
      setState(() {
        _maxZoom = maxZoom.clamp(1.0, 4.0);
        _minZoom = minZoom;
      });
    }
  }
  void _handleScaleStart(ScaleStartDetails details) {
    _baseScale = _currentZoom;
  }
  void _handleScaleUpdate(ScaleUpdateDetails details) {
    final cameraService = ref.read(cameraServiceProvider);
    if (cameraService.controller == null) return;
    final newZoom = (_baseScale * details.scale).clamp(_minZoom, _maxZoom);
    if (newZoom != _currentZoom) {
      setState(() {
        _currentZoom = newZoom;
      });
      cameraService.controller!.setZoomLevel(_currentZoom);
    }
  }
  void _handleTapUp(TapUpDetails details, BoxConstraints constraints) async {
    final cameraService = ref.read(cameraServiceProvider);
    if (cameraService.controller == null) return;
    final offset = Offset(
      details.localPosition.dx / constraints.maxWidth,
      details.localPosition.dy / constraints.maxHeight,
    );
    try {
      await cameraService.controller!.setFocusPoint(offset);
      await cameraService.controller!.setExposurePoint(offset);
      setState(() {
        _focusPoint = details.localPosition;
        _showFocusIndicator = true;
      });
      HapticFeedback.selectionClick();
      Future.delayed(const Duration(seconds: 1), () {
        if (mounted) {
          setState(() {
            _showFocusIndicator = false;
          });
        }
      });
    } catch (e) {
      debugPrint('[CameraScreen] Error setting focus: $e');
    }
  }
  Future<void> _onShutterTap() async {
    HapticFeedback.lightImpact();
    setState(() {
      _showFlash = true;
    });
    Future.delayed(const Duration(milliseconds: 100), () {
      if (mounted) {
        setState(() {
          _showFlash = false;
        });
      }
    });
    try {
      final cameraService = ref.read(cameraServiceProvider);
      if (cameraService.controller == null) {
        debugPrint('[CameraScreen] Cannot capture: camera not initialized');
        return;
      }
      final XFile image = await cameraService.controller!.takePicture();
      debugPrint('[CameraScreen] Image captured: ${image.path}');
      final result = await ImageProcessor.processImage(image.path);
      debugPrint('[CameraScreen] Image processed successfully:');
      debugPrint('  - Output: ${result.outputPath}');
      debugPrint('  - Processing time: ${result.processingTimeMs}ms');
      debugPrint('  - Size reduction: ${result.originalSize} -> ${result.processedSize} bytes');
      final jobStateNotifier = ref.read(jobStateProvider.notifier);
      await jobStateNotifier.uploadImage(result.outputPath);
    } catch (e) {
      debugPrint('[CameraScreen] Error capturing/processing image: $e');
    }
  }
  @override
  Widget build(BuildContext context) {
    final cameraService = ref.watch(cameraServiceProvider);
    return Scaffold(
      backgroundColor: Colors.black,
      body: Stack(
        children: [
          _buildBody(cameraService),
          if (_showFlash) _buildFlashOverlay(),
          if (cameraService.isInitialized && cameraService.controller != null) ...[
            const ProcessingStackWidget(),
            _buildShutterButton(),
            _buildZoomIndicator(),
            if (_showFocusIndicator && _focusPoint != null)
              _buildFocusIndicator(),
          ],
          _buildLibraryButton(context),
          _buildRateLimitOverlay(),
        ],
      ),
    );
  }
  Widget _buildBody(dynamic cameraService) {
    if (cameraService.errorMessage != null) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Text(
            cameraService.errorMessage!,
            style: const TextStyle(color: Colors.white),
            textAlign: TextAlign.center,
          ),
        ),
      );
    }
    if (!cameraService.isInitialized || cameraService.controller == null) {
      return const Center(
        child: CircularProgressIndicator(
          valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
        ),
      );
    }
    return LayoutBuilder(
      builder: (context, constraints) {
        return GestureDetector(
          onScaleStart: _handleScaleStart,
          onScaleUpdate: _handleScaleUpdate,
          onTapUp: (details) => _handleTapUp(details, constraints),
          child: CameraPreview(cameraService.controller!),
        );
      },
    );
  }
  Widget _buildFlashOverlay() {
    return AnimatedOpacity(
      opacity: _showFlash ? 1.0 : 0.0,
      duration: const Duration(milliseconds: 100),
      child: Container(
        width: double.infinity,
        height: double.infinity,
        color: Colors.white,
      ),
    );
  }
  Widget _buildShutterButton() {
    final jobState = ref.watch(jobStateProvider);
    final isRateLimited = jobState.rateLimit?.isActive ?? false;
    return Positioned(
      left: 0,
      right: 0,
      bottom: 40,
      child: Center(
        child: GestureDetector(
          onTap: isRateLimited ? null : _onShutterTap,
          child: Container(
            width: 80,
            height: 80,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              border: Border.all(
                color: isRateLimited ? Colors.white.withValues(alpha: 0.3) : Colors.white,
                width: 4,
              ),
            ),
          ),
        ),
      ),
    );
  }
  Widget _buildLibraryButton(BuildContext context) {
    return Positioned(
      top: 48,
      right: 16,
      child: GestureDetector(
        onTap: () {
          Navigator.of(context).push(
            MaterialPageRoute(
              builder: (context) => const LibraryScreen(),
            ),
          );
        },
        child: Container(
          width: 48,
          height: 48,
          decoration: BoxDecoration(
            color: AppTheme.borderGray,
            borderRadius: BorderRadius.circular(8),
            border: Border.all(
              color: Colors.white,
              width: 1,
            ),
          ),
          child: const Icon(
            Icons.grid_view_rounded,
            color: AppTheme.textPrimary,
            size: 24,
          ),
        ),
      ),
    );
  }
  Widget _buildZoomIndicator() {
    return Positioned(
      top: 48,
      left: 16,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
        decoration: BoxDecoration(
          color: Colors.black.withValues(alpha: 0.5),
          borderRadius: BorderRadius.circular(8),
          border: Border.all(
            color: Colors.white.withValues(alpha: 0.3),
            width: 1,
          ),
        ),
        child: Text(
          '${_currentZoom.toStringAsFixed(1)}x',
          style: const TextStyle(
            color: Colors.white,
            fontSize: 14,
            fontWeight: FontWeight.w500,
          ),
        ),
      ),
    );
  }
  Widget _buildFocusIndicator() {
    return Positioned(
      left: _focusPoint!.dx - 30,
      top: _focusPoint!.dy - 30,
      child: IgnorePointer(
        child: AnimatedOpacity(
          opacity: _showFocusIndicator ? 1.0 : 0.0,
          duration: const Duration(milliseconds: 200),
          child: Container(
            width: 60,
            height: 60,
            decoration: BoxDecoration(
              border: Border.all(
                color: Colors.white,
                width: 2,
              ),
            ),
            child: Stack(
              children: [
                Positioned(
                  left: 0,
                  top: 0,
                  child: CustomPaint(
                    size: const Size(12, 12),
                    painter: _BracketPainter(
                      color: Colors.white,
                      position: BracketPosition.topLeft,
                    ),
                  ),
                ),
                Positioned(
                  right: 0,
                  top: 0,
                  child: CustomPaint(
                    size: const Size(12, 12),
                    painter: _BracketPainter(
                      color: Colors.white,
                      position: BracketPosition.topRight,
                    ),
                  ),
                ),
                Positioned(
                  left: 0,
                  bottom: 0,
                  child: CustomPaint(
                    size: const Size(12, 12),
                    painter: _BracketPainter(
                      color: Colors.white,
                      position: BracketPosition.bottomLeft,
                    ),
                  ),
                ),
                Positioned(
                  right: 0,
                  bottom: 0,
                  child: CustomPaint(
                    size: const Size(12, 12),
                    painter: _BracketPainter(
                      color: Colors.white,
                      position: BracketPosition.bottomRight,
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
  Widget _buildRateLimitOverlay() {
    final jobState = ref.watch(jobStateProvider);
    final rateLimit = jobState.rateLimit;
    if (rateLimit == null || !rateLimit.isActive) {
      return const SizedBox.shrink();
    }
    final remainingMs = rateLimit.remainingMs;
    final hours = remainingMs ~/ (1000 * 60 * 60);
    final minutes = (remainingMs % (1000 * 60 * 60)) ~/ (1000 * 60);
    final seconds = (remainingMs % (1000 * 60)) ~/ 1000;
    final timeString = '${hours.toString().padLeft(2, '0')}:${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';
    return Positioned.fill(
      child: Container(
        color: Colors.black.withValues(alpha: 0.7),
        child: Center(
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
            decoration: BoxDecoration(
              color: Colors.black.withValues(alpha: 0.9),
              borderRadius: BorderRadius.circular(12),
              border: Border.all(
                color: Colors.white.withValues(alpha: 0.3),
                width: 1,
              ),
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Text(
                  'LIMIT REACHED',
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    letterSpacing: 1.2,
                  ),
                ),
                const SizedBox(height: 8),
                const Text(
                  'RESETS IN',
                  style: TextStyle(
                    color: Colors.white70,
                    fontSize: 14,
                    letterSpacing: 1.0,
                  ),
                ),
                const SizedBox(height: 12),
                Text(
                  timeString,
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 32,
                    fontWeight: FontWeight.bold,
                    fontFeatures: [FontFeature.tabularFigures()],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
enum BracketPosition {
  topLeft,
  topRight,
  bottomLeft,
  bottomRight,
}
class _BracketPainter extends CustomPainter {
  final Color color;
  final BracketPosition position;
  _BracketPainter({
    required this.color,
    required this.position,
  });
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;
    final path = Path();
    switch (position) {
      case BracketPosition.topLeft:
        path.moveTo(size.width, 0);
        path.lineTo(0, 0);
        path.lineTo(0, size.height);
        break;
      case BracketPosition.topRight:
        path.moveTo(0, 0);
        path.lineTo(size.width, 0);
        path.lineTo(size.width, size.height);
        break;
      case BracketPosition.bottomLeft:
        path.moveTo(0, 0);
        path.lineTo(0, size.height);
        path.lineTo(size.width, size.height);
        break;
      case BracketPosition.bottomRight:
        path.moveTo(size.width, 0);
        path.lineTo(size.width, size.height);
        path.lineTo(0, size.height);
        break;
    }
    canvas.drawPath(path, paint);
  }
  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}
</file>

<file path="lib/features/talaria/job_state_notifier.dart">
import 'dart:async';
import 'dart:io';
import 'package:dio/dio.dart';
import 'package:drift/drift.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:flutter_cache_manager/flutter_cache_manager.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:wingtip/core/failed_scans_directory.dart';
import 'package:wingtip/core/sse_client.dart';
import 'package:wingtip/core/sse_client_provider.dart';
import 'package:wingtip/core/talaria_client_provider.dart';
import 'package:wingtip/data/database.dart';
import 'package:wingtip/data/database_provider.dart';
import 'package:wingtip/features/talaria/job_state.dart';
class JobStateNotifier extends Notifier<JobState> {
  final Map<String, StreamSubscription<SseEvent>> _sseSubscriptions = {};
  final Map<String, Timer> _autoRemoveTimers = {};
  Timer? _rateLimitTimer;
  @override
  JobState build() {
    ref.onDispose(() {
      for (final subscription in _sseSubscriptions.values) {
        subscription.cancel();
      }
      _sseSubscriptions.clear();
      for (final timer in _autoRemoveTimers.values) {
        timer.cancel();
      }
      _autoRemoveTimers.clear();
      _rateLimitTimer?.cancel();
    });
    return JobState.idle();
  }
  Future<void> uploadImage(String imagePath) async {
    ScanJob? job;
    try {
      job = ScanJob.uploading(imagePath);
      state = state.copyWith(
        jobs: [...state.jobs, job],
      );
      debugPrint('[JobStateNotifier] Created job ${job.id}: $imagePath');
      final client = await ref.read(talariaClientProvider.future);
      final response = await client.uploadImage(imagePath);
      debugPrint('[JobStateNotifier] Upload successful for job ${job.id}:');
      debugPrint('  - Job ID: ${response.jobId}');
      debugPrint('  - Stream URL: ${response.streamUrl}');
      _updateJob(
        job.id,
        job.copyWith(
          jobId: response.jobId,
          streamUrl: response.streamUrl,
          status: JobStatus.listening,
        ),
      );
      await _listenToStream(job.id, response.jobId, response.streamUrl);
    } on DioException catch (e) {
      debugPrint('[JobStateNotifier] DioException during upload: ${e.type}');
      await _handleNetworkError(e, job, imagePath);
    } on SocketException catch (e) {
      debugPrint('[JobStateNotifier] SocketException during upload: $e');
      await _handleNetworkError(e, job, imagePath);
    } on TimeoutException catch (e) {
      debugPrint('[JobStateNotifier] TimeoutException during upload: $e');
      await _handleNetworkError(e, job, imagePath);
    } catch (e) {
      debugPrint('[JobStateNotifier] Upload failed: $e');
      if (e.toString().contains('RateLimitException')) {
        _handleRateLimitError(e);
      } else {
        HapticFeedback.heavyImpact();
        if (job != null) {
          _updateJob(
            job.id,
            job.copyWith(
              status: JobStatus.error,
              errorMessage: e.toString(),
            ),
          );
        }
      }
    }
  }
  void _handleRateLimitError(dynamic error) {
    debugPrint('[JobStateNotifier] Rate limit hit: $error');
    HapticFeedback.heavyImpact();
    int retryAfterMs = 60000;
    final errorStr = error.toString();
    final match = RegExp(r'retry after (\d+)ms').firstMatch(errorStr);
    if (match != null) {
      retryAfterMs = int.tryParse(match.group(1) ?? '') ?? 60000;
    }
    // Set rate limit state
    final expiresAt = DateTime.now().add(Duration(milliseconds: retryAfterMs));
    state = state.copyWith(
      rateLimit: RateLimitInfo(
        expiresAt: expiresAt,
        retryAfterMs: retryAfterMs,
      ),
    );
    // Remove the failed job from the queue
    if (state.jobs.isNotEmpty) {
      final lastJob = state.jobs.last;
      _removeJob(lastJob.id);
    }
    // Schedule rate limit clear
    _rateLimitTimer?.cancel();
    _rateLimitTimer = Timer(Duration(milliseconds: retryAfterMs), () {
      debugPrint('[JobStateNotifier] Rate limit expired, clearing');
      state = state.clearRateLimit();
    });
  }
  Future<void> _handleNetworkError(
    dynamic error,
    ScanJob? job,
    String imagePath,
  ) async {
    HapticFeedback.heavyImpact();
    String errorMessage;
    String? serverJobId;
    if (error is DioException) {
      switch (error.type) {
        case DioExceptionType.connectionTimeout:
        case DioExceptionType.sendTimeout:
        case DioExceptionType.receiveTimeout:
          errorMessage = 'Upload timed out after 30s';
        case DioExceptionType.connectionError:
          errorMessage = 'Server unreachable';
        case DioExceptionType.badResponse:
          errorMessage = 'Server error: ${error.response?.statusCode ?? "unknown"}';
        case DioExceptionType.cancel:
          errorMessage = 'Upload cancelled';
        default:
          errorMessage = 'No internet connection';
      }
    } else if (error is SocketException) {
      errorMessage = 'No internet connection';
    } else if (error is TimeoutException) {
      errorMessage = 'Upload timed out after 30s';
    } else {
      errorMessage = error.toString();
    }
    debugPrint('[JobStateNotifier] Network error: $errorMessage');
    if (job != null) {
      _updateJob(
        job.id,
        job.copyWith(
          status: JobStatus.error,
          errorMessage: errorMessage,
        ),
      );
      serverJobId = job.id;
    }
    if (serverJobId != null) {
      await _saveFailedScan(serverJobId, imagePath, errorMessage);
    }
  }
  void _updateJob(String jobId, ScanJob updatedJob) {
    final jobs = state.jobs;
    final index = jobs.indexWhere((job) => job.id == jobId);
    if (index != -1) {
      final updatedJobs = List<ScanJob>.from(jobs);
      updatedJobs[index] = updatedJob;
      state = state.copyWith(jobs: updatedJobs);
    }
  }
  void _removeJob(String jobId) {
    final jobs = state.jobs.where((job) => job.id != jobId).toList();
    state = state.copyWith(jobs: jobs);
    _autoRemoveTimers[jobId]?.cancel();
    _autoRemoveTimers.remove(jobId);
  }
  void _scheduleAutoRemove(String jobId) {
    _autoRemoveTimers[jobId]?.cancel();
    _autoRemoveTimers[jobId] = Timer(const Duration(seconds: 5), () {
      debugPrint('[JobStateNotifier] Auto-removing job $jobId');
      _removeJob(jobId);
    });
  }
  Future<void> _listenToStream(
    String jobId,
    String serverJobId,
    String streamUrl,
  ) async {
    try {
      await _sseSubscriptions[jobId]?.cancel();
      final sseClient = ref.read(sseClientProvider);
      debugPrint('[JobStateNotifier] Starting SSE stream for job: $jobId');
      _sseSubscriptions[jobId] = sseClient.listen(streamUrl).listen(
        (event) {
          _handleSseEvent(event, jobId, serverJobId);
        },
        onError: (error) {
          debugPrint('[JobStateNotifier] SSE stream error for job $jobId: $error');
          HapticFeedback.heavyImpact();
          final job = state.getJobById(jobId);
          if (job != null) {
            _updateJob(
              jobId,
              job.copyWith(
                status: JobStatus.error,
                errorMessage: error.toString(),
              ),
            );
          }
        },
        onDone: () {
          debugPrint('[JobStateNotifier] SSE stream closed for job $jobId');
        },
        cancelOnError: true,
      );
    } catch (e) {
      debugPrint('[JobStateNotifier] Failed to start SSE stream: $e');
      HapticFeedback.heavyImpact();
      final job = state.getJobById(jobId);
      if (job != null) {
        _updateJob(
          jobId,
          job.copyWith(
            status: JobStatus.error,
            errorMessage: e.toString(),
          ),
        );
      }
    }
  }
  Future<void> _handleSseEvent(
    SseEvent event,
    String jobId,
    String serverJobId,
  ) async {
    debugPrint('[JobStateNotifier] Handling SSE event for job $jobId: ${event.type}');
    final job = state.getJobById(jobId);
    if (job == null) {
      debugPrint('[JobStateNotifier] Job $jobId not found, ignoring event');
      return;
    }
    switch (event.type) {
      case SseEventType.progress:
        final progress = event.data['progress'] as num? ?? 0.0;
        final message = event.data['message'] as String?;
        _updateJob(
          jobId,
          job.copyWith(
            status: JobStatus.processing,
            progress: progress.toDouble(),
            progressMessage: message,
          ),
        );
      case SseEventType.result:
        final resultData = event.data;
        debugPrint('[JobStateNotifier] Received result for job $jobId: $resultData');
        await _saveBookResult(resultData, serverJobId);
        _updateJob(
          jobId,
          job.copyWith(result: resultData),
        );
      case SseEventType.complete:
        final resultData = event.data;
        debugPrint('[JobStateNotifier] Job $jobId completed: $resultData');
        _updateJob(
          jobId,
          job.copyWith(
            status: JobStatus.completed,
            result: resultData,
          ),
        );
        await _sseSubscriptions[jobId]?.cancel();
        _sseSubscriptions.remove(jobId);
        await _cleanupJob(serverJobId, job.imagePath);
        _scheduleAutoRemove(jobId);
      case SseEventType.error:
        final errorMessage = event.data['message'] as String? ?? 'Unknown error';
        debugPrint('[JobStateNotifier] Job $jobId error: $errorMessage');
        HapticFeedback.heavyImpact();
        _updateJob(
          jobId,
          job.copyWith(
            status: JobStatus.error,
            errorMessage: errorMessage,
          ),
        );
        _sseSubscriptions[jobId]?.cancel();
        _sseSubscriptions.remove(jobId);
        await _saveFailedScan(serverJobId, job.imagePath, errorMessage);
    }
  }
  Future<void> _saveFailedScan(
    String jobId,
    String imagePath,
    String errorMessage,
  ) async {
    try {
      final persistentPath = await FailedScansDirectory.moveImage(imagePath, jobId);
      debugPrint('[JobStateNotifier] Moved failed scan image to: $persistentPath');
      final database = ref.read(databaseProvider);
      await database.saveFailedScan(
        jobId: jobId,
        imagePath: persistentPath,
        errorMessage: errorMessage,
      );
      debugPrint('[JobStateNotifier] Failed scan saved: $jobId');
    } catch (e) {
      debugPrint('[JobStateNotifier] Failed to save failed scan: $e');
    }
  }
  Future<void> _saveBookResult(Map<String, dynamic> resultData, String serverJobId) async {
    try {
      final isbn = resultData['isbn'] as String?;
      final title = resultData['title'] as String?;
      final author = resultData['author'] as String?;
      final coverUrl = resultData['coverUrl'] as String?;
      final format = resultData['format'] as String?;
      final spineConfidence = resultData['spineConfidence'] as num?;
      if (isbn == null || isbn.isEmpty) {
        debugPrint('[JobStateNotifier] Missing ISBN, skipping save');
        return;
      }
      if (title == null || title.isEmpty) {
        debugPrint('[JobStateNotifier] Missing title, skipping save');
        return;
      }
      if (author == null || author.isEmpty) {
        debugPrint('[JobStateNotifier] Missing author, skipping save');
        return;
      }
      final book = BooksCompanion.insert(
        isbn: isbn,
        title: title,
        author: author,
        coverUrl: coverUrl != null && coverUrl.isNotEmpty
            ? Value(coverUrl)
            : const Value.absent(),
        format: format != null && format.isNotEmpty
            ? Value(format)
            : const Value.absent(),
        addedDate: DateTime.now().millisecondsSinceEpoch,
        spineConfidence: spineConfidence != null
            ? Value(spineConfidence.toDouble())
            : const Value.absent(),
      );
      final database = ref.read(databaseProvider);
      await database.into(database.books).insertOnConflictUpdate(book);
      debugPrint('[JobStateNotifier] Book saved: $isbn - $title');
      await _cleanupFailedScanIfExists(serverJobId);
      await HapticFeedback.mediumImpact();
      if (coverUrl != null && coverUrl.isNotEmpty) {
        await _prefetchCoverImage(coverUrl);
      }
    } catch (e) {
      debugPrint('[JobStateNotifier] Failed to save book: $e');
    }
  }
  Future<void> _cleanupFailedScanIfExists(String jobId) async {
    try {
      final database = ref.read(databaseProvider);
      final failedScan = await database.getFailedScan(jobId);
      if (failedScan != null) {
        debugPrint('[JobStateNotifier] Cleaning up failed scan for job: $jobId');
        await FailedScansDirectory.deleteImage(jobId);
        debugPrint('[JobStateNotifier] Deleted failed scan image');
        await database.deleteFailedScan(jobId);
        debugPrint('[JobStateNotifier] Deleted failed scan database entry');
      }
    } catch (e) {
      debugPrint('[JobStateNotifier] Failed to cleanup failed scan: $e');
    }
  }
  Future<void> _prefetchCoverImage(String imageUrl) async {
    try {
      debugPrint('[JobStateNotifier] Prefetching cover image: $imageUrl');
      await DefaultCacheManager().downloadFile(imageUrl);
      debugPrint('[JobStateNotifier] Cover image prefetched successfully');
    } catch (e) {
      debugPrint('[JobStateNotifier] Failed to prefetch cover image: $e');
    }
  }
  Future<void> _cleanupJob(String jobId, String imagePath) async {
    try {
      debugPrint('[JobStateNotifier] Starting cleanup for job: $jobId');
      final client = await ref.read(talariaClientProvider.future);
      await client.cleanupJob(jobId);
      debugPrint('[JobStateNotifier] Server cleanup successful');
      final imageFile = File(imagePath);
      if (await imageFile.exists()) {
        await imageFile.delete();
        debugPrint('[JobStateNotifier] Deleted temporary file: $imagePath');
      } else {
        debugPrint('[JobStateNotifier] Temporary file not found: $imagePath');
      }
      debugPrint('[JobStateNotifier] Cleanup completed successfully');
    } catch (e) {
      debugPrint('[JobStateNotifier] Cleanup failed: $e');
    }
  }
  void reset() {
    for (final subscription in _sseSubscriptions.values) {
      subscription.cancel();
    }
    _sseSubscriptions.clear();
    for (final timer in _autoRemoveTimers.values) {
      timer.cancel();
    }
    _autoRemoveTimers.clear();
    state = JobState.idle();
  }
}
</file>

<file path="pubspec.lock">
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  _fe_analyzer_shared:
    dependency: transitive
    description:
      name: _fe_analyzer_shared
      sha256: c209688d9f5a5f26b2fb47a188131a6fb9e876ae9e47af3737c0b4f58a93470d
      url: "https://pub.dev"
    source: hosted
    version: "91.0.0"
  analyzer:
    dependency: transitive
    description:
      name: analyzer
      sha256: f51c8499b35f9b26820cfe914828a6a98a94efd5cc78b37bb7d03debae3a1d08
      url: "https://pub.dev"
    source: hosted
    version: "8.4.1"
  ansicolor:
    dependency: transitive
    description:
      name: ansicolor
      sha256: "50e982d500bc863e1d703448afdbf9e5a72eb48840a4f766fa361ffd6877055f"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.3"
  archive:
    dependency: transitive
    description:
      name: archive
      sha256: "2fde1607386ab523f7a36bb3e7edb43bd58e6edaf2ffb29d8a6d578b297fdbbd"
      url: "https://pub.dev"
    source: hosted
    version: "4.0.7"
  args:
    dependency: transitive
    description:
      name: args
      sha256: d0481093c50b1da8910eb0bb301626d4d8eb7284aa739614d2b394ee09e3ea04
      url: "https://pub.dev"
    source: hosted
    version: "2.7.0"
  async:
    dependency: transitive
    description:
      name: async
      sha256: "758e6d74e971c3e5aceb4110bfd6698efc7f501675bcfe0c775459a8140750eb"
      url: "https://pub.dev"
    source: hosted
    version: "2.13.0"
  boolean_selector:
    dependency: transitive
    description:
      name: boolean_selector
      sha256: "8aab1771e1243a5063b8b0ff68042d67334e3feab9e95b9490f9a6ebf73b42ea"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  build:
    dependency: transitive
    description:
      name: build
      sha256: "275bf6bb2a00a9852c28d4e0b410da1d833a734d57d39d44f94bfc895a484ec3"
      url: "https://pub.dev"
    source: hosted
    version: "4.0.4"
  build_config:
    dependency: transitive
    description:
      name: build_config
      sha256: "4f64382b97504dc2fcdf487d5aae33418e08b4703fc21249e4db6d804a4d0187"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.0"
  build_daemon:
    dependency: transitive
    description:
      name: build_daemon
      sha256: bf05f6e12cfea92d3c09308d7bcdab1906cd8a179b023269eed00c071004b957
      url: "https://pub.dev"
    source: hosted
    version: "4.1.1"
  build_runner:
    dependency: "direct dev"
    description:
      name: build_runner
      sha256: b4d854962a32fd9f8efc0b76f98214790b833af8b2e9b2df6bfc927c0415a072
      url: "https://pub.dev"
    source: hosted
    version: "2.10.5"
  built_collection:
    dependency: transitive
    description:
      name: built_collection
      sha256: "376e3dd27b51ea877c28d525560790aee2e6fbb5f20e2f85d5081027d94e2100"
      url: "https://pub.dev"
    source: hosted
    version: "5.1.1"
  built_value:
    dependency: transitive
    description:
      name: built_value
      sha256: "7931c90b84bc573fef103548e354258ae4c9d28d140e41961df6843c5d60d4d8"
      url: "https://pub.dev"
    source: hosted
    version: "8.12.3"
  cached_network_image:
    dependency: "direct main"
    description:
      name: cached_network_image
      sha256: "7c1183e361e5c8b0a0f21a28401eecdbde252441106a9816400dd4c2b2424916"
      url: "https://pub.dev"
    source: hosted
    version: "3.4.1"
  cached_network_image_platform_interface:
    dependency: transitive
    description:
      name: cached_network_image_platform_interface
      sha256: "35814b016e37fbdc91f7ae18c8caf49ba5c88501813f73ce8a07027a395e2829"
      url: "https://pub.dev"
    source: hosted
    version: "4.1.1"
  cached_network_image_web:
    dependency: transitive
    description:
      name: cached_network_image_web
      sha256: "980842f4e8e2535b8dbd3d5ca0b1f0ba66bf61d14cc3a17a9b4788a3685ba062"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.1"
  camera:
    dependency: "direct main"
    description:
      name: camera
      sha256: eefad89f262a873f38d21e5eec853461737ea074d7c9ede39f3ceb135d201cab
      url: "https://pub.dev"
    source: hosted
    version: "0.11.3"
  camera_android_camerax:
    dependency: transitive
    description:
      name: camera_android_camerax
      sha256: bc7a96998258adddd0b653dd693b0874537707d58b0489708f2a646e4f124246
      url: "https://pub.dev"
    source: hosted
    version: "0.6.27"
  camera_avfoundation:
    dependency: transitive
    description:
      name: camera_avfoundation
      sha256: "087a9fadef20325cb246b4c13344a3ce8e408acfc3e0c665ebff0ec3144d7163"
      url: "https://pub.dev"
    source: hosted
    version: "0.9.22+8"
  camera_platform_interface:
    dependency: transitive
    description:
      name: camera_platform_interface
      sha256: "98cfc9357e04bad617671b4c1f78a597f25f08003089dd94050709ae54effc63"
      url: "https://pub.dev"
    source: hosted
    version: "2.12.0"
  camera_web:
    dependency: transitive
    description:
      name: camera_web
      sha256: "57f49a635c8bf249d07fb95eb693d7e4dda6796dedb3777f9127fb54847beba7"
      url: "https://pub.dev"
    source: hosted
    version: "0.3.5+3"
  characters:
    dependency: transitive
    description:
      name: characters
      sha256: f71061c654a3380576a52b451dd5532377954cf9dbd272a78fc8479606670803
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  charcode:
    dependency: transitive
    description:
      name: charcode
      sha256: fb0f1107cac15a5ea6ef0a6ef71a807b9e4267c713bb93e00e92d737cc8dbd8a
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  checked_yaml:
    dependency: transitive
    description:
      name: checked_yaml
      sha256: "959525d3162f249993882720d52b7e0c833978df229be20702b33d48d91de70f"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.4"
  cli_config:
    dependency: transitive
    description:
      name: cli_config
      sha256: ac20a183a07002b700f0c25e61b7ee46b23c309d76ab7b7640a028f18e4d99ec
      url: "https://pub.dev"
    source: hosted
    version: "0.2.0"
  cli_util:
    dependency: transitive
    description:
      name: cli_util
      sha256: ff6785f7e9e3c38ac98b2fb035701789de90154024a75b6cb926445e83197d1c
      url: "https://pub.dev"
    source: hosted
    version: "0.4.2"
  clock:
    dependency: transitive
    description:
      name: clock
      sha256: fddb70d9b5277016c77a80201021d40a2247104d9f4aa7bab7157b7e3f05b84b
      url: "https://pub.dev"
    source: hosted
    version: "1.1.2"
  code_assets:
    dependency: transitive
    description:
      name: code_assets
      sha256: ae0db647e668cbb295a3527f0938e4039e004c80099dce2f964102373f5ce0b5
      url: "https://pub.dev"
    source: hosted
    version: "0.19.10"
  code_builder:
    dependency: transitive
    description:
      name: code_builder
      sha256: "6a6cab2ba4680d6423f34a9b972a4c9a94ebe1b62ecec4e1a1f2cba91fd1319d"
      url: "https://pub.dev"
    source: hosted
    version: "4.11.1"
  collection:
    dependency: transitive
    description:
      name: collection
      sha256: "2f5709ae4d3d59dd8f7cd309b4e023046b57d8a6c82130785d2b0e5868084e76"
      url: "https://pub.dev"
    source: hosted
    version: "1.19.1"
  connectivity_plus:
    dependency: "direct main"
    description:
      name: connectivity_plus
      sha256: b5e72753cf63becce2c61fd04dfe0f1c430cc5278b53a1342dc5ad839eab29ec
      url: "https://pub.dev"
    source: hosted
    version: "6.1.5"
  connectivity_plus_platform_interface:
    dependency: transitive
    description:
      name: connectivity_plus_platform_interface
      sha256: "42657c1715d48b167930d5f34d00222ac100475f73d10162ddf43e714932f204"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.1"
  convert:
    dependency: transitive
    description:
      name: convert
      sha256: b30acd5944035672bc15c6b7a8b47d773e41e2f17de064350988c5d02adb1c68
      url: "https://pub.dev"
    source: hosted
    version: "3.1.2"
  coverage:
    dependency: transitive
    description:
      name: coverage
      sha256: "5da775aa218eaf2151c721b16c01c7676fbfdd99cebba2bf64e8b807a28ff94d"
      url: "https://pub.dev"
    source: hosted
    version: "1.15.0"
  cross_file:
    dependency: transitive
    description:
      name: cross_file
      sha256: "701dcfc06da0882883a2657c445103380e53e647060ad8d9dfb710c100996608"
      url: "https://pub.dev"
    source: hosted
    version: "0.3.5+1"
  crypto:
    dependency: transitive
    description:
      name: crypto
      sha256: c8ea0233063ba03258fbcf2ca4d6dadfefe14f02fab57702265467a19f27fadf
      url: "https://pub.dev"
    source: hosted
    version: "3.0.7"
  csslib:
    dependency: transitive
    description:
      name: csslib
      sha256: "09bad715f418841f976c77db72d5398dc1253c21fb9c0c7f0b0b985860b2d58e"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.2"
  csv:
    dependency: "direct main"
    description:
      name: csv
      sha256: c6aa2679b2a18cb57652920f674488d89712efaf4d3fdf2e537215b35fc19d6c
      url: "https://pub.dev"
    source: hosted
    version: "6.0.0"
  cupertino_icons:
    dependency: "direct main"
    description:
      name: cupertino_icons
      sha256: ba631d1c7f7bef6b729a622b7b752645a2d076dba9976925b8f25725a30e1ee6
      url: "https://pub.dev"
    source: hosted
    version: "1.0.8"
  dart_style:
    dependency: transitive
    description:
      name: dart_style
      sha256: a9c30492da18ff84efe2422ba2d319a89942d93e58eb0b73d32abe822ef54b7b
      url: "https://pub.dev"
    source: hosted
    version: "3.1.3"
  dbus:
    dependency: transitive
    description:
      name: dbus
      sha256: "79e0c23480ff85dc68de79e2cd6334add97e48f7f4865d17686dd6ea81a47e8c"
      url: "https://pub.dev"
    source: hosted
    version: "0.7.11"
  dio:
    dependency: "direct main"
    description:
      name: dio
      sha256: d90ee57923d1828ac14e492ca49440f65477f4bb1263575900be731a3dac66a9
      url: "https://pub.dev"
    source: hosted
    version: "5.9.0"
  dio_web_adapter:
    dependency: transitive
    description:
      name: dio_web_adapter
      sha256: "7586e476d70caecaf1686d21eee7247ea43ef5c345eab9e0cc3583ff13378d78"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.1"
  drift:
    dependency: "direct main"
    description:
      name: drift
      sha256: "5ea2f718558c0b31d4b8c36a3d8e5b7016f1265f46ceb5a5920e16117f0c0d6a"
      url: "https://pub.dev"
    source: hosted
    version: "2.30.1"
  drift_dev:
    dependency: "direct dev"
    description:
      name: drift_dev
      sha256: "892dfb5d69d9e604bdcd102a9376de8b41768cf7be93fd26b63cfc4d8f91ad5f"
      url: "https://pub.dev"
    source: hosted
    version: "2.30.1"
  fake_async:
    dependency: transitive
    description:
      name: fake_async
      sha256: "5368f224a74523e8d2e7399ea1638b37aecfca824a3cc4dfdf77bf1fa905ac44"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.3"
  ffi:
    dependency: transitive
    description:
      name: ffi
      sha256: d07d37192dbf97461359c1518788f203b0c9102cfd2c35a716b823741219542c
      url: "https://pub.dev"
    source: hosted
    version: "2.1.5"
  file:
    dependency: transitive
    description:
      name: file
      sha256: a3b4f84adafef897088c160faf7dfffb7696046cb13ae90b508c2cbc95d3b8d4
      url: "https://pub.dev"
    source: hosted
    version: "7.0.1"
  fixnum:
    dependency: transitive
    description:
      name: fixnum
      sha256: b6dc7065e46c974bc7c5f143080a6764ec7a4be6da1285ececdc37be96de53be
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  flutter:
    dependency: "direct main"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_cache_manager:
    dependency: "direct main"
    description:
      name: flutter_cache_manager
      sha256: "400b6592f16a4409a7f2bb929a9a7e38c72cceb8ffb99ee57bbf2cb2cecf8386"
      url: "https://pub.dev"
    source: hosted
    version: "3.4.1"
  flutter_launcher_icons:
    dependency: "direct dev"
    description:
      name: flutter_launcher_icons
      sha256: "10f13781741a2e3972126fae08393d3c4e01fa4cd7473326b94b72cf594195e7"
      url: "https://pub.dev"
    source: hosted
    version: "0.14.4"
  flutter_lints:
    dependency: "direct dev"
    description:
      name: flutter_lints
      sha256: "3105dc8492f6183fb076ccf1f351ac3d60564bff92e20bfc4af9cc1651f4e7e1"
      url: "https://pub.dev"
    source: hosted
    version: "6.0.0"
  flutter_native_splash:
    dependency: "direct main"
    description:
      name: flutter_native_splash
      sha256: "4fb9f4113350d3a80841ce05ebf1976a36de622af7d19aca0ca9a9911c7ff002"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.7"
  flutter_plugin_android_lifecycle:
    dependency: transitive
    description:
      name: flutter_plugin_android_lifecycle
      sha256: ee8068e0e1cd16c4a82714119918efdeed33b3ba7772c54b5d094ab53f9b7fd1
      url: "https://pub.dev"
    source: hosted
    version: "2.0.33"
  flutter_riverpod:
    dependency: "direct main"
    description:
      name: flutter_riverpod
      sha256: a3cd0547353c1990bf5ad64f73143e5ce7a780409639559ad83a743ff3b945e4
      url: "https://pub.dev"
    source: hosted
    version: "3.2.0"
  flutter_secure_storage:
    dependency: "direct main"
    description:
      name: flutter_secure_storage
      sha256: "9cad52d75ebc511adfae3d447d5d13da15a55a92c9410e50f67335b6d21d16ea"
      url: "https://pub.dev"
    source: hosted
    version: "9.2.4"
  flutter_secure_storage_linux:
    dependency: transitive
    description:
      name: flutter_secure_storage_linux
      sha256: be76c1d24a97d0b98f8b54bce6b481a380a6590df992d0098f868ad54dc8f688
      url: "https://pub.dev"
    source: hosted
    version: "1.2.3"
  flutter_secure_storage_macos:
    dependency: transitive
    description:
      name: flutter_secure_storage_macos
      sha256: "6c0a2795a2d1de26ae202a0d78527d163f4acbb11cde4c75c670f3a0fc064247"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.3"
  flutter_secure_storage_platform_interface:
    dependency: transitive
    description:
      name: flutter_secure_storage_platform_interface
      sha256: cf91ad32ce5adef6fba4d736a542baca9daf3beac4db2d04be350b87f69ac4a8
      url: "https://pub.dev"
    source: hosted
    version: "1.1.2"
  flutter_secure_storage_web:
    dependency: transitive
    description:
      name: flutter_secure_storage_web
      sha256: f4ebff989b4f07b2656fb16b47852c0aab9fed9b4ec1c70103368337bc1886a9
      url: "https://pub.dev"
    source: hosted
    version: "1.2.1"
  flutter_secure_storage_windows:
    dependency: transitive
    description:
      name: flutter_secure_storage_windows
      sha256: b20b07cb5ed4ed74fc567b78a72936203f587eba460af1df11281c9326cd3709
      url: "https://pub.dev"
    source: hosted
    version: "3.1.2"
  flutter_svg:
    dependency: "direct main"
    description:
      name: flutter_svg
      sha256: "87fbd7c534435b6c5d9d98b01e1fd527812b82e68ddd8bd35fc45ed0fa8f0a95"
      url: "https://pub.dev"
    source: hosted
    version: "2.2.3"
  flutter_test:
    dependency: "direct dev"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_web_plugins:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  frontend_server_client:
    dependency: transitive
    description:
      name: frontend_server_client
      sha256: f64a0333a82f30b0cca061bc3d143813a486dc086b574bfb233b7c1372427694
      url: "https://pub.dev"
    source: hosted
    version: "4.0.0"
  glob:
    dependency: transitive
    description:
      name: glob
      sha256: c3f1ee72c96f8f78935e18aa8cecced9ab132419e8625dc187e1c2408efc20de
      url: "https://pub.dev"
    source: hosted
    version: "2.1.3"
  google_fonts:
    dependency: "direct main"
    description:
      name: google_fonts
      sha256: ba03d03bcaa2f6cb7bd920e3b5027181db75ab524f8891c8bc3aa603885b8055
      url: "https://pub.dev"
    source: hosted
    version: "6.3.3"
  graphs:
    dependency: transitive
    description:
      name: graphs
      sha256: "741bbf84165310a68ff28fe9e727332eef1407342fca52759cb21ad8177bb8d0"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.2"
  hooks:
    dependency: transitive
    description:
      name: hooks
      sha256: "5410b9f4f6c9f01e8ff0eb81c9801ea13a3c3d39f8f0b1613cda08e27eab3c18"
      url: "https://pub.dev"
    source: hosted
    version: "0.20.5"
  html:
    dependency: transitive
    description:
      name: html
      sha256: "6d1264f2dffa1b1101c25a91dff0dc2daee4c18e87cd8538729773c073dbf602"
      url: "https://pub.dev"
    source: hosted
    version: "0.15.6"
  http:
    dependency: "direct main"
    description:
      name: http
      sha256: "87721a4a50b19c7f1d49001e51409bddc46303966ce89a65af4f4e6004896412"
      url: "https://pub.dev"
    source: hosted
    version: "1.6.0"
  http_multi_server:
    dependency: transitive
    description:
      name: http_multi_server
      sha256: aa6199f908078bb1c5efb8d8638d4ae191aac11b311132c3ef48ce352fb52ef8
      url: "https://pub.dev"
    source: hosted
    version: "3.2.2"
  http_parser:
    dependency: transitive
    description:
      name: http_parser
      sha256: "178d74305e7866013777bab2c3d8726205dc5a4dd935297175b19a23a2e66571"
      url: "https://pub.dev"
    source: hosted
    version: "4.1.2"
  image:
    dependency: "direct main"
    description:
      name: image
      sha256: "492bd52f6c4fbb6ee41f781ff27765ce5f627910e1e0cbecfa3d9add5562604c"
      url: "https://pub.dev"
    source: hosted
    version: "4.7.2"
  intl:
    dependency: "direct main"
    description:
      name: intl
      sha256: "3df61194eb431efc39c4ceba583b95633a403f46c9fd341e550ce0bfa50e9aa5"
      url: "https://pub.dev"
    source: hosted
    version: "0.20.2"
  io:
    dependency: transitive
    description:
      name: io
      sha256: dfd5a80599cf0165756e3181807ed3e77daf6dd4137caaad72d0b7931597650b
      url: "https://pub.dev"
    source: hosted
    version: "1.0.5"
  js:
    dependency: transitive
    description:
      name: js
      sha256: f2c445dce49627136094980615a031419f7f3eb393237e4ecd97ac15dea343f3
      url: "https://pub.dev"
    source: hosted
    version: "0.6.7"
  json_annotation:
    dependency: transitive
    description:
      name: json_annotation
      sha256: "1ce844379ca14835a50d2f019a3099f419082cfdd231cd86a142af94dd5c6bb1"
      url: "https://pub.dev"
    source: hosted
    version: "4.9.0"
  leak_tracker:
    dependency: transitive
    description:
      name: leak_tracker
      sha256: "33e2e26bdd85a0112ec15400c8cbffea70d0f9c3407491f672a2fad47915e2de"
      url: "https://pub.dev"
    source: hosted
    version: "11.0.2"
  leak_tracker_flutter_testing:
    dependency: transitive
    description:
      name: leak_tracker_flutter_testing
      sha256: "1dbc140bb5a23c75ea9c4811222756104fbcd1a27173f0c34ca01e16bea473c1"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.10"
  leak_tracker_testing:
    dependency: transitive
    description:
      name: leak_tracker_testing
      sha256: "8d5a2d49f4a66b49744b23b018848400d23e54caf9463f4eb20df3eb8acb2eb1"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.2"
  lints:
    dependency: transitive
    description:
      name: lints
      sha256: a5e2b223cb7c9c8efdc663ef484fdd95bb243bff242ef5b13e26883547fce9a0
      url: "https://pub.dev"
    source: hosted
    version: "6.0.0"
  logging:
    dependency: transitive
    description:
      name: logging
      sha256: c8245ada5f1717ed44271ed1c26b8ce85ca3228fd2ffdb75468ab01979309d61
      url: "https://pub.dev"
    source: hosted
    version: "1.3.0"
  matcher:
    dependency: transitive
    description:
      name: matcher
      sha256: dc58c723c3c24bf8d3e2d3ad3f2f9d7bd9cf43ec6feaa64181775e60190153f2
      url: "https://pub.dev"
    source: hosted
    version: "0.12.17"
  material_color_utilities:
    dependency: transitive
    description:
      name: material_color_utilities
      sha256: f7142bb1154231d7ea5f96bc7bde4bda2a0945d2806bb11670e30b850d56bdec
      url: "https://pub.dev"
    source: hosted
    version: "0.11.1"
  meta:
    dependency: transitive
    description:
      name: meta
      sha256: "23f08335362185a5ea2ad3a4e597f1375e78bce8a040df5c600c8d3552ef2394"
      url: "https://pub.dev"
    source: hosted
    version: "1.17.0"
  mime:
    dependency: transitive
    description:
      name: mime
      sha256: "41a20518f0cb1256669420fdba0cd90d21561e560ac240f26ef8322e45bb7ed6"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
  native_toolchain_c:
    dependency: transitive
    description:
      name: native_toolchain_c
      sha256: f8872ea6c7a50ce08db9ae280ca2b8efdd973157ce462826c82f3c3051d154ce
      url: "https://pub.dev"
    source: hosted
    version: "0.17.2"
  nm:
    dependency: transitive
    description:
      name: nm
      sha256: "2c9aae4127bdc8993206464fcc063611e0e36e72018696cd9631023a31b24254"
      url: "https://pub.dev"
    source: hosted
    version: "0.5.0"
  node_preamble:
    dependency: transitive
    description:
      name: node_preamble
      sha256: "6e7eac89047ab8a8d26cf16127b5ed26de65209847630400f9aefd7cd5c730db"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.2"
  objective_c:
    dependency: transitive
    description:
      name: objective_c
      sha256: "55eb67ede1002d9771b3f9264d2c9d30bc364f0267bc1c6cc0883280d5f0c7cb"
      url: "https://pub.dev"
    source: hosted
    version: "9.2.2"
  octo_image:
    dependency: transitive
    description:
      name: octo_image
      sha256: "34faa6639a78c7e3cbe79be6f9f96535867e879748ade7d17c9b1ae7536293bd"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.0"
  package_config:
    dependency: transitive
    description:
      name: package_config
      sha256: f096c55ebb7deb7e384101542bfba8c52696c1b56fca2eb62827989ef2353bbc
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  path:
    dependency: "direct main"
    description:
      name: path
      sha256: "75cca69d1490965be98c73ceaea117e8a04dd21217b37b292c9ddbec0d955bc5"
      url: "https://pub.dev"
    source: hosted
    version: "1.9.1"
  path_parsing:
    dependency: transitive
    description:
      name: path_parsing
      sha256: "883402936929eac138ee0a45da5b0f2c80f89913e6dc3bf77eb65b84b409c6ca"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  path_provider:
    dependency: "direct main"
    description:
      name: path_provider
      sha256: "50c5dd5b6e1aaf6fb3a78b33f6aa3afca52bf903a8a5298f53101fdaee55bbcd"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.5"
  path_provider_android:
    dependency: transitive
    description:
      name: path_provider_android
      sha256: f2c65e21139ce2c3dad46922be8272bb5963516045659e71bb16e151c93b580e
      url: "https://pub.dev"
    source: hosted
    version: "2.2.22"
  path_provider_foundation:
    dependency: transitive
    description:
      name: path_provider_foundation
      sha256: "2a376b7d6392d80cd3705782d2caa734ca4727776db0b6ec36ef3f1855197699"
      url: "https://pub.dev"
    source: hosted
    version: "2.6.0"
  path_provider_linux:
    dependency: transitive
    description:
      name: path_provider_linux
      sha256: f7a1fe3a634fe7734c8d3f2766ad746ae2a2884abe22e241a8b301bf5cac3279
      url: "https://pub.dev"
    source: hosted
    version: "2.2.1"
  path_provider_platform_interface:
    dependency: "direct dev"
    description:
      name: path_provider_platform_interface
      sha256: "88f5779f72ba699763fa3a3b06aa4bf6de76c8e5de842cf6f29e2e06476c2334"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  path_provider_windows:
    dependency: transitive
    description:
      name: path_provider_windows
      sha256: bd6f00dbd873bfb70d0761682da2b3a2c2fccc2b9e84c495821639601d81afe7
      url: "https://pub.dev"
    source: hosted
    version: "2.3.0"
  permission_handler:
    dependency: "direct main"
    description:
      name: permission_handler
      sha256: "59adad729136f01ea9e35a48f5d1395e25cba6cea552249ddbe9cf950f5d7849"
      url: "https://pub.dev"
    source: hosted
    version: "11.4.0"
  permission_handler_android:
    dependency: transitive
    description:
      name: permission_handler_android
      sha256: d3971dcdd76182a0c198c096b5db2f0884b0d4196723d21a866fc4cdea057ebc
      url: "https://pub.dev"
    source: hosted
    version: "12.1.0"
  permission_handler_apple:
    dependency: transitive
    description:
      name: permission_handler_apple
      sha256: f000131e755c54cf4d84a5d8bd6e4149e262cc31c5a8b1d698de1ac85fa41023
      url: "https://pub.dev"
    source: hosted
    version: "9.4.7"
  permission_handler_html:
    dependency: transitive
    description:
      name: permission_handler_html
      sha256: "38f000e83355abb3392140f6bc3030660cfaef189e1f87824facb76300b4ff24"
      url: "https://pub.dev"
    source: hosted
    version: "0.1.3+5"
  permission_handler_platform_interface:
    dependency: transitive
    description:
      name: permission_handler_platform_interface
      sha256: eb99b295153abce5d683cac8c02e22faab63e50679b937fa1bf67d58bb282878
      url: "https://pub.dev"
    source: hosted
    version: "4.3.0"
  permission_handler_windows:
    dependency: transitive
    description:
      name: permission_handler_windows
      sha256: "1a790728016f79a41216d88672dbc5df30e686e811ad4e698bfc51f76ad91f1e"
      url: "https://pub.dev"
    source: hosted
    version: "0.2.1"
  petitparser:
    dependency: transitive
    description:
      name: petitparser
      sha256: "1a97266a94f7350d30ae522c0af07890c70b8e62c71e8e3920d1db4d23c057d1"
      url: "https://pub.dev"
    source: hosted
    version: "7.0.1"
  platform:
    dependency: transitive
    description:
      name: platform
      sha256: "5d6b1b0036a5f331ebc77c850ebc8506cbc1e9416c27e59b439f917a902a4984"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.6"
  plugin_platform_interface:
    dependency: "direct dev"
    description:
      name: plugin_platform_interface
      sha256: "4820fbfdb9478b1ebae27888254d445073732dae3d6ea81f0b7e06d5dedc3f02"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.8"
  pool:
    dependency: transitive
    description:
      name: pool
      sha256: "978783255c543aa3586a1b3c21f6e9d720eb315376a915872c61ef8b5c20177d"
      url: "https://pub.dev"
    source: hosted
    version: "1.5.2"
  posix:
    dependency: transitive
    description:
      name: posix
      sha256: "6323a5b0fa688b6a010df4905a56b00181479e6d10534cecfecede2aa55add61"
      url: "https://pub.dev"
    source: hosted
    version: "6.0.3"
  pub_semver:
    dependency: transitive
    description:
      name: pub_semver
      sha256: "5bfcf68ca79ef689f8990d1160781b4bad40a3bd5e5218ad4076ddb7f4081585"
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  pubspec_parse:
    dependency: transitive
    description:
      name: pubspec_parse
      sha256: "0560ba233314abbed0a48a2956f7f022cce7c3e1e73df540277da7544cad4082"
      url: "https://pub.dev"
    source: hosted
    version: "1.5.0"
  recase:
    dependency: transitive
    description:
      name: recase
      sha256: e4eb4ec2dcdee52dcf99cb4ceabaffc631d7424ee55e56f280bc039737f89213
      url: "https://pub.dev"
    source: hosted
    version: "4.1.0"
  riverpod:
    dependency: transitive
    description:
      name: riverpod
      sha256: "9026676260f31bb5279cc5e59ca292145d8bab4aabede9aa2555c2a626ec66f1"
      url: "https://pub.dev"
    source: hosted
    version: "3.2.0"
  rxdart:
    dependency: transitive
    description:
      name: rxdart
      sha256: "5c3004a4a8dbb94bd4bf5412a4def4acdaa12e12f269737a5751369e12d1a962"
      url: "https://pub.dev"
    source: hosted
    version: "0.28.0"
  share_plus:
    dependency: "direct main"
    description:
      name: share_plus
      sha256: fce43200aa03ea87b91ce4c3ac79f0cecd52e2a7a56c7a4185023c271fbfa6da
      url: "https://pub.dev"
    source: hosted
    version: "10.1.4"
  share_plus_platform_interface:
    dependency: transitive
    description:
      name: share_plus_platform_interface
      sha256: cc012a23fc2d479854e6c80150696c4a5f5bb62cb89af4de1c505cf78d0a5d0b
      url: "https://pub.dev"
    source: hosted
    version: "5.0.2"
  shelf:
    dependency: transitive
    description:
      name: shelf
      sha256: e7dd780a7ffb623c57850b33f43309312fc863fb6aa3d276a754bb299839ef12
      url: "https://pub.dev"
    source: hosted
    version: "1.4.2"
  shelf_packages_handler:
    dependency: transitive
    description:
      name: shelf_packages_handler
      sha256: "89f967eca29607c933ba9571d838be31d67f53f6e4ee15147d5dc2934fee1b1e"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.2"
  shelf_static:
    dependency: transitive
    description:
      name: shelf_static
      sha256: c87c3875f91262785dade62d135760c2c69cb217ac759485334c5857ad89f6e3
      url: "https://pub.dev"
    source: hosted
    version: "1.1.3"
  shelf_web_socket:
    dependency: transitive
    description:
      name: shelf_web_socket
      sha256: "3632775c8e90d6c9712f883e633716432a27758216dfb61bd86a8321c0580925"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.0"
  sky_engine:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  source_gen:
    dependency: transitive
    description:
      name: source_gen
      sha256: "585bc140f20da42c584ece2df28f4d9ef2566955332b626f655957b3a8c8ad54"
      url: "https://pub.dev"
    source: hosted
    version: "4.1.2"
  source_map_stack_trace:
    dependency: transitive
    description:
      name: source_map_stack_trace
      sha256: c0713a43e323c3302c2abe2a1cc89aa057a387101ebd280371d6a6c9fa68516b
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  source_maps:
    dependency: transitive
    description:
      name: source_maps
      sha256: "190222579a448b03896e0ca6eca5998fa810fda630c1d65e2f78b3f638f54812"
      url: "https://pub.dev"
    source: hosted
    version: "0.10.13"
  source_span:
    dependency: transitive
    description:
      name: source_span
      sha256: "254ee5351d6cb365c859e20ee823c3bb479bf4a293c22d17a9f1bf144ce86f7c"
      url: "https://pub.dev"
    source: hosted
    version: "1.10.1"
  sqflite:
    dependency: transitive
    description:
      name: sqflite
      sha256: e2297b1da52f127bc7a3da11439985d9b536f75070f3325e62ada69a5c585d03
      url: "https://pub.dev"
    source: hosted
    version: "2.4.2"
  sqflite_android:
    dependency: transitive
    description:
      name: sqflite_android
      sha256: ecd684501ebc2ae9a83536e8b15731642b9570dc8623e0073d227d0ee2bfea88
      url: "https://pub.dev"
    source: hosted
    version: "2.4.2+2"
  sqflite_common:
    dependency: transitive
    description:
      name: sqflite_common
      sha256: "6ef422a4525ecc601db6c0a2233ff448c731307906e92cabc9ba292afaae16a6"
      url: "https://pub.dev"
    source: hosted
    version: "2.5.6"
  sqflite_darwin:
    dependency: transitive
    description:
      name: sqflite_darwin
      sha256: "279832e5cde3fe99e8571879498c9211f3ca6391b0d818df4e17d9fff5c6ccb3"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.2"
  sqflite_platform_interface:
    dependency: transitive
    description:
      name: sqflite_platform_interface
      sha256: "8dd4515c7bdcae0a785b0062859336de775e8c65db81ae33dd5445f35be61920"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.0"
  sqlite3:
    dependency: transitive
    description:
      name: sqlite3
      sha256: "3145bd74dcdb4fd6f5c6dda4d4e4490a8087d7f286a14dee5d37087290f0f8a2"
      url: "https://pub.dev"
    source: hosted
    version: "2.9.4"
  sqlite3_flutter_libs:
    dependency: "direct main"
    description:
      name: sqlite3_flutter_libs
      sha256: "1e800ebe7f85a80a66adacaa6febe4d5f4d8b75f244e9838a27cb2ffc7aec08d"
      url: "https://pub.dev"
    source: hosted
    version: "0.5.41"
  sqlparser:
    dependency: transitive
    description:
      name: sqlparser
      sha256: f52f5d5649dcc13ed198c4176ddef74bf6851c30f4f31603f1b37788695b93e2
      url: "https://pub.dev"
    source: hosted
    version: "0.43.0"
  stack_trace:
    dependency: transitive
    description:
      name: stack_trace
      sha256: "8b27215b45d22309b5cddda1aa2b19bdfec9df0e765f2de506401c071d38d1b1"
      url: "https://pub.dev"
    source: hosted
    version: "1.12.1"
  state_notifier:
    dependency: transitive
    description:
      name: state_notifier
      sha256: b8677376aa54f2d7c58280d5a007f9e8774f1968d1fb1c096adcb4792fba29bb
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  stream_channel:
    dependency: transitive
    description:
      name: stream_channel
      sha256: "969e04c80b8bcdf826f8f16579c7b14d780458bd97f56d107d3950fdbeef059d"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  stream_transform:
    dependency: transitive
    description:
      name: stream_transform
      sha256: ad47125e588cfd37a9a7f86c7d6356dde8dfe89d071d293f80ca9e9273a33871
      url: "https://pub.dev"
    source: hosted
    version: "2.1.1"
  string_scanner:
    dependency: transitive
    description:
      name: string_scanner
      sha256: "921cd31725b72fe181906c6a94d987c78e3b98c2e205b397ea399d4054872b43"
      url: "https://pub.dev"
    source: hosted
    version: "1.4.1"
  synchronized:
    dependency: transitive
    description:
      name: synchronized
      sha256: c254ade258ec8282947a0acbbc90b9575b4f19673533ee46f2f6e9b3aeefd7c0
      url: "https://pub.dev"
    source: hosted
    version: "3.4.0"
  term_glyph:
    dependency: transitive
    description:
      name: term_glyph
      sha256: "7f554798625ea768a7518313e58f83891c7f5024f88e46e7182a4558850a4b8e"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.2"
  test:
    dependency: transitive
    description:
      name: test
      sha256: "75906bf273541b676716d1ca7627a17e4c4070a3a16272b7a3dc7da3b9f3f6b7"
      url: "https://pub.dev"
    source: hosted
    version: "1.26.3"
  test_api:
    dependency: transitive
    description:
      name: test_api
      sha256: ab2726c1a94d3176a45960b6234466ec367179b87dd74f1611adb1f3b5fb9d55
      url: "https://pub.dev"
    source: hosted
    version: "0.7.7"
  test_core:
    dependency: transitive
    description:
      name: test_core
      sha256: "0cc24b5ff94b38d2ae73e1eb43cc302b77964fbf67abad1e296025b78deb53d0"
      url: "https://pub.dev"
    source: hosted
    version: "0.6.12"
  typed_data:
    dependency: transitive
    description:
      name: typed_data
      sha256: f9049c039ebfeb4cf7a7104a675823cd72dba8297f264b6637062516699fa006
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  universal_io:
    dependency: transitive
    description:
      name: universal_io
      sha256: f63cbc48103236abf48e345e07a03ce5757ea86285ed313a6a032596ed9301e2
      url: "https://pub.dev"
    source: hosted
    version: "2.3.1"
  url_launcher_linux:
    dependency: transitive
    description:
      name: url_launcher_linux
      sha256: d5e14138b3bc193a0f63c10a53c94b91d399df0512b1f29b94a043db7482384a
      url: "https://pub.dev"
    source: hosted
    version: "3.2.2"
  url_launcher_platform_interface:
    dependency: transitive
    description:
      name: url_launcher_platform_interface
      sha256: "552f8a1e663569be95a8190206a38187b531910283c3e982193e4f2733f01029"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.2"
  url_launcher_web:
    dependency: transitive
    description:
      name: url_launcher_web
      sha256: d0412fcf4c6b31ecfdb7762359b7206ffba3bbffd396c6d9f9c4616ece476c1f
      url: "https://pub.dev"
    source: hosted
    version: "2.4.2"
  url_launcher_windows:
    dependency: transitive
    description:
      name: url_launcher_windows
      sha256: "712c70ab1b99744ff066053cbe3e80c73332b38d46e5e945c98689b2e66fc15f"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.5"
  uuid:
    dependency: "direct main"
    description:
      name: uuid
      sha256: a11b666489b1954e01d992f3d601b1804a33937b5a8fe677bd26b8a9f96f96e8
      url: "https://pub.dev"
    source: hosted
    version: "4.5.2"
  vector_graphics:
    dependency: transitive
    description:
      name: vector_graphics
      sha256: a4f059dc26fc8295b5921376600a194c4ec7d55e72f2fe4c7d2831e103d461e6
      url: "https://pub.dev"
    source: hosted
    version: "1.1.19"
  vector_graphics_codec:
    dependency: transitive
    description:
      name: vector_graphics_codec
      sha256: "99fd9fbd34d9f9a32efd7b6a6aae14125d8237b10403b422a6a6dfeac2806146"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.13"
  vector_graphics_compiler:
    dependency: transitive
    description:
      name: vector_graphics_compiler
      sha256: d354a7ec6931e6047785f4db12a1f61ec3d43b207fc0790f863818543f8ff0dc
      url: "https://pub.dev"
    source: hosted
    version: "1.1.19"
  vector_math:
    dependency: transitive
    description:
      name: vector_math
      sha256: d530bd74fea330e6e364cda7a85019c434070188383e1cd8d9777ee586914c5b
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  vm_service:
    dependency: transitive
    description:
      name: vm_service
      sha256: "45caa6c5917fa127b5dbcfbd1fa60b14e583afdc08bfc96dda38886ca252eb60"
      url: "https://pub.dev"
    source: hosted
    version: "15.0.2"
  watcher:
    dependency: transitive
    description:
      name: watcher
      sha256: "1398c9f081a753f9226febe8900fce8f7d0a67163334e1c94a2438339d79d635"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.1"
  web:
    dependency: transitive
    description:
      name: web
      sha256: "868d88a33d8a87b18ffc05f9f030ba328ffefba92d6c127917a2ba740f9cfe4a"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  web_socket:
    dependency: transitive
    description:
      name: web_socket
      sha256: "34d64019aa8e36bf9842ac014bb5d2f5586ca73df5e4d9bf5c936975cae6982c"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.1"
  web_socket_channel:
    dependency: transitive
    description:
      name: web_socket_channel
      sha256: d645757fb0f4773d602444000a8131ff5d48c9e47adfe9772652dd1a4f2d45c8
      url: "https://pub.dev"
    source: hosted
    version: "3.0.3"
  webkit_inspection_protocol:
    dependency: transitive
    description:
      name: webkit_inspection_protocol
      sha256: "87d3f2333bb240704cd3f1c6b5b7acd8a10e7f0bc28c28dcf14e782014f4a572"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.1"
  win32:
    dependency: transitive
    description:
      name: win32
      sha256: d7cb55e04cd34096cd3a79b3330245f54cb96a370a1c27adb3c84b917de8b08e
      url: "https://pub.dev"
    source: hosted
    version: "5.15.0"
  xdg_directories:
    dependency: transitive
    description:
      name: xdg_directories
      sha256: "7a3f37b05d989967cdddcbb571f1ea834867ae2faa29725fd085180e0883aa15"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  xml:
    dependency: transitive
    description:
      name: xml
      sha256: "971043b3a0d3da28727e40ed3e0b5d18b742fa5a68665cca88e74b7876d5e025"
      url: "https://pub.dev"
    source: hosted
    version: "6.6.1"
  yaml:
    dependency: transitive
    description:
      name: yaml
      sha256: b9da305ac7c39faa3f030eccd175340f968459dae4af175130b3fc47e40d76ce
      url: "https://pub.dev"
    source: hosted
    version: "3.1.3"
sdks:
  dart: ">=3.10.7 <4.0.0"
  flutter: ">=3.38.4"
</file>

<file path="pubspec.yaml">
name: wingtip
description: "A new Flutter project."
publish_to: 'none'
version: 1.0.0+1
environment:
  sdk: ^3.10.7
dependencies:
  flutter:
    sdk: flutter
  cupertino_icons: ^1.0.8
  flutter_riverpod: ^3.0.0
  drift: ^2.0.0
  sqlite3_flutter_libs: ^0.5.0
  path_provider: ^2.0.0
  path: ^1.9.0
  google_fonts: ^6.2.1
  uuid: ^4.5.1
  flutter_secure_storage: ^9.2.2
  dio: ^5.4.0
  connectivity_plus: ^6.1.1
  http: ^1.2.0
  camera: ^0.11.0+2
  permission_handler: ^11.0.0
  image: ^4.0.0
  cached_network_image: ^3.3.0
  flutter_cache_manager: ^3.4.1
  csv: ^6.0.0
  intl: ^0.20.0
  share_plus: ^10.1.2
  flutter_native_splash: ^2.4.3
  flutter_svg: ^2.0.10+1
dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^6.0.0
  drift_dev: ^2.0.0
  build_runner: ^2.4.0
  path_provider_platform_interface: ^2.0.0
  plugin_platform_interface: ^2.1.0
  flutter_launcher_icons: ^0.14.1
flutter:
  uses-material-design: true
  assets:
    - assets/images/
flutter_launcher_icons:
  android: true
  ios: true
  image_path: "assets/icon/icon.png"
  adaptive_icon_background: "#000000"
  adaptive_icon_foreground: "assets/icon/icon.png"
  remove_alpha_ios: true
flutter_native_splash:
  color: "#000000"
  image: "assets/splash/splash.png"
  android: true
  ios: true
  web: false
  android_12:
    color: "#000000"
    image: "assets/splash/splash.png"
</file>

</files>
